# 杨辉三角

## 问题描述

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

![帕斯卡三角](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

## 示例

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

## 尝试的答案

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        // 定义结果集
        List<List<Integer>> result = new ArrayList<>();
        // 遍历每一行
        for(int i = 1; i <= numRows; i++){
            // 定义每一行的集合
            List<Integer> rows = new ArrayList<>();
			// 行内元素的数量等于行的值
            for(int j = 1; j <= i; j++){
                // 使用上一章的帕斯卡计算方式，要记住集合下标从0开始
                if(j == 1 || j == i) {
                    rows.add(1);
                } else {
                    // 此处应该是可以优化的，解决思路：使用一个数组临时保存上一个集合中的元素，这样可以不用遍历集合，改为使用下标取值
                    rows.add(result.get(i - 2).get(j - 2) + result.get(i - 2).get(j - 1));
                }
            }
            result.add(rows);
        }
        return result;
    }
}
```

## 执行结果：

```
执行用时 :
1 ms, 在所有 java 提交中击败了98.47%的用户
内存消耗 :
33.7 MB, 在所有 java 提交中击败了33.76%的用户
```

## LeetCode 上的最优代码

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        int[] ans=new int[numRows+2];
        ans[1]=1;
        List<List<Integer>> res=new LinkedList<>();        
        for(int i=1;i<=numRows;++i){
            List<Integer> temp=new LinkedList<>();
            for(int j=i;j>=2;--j){
                ans[j]=ans[j]+ans[j-1];
                temp.add(ans[j]);
            }
            temp.add(1);
            res.add(temp);
        }
        return res;
    }
}
```

