# 单例模式

## 懒汉模式 - 线程不安全

```java
/**
 * 懒汉模式 - 线程不安全的
 *  例如：当两个线程通过获取该对象的实例，当线程A与线程B都通过了 instance == null 的判断，但是返回的不是用一个实例
 */
public class Sample1 {

    // 构造方法私有化
    private Sample1() {
    }

    // 单例对象
    private volatile static Sample1 instance = null;

    // 静态工厂方法
    public static Sample1 getInstance() {
        if (instance == null) {  // A、B 同时执行到该步骤，则会生成两个instance
            instance = new Sample1();
        }
        return instance;
    }
}

```

## 懒汉模式 - 线程安全

```java
/**
 * 懒汉模式 - 线程安全的
 *  volatile + 双重检测机制 => 禁止指令重排，实现线程安全
 */
public class Sample3 {

    // 构造方法私有化
    private Sample3() {
    }

    // 单例对象 => 使用volatile 修饰，禁止指令重排
    private volatile static Sample3 instance = null;

    // 在执行 instance = new Sample2(); 时，底层JVM是进行了三次操作的
    // 1. memory = allocate() 分配对象的内存空间
    // 2. ctorInstance() 初始化对象
    // 3. instance = memory 设置instance指向刚分配的内存

    // 但是由于CPU的指令重排，具体的执行顺序可能发生改变，如：
    // 1. memory = allocate() 分配对象的内存空间
    // 3. instance = memory 设置instance指向刚分配的内存
    // 2. ctorInstance() 初始化对象

    // 如果两个线程，线程A在执行到 instance = memory 时，线程B得到的是尚未 ctorInstance() 的对象，此时就会出现空指针的问题
    // 解决方法就是：让instance在实例化时，不进行指令重排.

    // 静态工厂方法
    public static Sample3 getInstance() {
        if (instance == null) { // 双重检测机制 B
            synchronized (Sample3.class) { // 同步锁
                if (instance == null){
                    instance = new Sample3(); // A
                }
            }
        }
        return instance;
    }

}
```

## 饿汉模式 - 线程安全

```java
/**
 * 饿汉模式
 */
public class Sample4 {

    // 构造方法私有化
    private Sample4() {
    }

    // 单例对象 => 注意静态属性与静态代码块的执行顺序
    private volatile static Sample4 instance;

    static {
        instance = new Sample4();
    }

    // 静态工厂方法
    public static Sample4 getInstance() {
        return instance;
    }
}

```

## 枚举模式 - 线程安全(推荐)

```java
/**
 * 单例枚举模式
 */
public class Sample5 {

    // 构造方法私有化
    private Sample5() {
    }

    // 静态工厂方法
    public static Sample5 getInstance() {
        return Singleton.INSTANCE.getInstance();
    }

    private enum Singleton {
        INSTANCE;

        private Sample5 sample5;

        // 由于枚举的特性，JVM会保证该构造只会执行一次
        Singleton() {
            sample5 = new Sample5();
        }

        public Sample5 getInstance() {
            return sample5;
        }
    }
}
```

