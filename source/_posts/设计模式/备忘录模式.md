---
title: 备忘录模式
date: 2018-10-11 11:23:10
categories:
  - 设计模式
---
# 撤销功能的实现————备忘录模式
    
    在实现撤销时，首先必须保存软件系统的历史状态，当用户需要取消错误操作并且返回到某个历史状态时，可以取出事先保存的历史状态来覆盖当前状态，如下：

                        |—— 历史状态1   ←------
    |—— 历史状态集合     |—— 历史状态2          | 撤销
                        |—— 历史状态3          |
                        |—— 历史状态4   ←-- 当前状态

## 一、概述

    备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态恢复，即（Undo）撤销操作。

   备忘录模式的定义：
>   备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。

    备忘录模式的核心是备忘录类以及用于管理备忘录的负责人类的设计，结构如下：
    Originator(原发器)                          Memento(备忘录)
    - state:String                          - state:String
    + restoreMemento(Memento m)   ----→     + getState()
    + createMemento()                       + setState()
                                    -----------↑
                                    |
                            Caretaker(负责人)

在备忘录模式下有如下几个角色：
    
    Originator（原发器）： 一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复内部状态，一般将需要保存内部状态的类设计为原发器。

    Memento（备忘录）： 存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。

    Caretaker（负责人）： 负责人又称为管理者，他负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或者多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。

__需要注意的是， 除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用.__

__由于在备忘录中存储的是原发器的中间状态，因此需要防止原发器以外的其他对象访问备忘录，特别是不允许其他对象来修改备忘录。__

## 二、详细设计

### 首先应该存在一个原发器类Originator，在真实业务中，原发器类是一个具体的业务类，它包含一些用于存储成员数据的属性

    public class Originator{
        private String state;

        //创建一个备忘录
        public Memento createMemento(){
            return new Memento(this);
        }

        //根据备忘录对象恢复原发器状态
        public void restoreMemento(Memento m){
            state = m.state;
        }
        /** setter and getter*/
    }

### 备忘录类Memento，通常提供了与原发器相对应的属性，用于存储原发器的状态，典型的备忘录类模式如下：

>   除了 Originator 类之外，不允许其他类来调用备忘录类 Memento 的构造函数和相关方法，因此在这里，我们使用默认标识符来定义 Memento 类，即保证其包内可见。将 Originator 类与 Memento 类定义在用一个包中，保证了只有 Originator 类可以对 Memento 类进行访问。

    class Memento{
        private String state;

        public Memento(Originator o){
            state = o.getState();
        }

        /** setter and getter*/
    }

### 负责人类 Caretaker ，它用于保存备忘录对象，并提供 getMemento() 方法用于向客户端返回一个备忘录对象，原发器通过使用这个备忘录对象可以回到某个历史状态。

    public class Caretaker{
        private Memento memento;

        /** setter and getter*/
    }

>   在 Caretaker 类中不应该直接调用 Memento 中的状态改变方法，它的作用仅仅用于存储备忘录对象那个。将原发器备份生成的备忘录对象存储在其中，当用户需要对原发器进行恢复时再将存储在其中的备忘录对象取出。

## 举个栗子

>   实现多次撤销：  
>   在负责人类中定义一个集合来存储多个备忘录，每个备忘录负责保存一个历史状态，在撤销时可以对备忘录集合进行逆向遍历，回到一个指定的历史状态，而且还可以对备忘录集合进行正向遍历，实现重做（Redo）操作，即取消撤销，让对象状态得到恢复

>   负责人类：  

    class MementoCaretaker{
        private List mementoList = new ArrayList();
        //取出操作
        public ChessmanMemento getMemento(int i){
            return mementoList.get(i);
        }
        //保存操作
        public void setMemento(ChessmanMemento memento){
            mementoList.add(memento);
        }
    }

>   备忘录类：

    class ChessmanMemento{
        private String label;
        private int x;
        private int y;
        /** setter and getter*/
        /** constructor:label,x,y */
    }

>   原发器类：

    class Chessman{
        private String label;
        private int x;
        private int y;

        //保存状态
        public ChessmanMemento save(){
            return new ChessmanMemento(this.label,this.x,this.y);
        }

        //恢复状态
        public void restore(ChessMemento memento){
            this.label = memento.getLabel();
            this.x = memento.getX();
            this.y = memento.getY();
        }

        /** setter and getter*/
    }

>   测试类：

    class Client{
        private static int index = -1; //定义一个索引来记录当前状态所在位置  
        private static MementoCaretaker mc = new MementoCaretaker();  

        public static void main(String args[]) {  
            Chessman chess = new Chessman("车",1,1);  
            play(chess);          
            chess.setY(4);  
            play(chess);  
            chess.setX(5);  
            play(chess);      
            undo(chess,index);  
            undo(chess,index);    
            redo(chess,index);  
            redo(chess,index);  
        }  

        //下棋  
        public static void play(Chessman chess) {  
            mc.setMemento(chess.save()); //保存备忘录  
            index ++;   
            System.out.println("棋子" + chess.getLabel() + "当前位置为：" + "第" + chess.getX() + "行" + "第" + chess.getY() + "列。");  
        }  

        //悔棋  
        public static void undo(Chessman chess,int i) {  
            System.out.println("******悔棋******");  
            index --;   
            chess.restore(mc.getMemento(i-1)); //撤销到上一个备忘录  
            System.out.println("棋子" + chess.getLabel() + "当前位置为：" + "第" + chess.getX() + "行" + "第" + chess.getY() + "列。");  
        }  

        //撤销悔棋  
        public static void redo(Chessman chess,int i) {  
            System.out.println("******撤销悔棋******");   
            index ++;   
            chess.restore(mc.getMemento(i+1)); //恢复到下一个备忘录  
            System.out.println("棋子" + chess.getLabel() + "当前位置为：" + "第" + chess.getX() + "行" + "第" + chess.getY() + "列。");  
        }  
    }