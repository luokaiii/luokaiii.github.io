### 一、Spring

1. 对 Spring 的理解：Spring 是一个开源框架，主要核心是 IOC 和 AOP
   1. **IOC 控制反转**：
      1. 传统开发模式中，需要对象时要通过 new 或 getInstance 直接或间接创建对象。而 Spring 开发模式中，Spring 容器通过工厂模式为我们创建了所需要的对象，不需要自己创建，直接使用 spring 提供的对象即可，这就是控制反转的思想
   2. **DI 依赖注入：spring 通过 set 方法或带参构造，将所需的对象自动设置**
   3. **AOP 面向切面编程**：
      1. 在OOP中，我们将事物抽象为一个个对象；而在面向切面编程中，将这些对象的某些类似的方面抽成一个切面，对切面进行公共操作
      2. AOP底层是动态代理
      3. AOP 常用于 日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术
      4. 切点：AOP 的连接点，通过表达式或匹配的方式指明切入点，拦截方法
      5. 切面通知的类型：before、after、after-returning、after-throwing、around
      6. 目标对象：被切面通知的对象
2. Spring 中的设计模式
   1. 单例模式 - spring 中的 bean 默认为单例模式
   2. 模板方法模式 - 解决代码重复问题，如 restTemplate、JpaTemplate
   3. 工厂模式 - Spring 通过 BeanFactory 创建对象实例
3. Spring 的常用注解：
   1. @Required
   2. @Autowired
   3. @Bean
   4. @Qualifier
4. Spring 如何解决循环依赖
5. Spring 的作用
   1. 从Spring的核心模块 IOC、AOP、DI、JDBC、可扩展性方面思考
6. Spring的事务：@Transactional
7. BeanFactory 的实现类有哪些
   1. XMLBeanFactory、ApplicationContext
8. BeanFactory 与 ApplicationContext 的区别
9. 依赖注入的方式：set、constructor、静态工厂、实例工厂
10. 什么是 Spring的 Bean：java对象，被IOC容器初始化、装配、管理，且都是单例
    1. Spring 中的单例 Bean 不是线程安全的

### 二、SpringMVC

1. SpringMVC的工作原理
   1. 用户发送请求，被前端控制器 DispatchServlet 捕获；
   2. DispatchServlet 对 URL 进行解析，得到资源标识符，然后根据URL调用 HandlerMapping，将请求映射到处理器 HandlerExcutionChain；
   3. DispatchServlet 根据获得的 Handler 选择合适的 HandlerAdapter 适配器处理；
   4. Handler 处理完成后返回一个 ModalAndView（逻辑视图，非正式视图） 给 DispatchServlet
   5. DispatchServlet 通过 ViewResolver 解析器，将逻辑视图转化为真正的视图 View
   6. DispatchServlet 通过 model 解析参数，并展示最终的完整 view
2. 常用注解
   1. @RequestMapping 
   2. @RequestBody
   3. @ResponseBody

### 三、MyBatis

1. \# 和 $ 的区别
   1. \# 相当于对数据加上双引号，能防止sql注入
   2. $ 相当于直接显示数据，一般用于输入数据库对象，如表名
2. MyBatis 的编程步骤：
   1. 创建 SqlSessionFactory
   2. 通过 factory 创建 SqlSession
   3. 通过 session 执行数据库操作
   4. 调用 session.commit() 提交事务
   5. 调用 session.close() 关闭会话
3. JDBC 与 MyBatis 的比较：
   1. JDBC 中**创建、释放数据库连接，会影响系统性能**；MyBatis中使用数据库连接池解决的
   2. JDBC **SQL 存在于代码中，不易维护**；MyBatis 通过 Mapper.xml 与 代码分离
   3. JDBC 向sql **传参麻烦**； MyBatis 自动映射
   4. JDBC **对结果集解析麻烦**；MyBatis 可对 POJO 对象解析
4. MyBatis 的 mapper 接口调用有哪些要求
   1. 接口的方法名与 xml 中的 id 相同
   2. 接口的输入参数类型 与 xml 中的 parameterType 类型相同
   3. 接口的输出参数类型 与 xml 中的 resultType 类型相同
   4. xml 中的 namespace 是 接口的类路径

### 四、Hibernate



### 五、Quartz

Quartz 是一个开源的作业调度框架，灵活且简单。

1. TODO 查看之前的博客
2. 436页

### 六、Redis

1. Redis 的特点

   1. 由 C 语言编写的 NoSQL 数据库服务器，是一个 key-value 的存储系统，**支持丰富的数据类型**。
   2. **纯内存操作**，整个数据库都在内存中操作，定期通过异步将数据库数据 flush 到硬盘上保存。
   3. 单个**value 的最大限制是 1GB**，不像 Memcached 只能保存 1MB 的数据。
   4. 支持对 key-value 设置 **过期时间**
   5. 缺点是容易受到物理内存的限制，不能作为海量数据的高性能读写

2. Redis 将所有数据放入内存的原因：

   1. 为了达到最快的读写速度，并通过异步方式将数据写入磁盘，因此 redis 具有快速和持久化的特点
   2. 在内存越来越便宜的今天，redis 将越来越受欢迎

3. Redis 的性能问题：

   1. Master 写内存快照，会阻塞主线程的工作，造成间歇性暂停服务
      1. 因此 Master 最好不要写内存快照
   2. Master AOP 持久化，AOF 文件不断增大，过大时会影响 Master 重启恢复速度
      1. 因此 Master 对号不要做任何持久化操作
   3. Redis 主从复制的性能问题，Slave 和 Master 最好在同一个局域网内

4. Redis 的适用场景：

   1. 会话缓存（Session Cache）
   2. 全页缓存（FPC）
   3. 队列
   4. 排行榜/计数器
   5. 发布/订阅

5. Memcache 与 Redis 的区别

   1. | 区别      | Memcache                 | Redis          |
      | --------- | ------------------------ | -------------- |
      | 存储方式  | 全部存在内存中           | 部分存在硬盘上 |
      | 数据类型  | 相对简单                 | 复杂的类型     |
      | 底层模型  | 通信协议及底层实现不一样 |                |
      | Value大小 | 1MB                      | 1GB            |

6. **Redis 的数据类型：**

   1. String -- 字符串，value 为string或者long等
   2. Hash -- 字典，JSON格式
   3. List -- 列表，链表
   4. Set -- 集合，不重复值的组合
   5. Sorted Set -- 有序集合
      1. 与 Set 相比，多了个 score 权重

7. Redis 优缺点

   1. 优点：
      1. **性能极高**，能支持超过10w/s的读写频率
      2. **丰富的数据类型**，5种数据类型
      3. **原子性操作**
      4. **丰富的特性，如 发布/订阅，通知，过期等**
   2. 缺点：
      1. 修改配置文件、重启、将硬盘数据加载进内存，时间较久，且过程中redis不能提供服务
      2. 完整同步，需要生成rdb文件，占用CPU，消耗现网带宽
      3. 受限于内存大小，虽然 key 有过期策略，但还是需要提前预估和节约内存

8. Redis 的 持久化

   1. RDB 持久化：快照
      1. 适用于灾难恢复，文件十分紧凑，每次都保存整个数据集。
      2. 缺点，因为要备份整个数据集，因此备份间隔不能太短
   2. AOF 持久化：记录所有写操作，在服务器启动时执行，来还原数据集
      1. 默认每秒钟 fsync 一次；且 AOF 文件过大时，自动在后台重写
      2. AOF 文件体积要大于 RDB
   3. 无持久化：数据只在运行时存在

### 七、ActiveMQ

1. ActiveMQ 如何解决分布式事务？
   1. 如注册时的操作：a. 收集用户信息，保存至数据库 b. 向用户发送验证码；如果用户服务和验证码服务是相互独立的，拥有各自的数据库，那么就不能通过本地事务保证操作的原子性。
   2. 用户注册时，当信息保存成功后，向消息队列发送一跳消息。
   3. 验证码系统监听消息，一旦接收到消息，就给该用户发送验证码
   4. 防止消息重复发送：增加一个状态表，记录消息的处理状态，每次处理消息前，都检查改消息
2. ActiveMQ 消息发送失败怎么办？
   1. ActiveMQ 有两种通信方式，点到点模式 和 发布订阅模式
   2. 点到点模式：当消息发送不成功，消息会默认保存到 服务端，直到有消费者将其消费
   3. 发布订阅模式：默认只通知一次，如果接收不到就没有了，适用于送达率要求不高的情况
      1. 如果要求消息必须送达，不可丢失的话，需要配置持久订阅
      2. 每个订阅端一个ID，订阅时向 ActiveMQ 注册
      3. 且发布消息和接收消息配置发送模式为持久化
      4. 当客户端接收不到消息时，消息会持久化到服务端，直到客户端正常接收为止

### 八、Nginx

1. Nginx 的反向代理为什么能提升服务器性能？
   1. 像 JAVA、PHP 这类服务器的 IO 处理能力往往不高
   2. 而 Nginx 在 request 和 response 时，可以在读取完成前 buffer 住，这样交给后端的就是一个完整的 HTTP 请求，从而提高后端效率。
   3. 而不是断断续续的传递
2. Nginx 和 Apache 的优缺点
   1. Nginx 的优点：
      1. 轻量级，比 apache 占用更少的内存及资源
      2. 抗并发，nginx 处理请求是异步非阻塞的，apache 是阻塞型的
      3. 低资源低消耗高性能
      4. 高度模块化的设计，编写模块相对简单
      5. 社区活跃
   2. Apache 的优点：
      1. rewrite 功能强大
      2. 模块多
      3. 少 bug
      4. 更稳定

### 九、Restful

一种软件架构风格、设计风格，而不是标准，只提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件。

结构清晰、符合标准、易于理解、扩展方便