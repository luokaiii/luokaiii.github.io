---
title: 《JAVA 核心知识点整理》读书笔记 - 目录
date: 2019-12-01 14:00:00
tags: 
  - 读书笔记
  - 面试
categories:
  - JAVA 核心知识点整理
---

# 目录

1. JVM
   1. 线程
   2. JVM内存区域
      1. 程序计数器(线程私有)
      2. 虚拟机栈(线程私有)
      3. 本地方法区(线程私有)
      4. 堆(Heap-线程共享) - 运行时数据区
      5. 方法区/永久代(线程共享)
   3. JVM 运行时内存
      1. 新生代
         1. Eden区
         2. ServicorFrom
         3. ServicorTo
         4. MinorGC 的过程 (复制 > 清空 > 互换)
            1. eden、ServicorFrom 复制到 ServicorTo，年龄+1
            2. 清空 Eden、ServicorFrom
            3. ServicorTo 和 ServicorFrom 互换
      2. 老年代
      3. 永久代
   4. 垃圾回收算法
      1. 如何确定垃圾
         1. 引用计数法
         2. 可达性分析
      2. 标记清除算法(Mark-Sweep)
      3. 复制算法(Copying)
      4. 标记整理算法(Mark-Compact)
      5. 分代收集算法
         1. 新生代与复制算法
         2. 老年代与标记复制算法
   5. Java的四种引用类型
      1. 强引用
      2. 软引用
      3. 弱引用
      4. 虚引用
   6. GC分代收集算法 VS 分区收集算法
      1. 分代收集算法
         1. 新生代-复制算法
         2. 老年代-标记整理算法
      2. 分区收集算法
   7. GC 垃圾收集器
      1. Serial垃圾收集器(单线程、复制算法)
      2. ParNew 垃圾收集器(Serial+多线程)
      3. Parallel Scavenge 收集器(多线程复制算法、高效)
      4. Serial Old 收集器（单线程标记整理算法）
      5. Parallel Old 收集器（多线程标记整理算法）
      6. CMS 收集器（多线程标记整理算法）
         1. 初识标记
         2. 并发标记
         3. 重新标记
         4. 并发清除
      7. G1 收集器
   8. JAVA IO/NIO
      1. 阻塞 IO 模型
      2. 非阻塞 IO 模型
      3. 多路复用 IO 模型
      4. 信号驱动 IO 模型
      5. 异步 IO 模型
      6. JAVA IO包
      7. JAVA NIO
         1. NIO 的缓冲区
         2. NIO 的非阻塞
      8. Channel
      9. Buffer
      10. Selector
   9. JVM 类加载机制
      1. 加载
      2. 验证
      3. 准备
      4. 解析
      5. 符号引用
      6. 直接引用
      7. 初始化
      8. 类构造器<Client>
   10. 类加载器
       1. 启动类加载器（Bootstrap ClassLoader）
       2. 扩展类加载器（Extension ClassLoader）
       3. 应用程序类加载器（Application ClassLoader）
   11. 双亲委派
   12. OSGI（动态模型系统）
       1. 动态改变构造
       2. 模块化编程与热插拔
2. JAVA 集合
   1. 接口继承关系和实现
   2. List
      1. ArrayList（数组）
      2. Vector（数组、线程同步）
      3. LinkedList（链表）
   3. Set
      1. HashSet（Hash表）
      2. TreeSet（二叉树）
      3. LinkHashSet（HashSet+LinkHashMap）
   4. Map
      1. HashMap（数组+链表+红黑树）
         1. JAVA7实现
         2. JAVA8实现
      2. ConcurrentHashMap
         1. Segment 段
         2. 线程安全（Segment 继承 ReentrantLock 加锁）
         3. 并行度（默认16）
         4. Java8实现（引入了红黑树）
         5. HashTable（线程安全）
         6. TreeMap（可排序）
         7. LinkHashMap（记录插入顺序）
3. Java 多线程并发
   1. Java 并发知识库
   2. Java线程实现/创建方法
      1. 继承Thread类
      2. 实现Runnable接口
      3. ExecutorService、Callable<Class>、Future 有返回值线程
      4. 基于线程池的方式
   3. 四种线程池
      1. newCachedThreadPool
      2. newFixedThreadPool
      3. newScheduledThreadPool
      4. newSingleThreadExecutor
   4. 线程生命周期
      1. 新建状态（NEW）
      2. 就绪状态（RUNNABLE）
      3. 运行状态（RUNNING）
      4. 阻塞状态（BLOCKED）
         1. 等待阻塞（o.wait > 等待队列）
         2. 同步阻塞（lock > 锁池）
         3. 其他阻塞（sleep/join）
      5. 线程死亡（DEAD）
         1. 正常结束
         2. 异常结束
         3. 调用stop
   5. 终止线程的4中方式
      1. 正常运行结束
      2. 使用退出标志退出线程
      3. Interrupt方法结束线程
      4. stop方法终止线程（线程不安全）
   6. sleep 与 wait 的区别
   7. start 与 run 的区别
   8. Java 后台线程
   9. Java 锁
      1. 乐观锁
      2. 悲观锁
      3. 自旋锁
         1. 自旋锁的优缺点
         2. 自旋锁的时间阈值（1.6引入了适应性自旋锁）
         3. 自旋锁的开发
      4. Synchronized同步锁
         1. Synchronized 作用范围
         2. Synchronized 核心组件
         3. Synchronized 实现
      5. ReentrantLock
         1. Lock 接口的主要方法
         2. 非公平锁
         3. 公平锁
         4. ReentrantLock 与 Synchronized
         5. ReentrantLock 的实现
         6. Condition 类与 Object 锁方法的区别
         7. tryLock 、Lock、lockInterruptibly的区别
      6. Semaphore 信号量
         1. 实现互斥锁
         2. 代码实现
         3. Semaphore 与 ReentrantLock
      7. AutomicInteger
      8. 可重入锁（递归锁）
      9. 公平锁与非公平锁
         1. 公平锁（Fair）
         2. 非公平锁（Nofair）
      10. ReadWriteLock 读写锁
          1. 读锁
          2. 写锁
      11. 共享锁和独占锁
          1. 独占锁
          2. 共享锁
      12. 重量级锁（Mutex Lock）
      13. 轻量级锁
          1. 锁升级
      14. 偏向锁
      15. 分段锁
      16. 锁优化
          1. 减少锁持有时间
          2. 减小锁粒度
          3. 锁分离
          4. 锁粗化
          5. 锁消除
   10. 线程的基本方法
       1. 线程等待（wait）
       2. 线程睡眠（sleep）
       3. 线程让步（yield）
       4. 线程中断（interrupt）
       5. join 等待其他线程终止
       6. 为什么使用 join() 方法
       7. 线程唤醒 - notify
       8. 其他方法
   11. 线程上下文切换
       1. 进程
       2. 上下文
       3. 寄存器
       4. 程序计数器
       5. PCB-切换锁
       6. 上下文切换的活动
       7. 引起线程上下文切换的原因
   12. 同步锁与死锁
       1. 同步锁
       2. 死锁
   13. 线程池原理
       1. 线程复用
       2. 线程池的组成
       3. 拒绝策略
       4. java 线程池工作过程
   14. JAVA 阻塞队列原理
       1. 阻塞队列的主要方法
          1. 插入操作
          2. 获取数据操作
       2. Java 中的阻塞队列
       3. ArrayBlockingQueue（公平、非公平）
       4. LinkedBlockingQueue（两个独立锁提高并发）
       5. PriorityBlockingQueue（compareTo 排序实现优先）
       6. DelayQueue（缓存失效、定时任务）
       7. SynchronousQueue（不存储数据、可用于传递数据）
       8. LinkedTransferQueue
       9. LinkedBlockingQueue
   15. CyclicBarrier、CountDownLatch、Semaphore 的用法
       1. CountDownLatch（线程计数器）
       2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）
       3. Semaphore（信号量-控制同时访问的线程个数）
   16. volatile 关键字的作用
       1. 变量可见性
       2. 禁止重排序
       3. 比 Synchronized 更轻量级的同步锁
       4. 适用场景
   17. 如何在两个线程之间共享数据
       1. 将数据抽象成一个类，并将数据的操作作为这个类的方法
       2. Runnable 对象作为一个类的内部类
   18. ThreadLocal 作用（线程本地存储）
       1. ThreadLocalMap（线程的一个属性）
       2. 使用场景
   19. synchronized 和 ReentrantLock 的区别
       1. 共同点
       2. 不同点
   20. ConcurrentHashMap 并发
       1. 减小锁粒度
       2. ConcurrentHashMap 分段锁
          1. ConcurrentHashMap 是由Segment 数组结构和 HashEntry数组结构组成
   21. Java中用到的线程调度
       1. 抢占式调度
       2. 协同式调度
       3. JVM 的线程调度实现（抢占式调度）
       4. 线程让出CPU的情况
   22. 进程调度算法
       1. 优先调度算法
       2. 高优先权优先调度算法
       3. 基于时间片的轮转调度算法
   23. 什么是CAS（比较并交换-乐观锁机制-锁自旋）
       1. 概念及特性
       2. 原子包 java.util.concurrent.atomic（锁自旋）
       3. ABA 问题
   24. 什么是AQS（抽象的队列同步器）
       1. Exclusive 独占资源- ReentrantLock
       2. Share 共享资源 -Semaphore、CountDownLatch
       3. 同步器的实现是 ABS 核心（state资源状态计数）
       4. ReentrantReadWriteLock 实现独占和共享两种方法
4. JAVA 基础
   1. JAVA 异常分类及处理
      1. 概念
      2. 异常分类
         1. Error
         2. Exception
      3. 异常的处理方式
         1. 不处理，抛出给调用者（throw、throws）
         2. try catch 捕获异常
      4. throw 和 throws 的区别
         1. 位置不同
         2. 功能不同
   2. Java 反射
      1. 动态语言
      2. 反射机制概念（运行状态中知道类所有的属性和方法）
      3. 反射的应用场合
         1. 编译时类型和运行时类型
         2. 编译时类型无法获取具体方法
      4. Java 反射API
         1. 反射 API 用来生成JVM 中的类、接口或者对象的信息
      5. 反射使用步骤（获取Class对象、调用对象方法）
      6. 获取Class对象的3种方法
         1. 调用某个对象的getClass（）方法
         2. 调用某个类的 class 属性来获取该类对应的 Class 对象
         3. 使用 Class 类中的 forName() 静态方法（最安全、性能最好）
      7. 创建对象的两种方法
         1. Class 对象的 newInstance()
         2. 调用 Constructor 对象的 newInstance()
   3. JAVA 注解
      1. 概念
      2. 四种标准元注解
         1. @Target 修饰的对象范围
         2. @Rentention 定义被保留的时间长短
         3. @Document 描述javadoc
         4. @Inherited 阐述某个被标注的类型是被继承的
      3. 注解处理器
   4. JAVA 内部类
      1. 静态内部类
      2. 成员内部类
      3. 局部内部类（定义在方法中的类）
      4. 匿名内部类（要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用）
   5. JAVA 泛型
      1. 泛型方法（<E>）
      2. 泛型类 （<T>）
      3. 类型通配符 ？
      4. 类型擦除
   6. JAVA 序列化（创建可复用的Java对象）
      1. 持久化对象及其状态到内存或者硬盘
      2. 序列化对象 以字节数组保存-静态成员不保存
      3. 序列化用户远程对象传输
      4. Serializable 实现序列化
      5. ObjectOutputStream 和 ObjectInputStream 对对象进行序列化和反序列化
      6. writeObject 和 readObject 自定义序列化策略
      7. 序列化ID
      8. 序列化并不保存静态变量
      9. 序列化子父类说明
      10. Transient 关键字阻止该变量被序列化到文件中
   7. JAVA 复制
      1. 直接赋值复制
      2. 浅复制（复制引用但不复制引用的对象）
      3. 深复制（复制对象和其应用对象）
      4. 序列化（深 clone 实现）
5. Spring 原理
   1. Spring 特性
      1. 轻量级
      2. 控制反转
      3. 面向切面
      4. 容器
      5. 框架集合
   2. Spring 核心组件
   3. Spring 常用模块
   4. Spring 主要包
   5. Spring 常用注解
   6. Spring 第三方结合
   7. Spring IOC 原理
      1. 概念
      2. Spring 容器高层视图
      3. IOC 容器实现
         1. BeanFactory-框架基础设施
            1. BeanDefinitionRegistry 注册表
            2. BeanFactory 顶层接口
            3. ListableBeanFactory
            4. HibernarchicalBeanFactory 父子级联
            5. ConfigurableBeanFactory
            6. AutowireCapableBeanFacotry自动装配
            7. SingletonBeanRegistry 运行期间注册单例Bean
            8. 依赖日志框架
         2. ApplicationContext 面向开发应用
         3. WebApplication 体系架构
      4. Spring Bean 作用域
         1. singleton ：单例模式（多线程下不安全）
         2. prototype ：原型模式，每次使用时创建
         3. request ： 一次request 一个实例
         4. session 
         5. global session
      5. Spring Bean 生命周期
         1. 实例化
         2. IOC 依赖注入
         3. setBeanName 实现
         4. BeanFactoryAware 实现
         5. ApplicationContextAware 实现
         6. postProcessBeforeInitialization 接口实现-初始化预处理
         7. init-method
         8. postProcessAfterInitialization
         9. Destroy 过期自动清理阶段
         10. destroy-method 自配置清理
      6. Spirng 依赖注入四种方式
         1. 构造器注入
         2. setter 方法注入
         3. 静态工厂注入
         4. 实例工厂
      7. 五种不同方式的自动装配
   8. Spring AOP 原理
      1. 概念
      2. AOP 核心概念
      3. AOP 两种代理方式
         1. JDK 动态接口代理
         2. CGLib 动态代理
      4. 实现原理
   9. Spring MVC 原理
      1. SpringMVC 流程
         1. Http 请求到 DispatcherServlet
         2. HandlerMapping 寻找处理器
         3. 调用处理器 Controller
         4. Controller 调用业务逻辑处理后，返回ModelAndView
         5. DispatcherServlet 查询 ModelAndView
         6. ModelAndView 反馈浏览器 Http
      2. SpringMVC 常用注解
   10. Spring Boot 原理
       1. 创建独立的 Spring 应用程序
       2. 嵌入的Tomcat，无需部署War文件
       3. 简化Maven 配置
       4. 自动配置 spirng
       5. 提供生产就绪型功能，如指标、健康检查和外部配置
       6. 绝对没有代码生成和对xml没有要求配置
   11. JPA 原理
       1. 事务
       2. 本地事务
       3. 分布式事务
       4. 两阶段提交
          1. 准备阶段
          2. 提交阶段
   12. Mybatis 缓存
       1. Mybatis 的一级缓存原理（sqlsession 级别）
       2. 二级缓存原理（mapper基本）
          1. 具体使用需要配置
   13. Tomcat架构
6. 微服务
   1. 服务注册与发现
      1. 客户端注册（zookeeper）
      2. 第三方注册（独立的服务registrar）
      3. 客户端发现
      4. 服务端发现
      5. consul
      6. Eureka
      7. SmartStack
      8. Etcd
   2. API网关
      1. 请求转发
      2. 响应合并
      3. 协议转换
      4. 数据转换
      5. 安全认证
   3. 配置中心
      1. zookeeper 配置中心
      2. 配置中心数据分类
   4. 事件调度（kafka）
   5. 服务跟踪（starter-sleuth）
   6. 服务熔断（hystrix）
      1. hystrix 断路器机制
   7. API管理
7. Netty 和 RPC
   1. Netty 原理
   2. Netty 高性能
      1. 多路复用通讯方式
      2. 异步通讯 NIO
      3. 零拷贝（Direct Buffers 使用堆外直接内存）
      4. 内存池（基于内存池的缓冲区重用机制）
      5. 高校的Reactor线程模型
         1. Reactor 单线程模型
         2. Reactor 多线程模型
         3. 主从 Reactor 多线程模型
      6. 无锁设计、线程绑定
      7. 高性能的序列化框架
         1. 小包封大包，防止网络阻塞
         2. 软中断 hash 值和 cpu 绑定
   3. Netty RPC 实现
      1. 概念
      2. 关键技术
      3. 核心流程
      4. 消息编解码
         1. 总数据结构（接口名称+方法名+参数类型和参数值+超时时间+requestID）
         2. 序列化
      5. 通讯过程
         1. 核心问题（线程暂停、消息乱序）
         2. 通讯流程
         3. requestID 生成 AtomicLong
         4. 存放回调对象 callback 到全局 ConcurrentHashMap
         5. synchronized 获取回调对象 callback 的锁并自旋wait
         6. 监听消息的线程收到消息，找到calllback上的锁并唤醒
   4. RMI 实现方式
      1. 实现步骤
   5. Protoclol Buffer
      1. 特点
   6. Thrift
8. 网络
9. 日志
10. Zookeeper
11. Kafka
12. RabbitMQ
13. Hbase
14. MongoDB
15. Cassandra
16. 设计模式
    1. 设计原则
    2. 工厂方法模式
    3. 抽象工厂模式
    4. 单例模式
    5. 建造者模式
    6. 原型模式
    7. 适配器模式
    8. 装饰器模式
    9. 代理模式
    10. 外观模式
    11. 桥接模式
    12. 组合模式
    13. 享元模式
    14. 策略模式
    15. 模板方法模式
    16. 观察者模式
    17. 迭代子模式
    18. 责任链模式
    19. 命令模式
    20. 备忘录模式
    21. 状态模式
    22. 访问者模式
    23. 中介者模式
    24. 解释器模式
17. 负载均衡
18. 数据库
19. 一致性算法
20. JAVA 算法
    1. 二分查找
    2. 冒泡排序算法
    3. 插入排序算法
    4. 快速排序算法
    5. 希尔排序算法
    6. 归并排序算法
    7. 桶排序算法
    8. 基数排序算法
    9. 剪枝算法
    10. 回溯算法
    11. 最短路径算法
    12. 最大子数组算法
    13. 最长公共子序算法
    14. 最小生成树算法
21. 数据结构
    1. 栈（stack）
    2. 队列（queue）
    3. 链表（link）
    4. 散列表（hash table）
    5. 排序二叉树
    6. 红黑树
    7. B-Tree
    8. 位图
22. 加密算法
    1. AES
    2. RSA
    3. CRC
    4. MD5
23. 分布式缓存
    1. 缓存雪崩
    2. 缓存穿透
    3. 缓存预热
    4. 缓存更新
    5. 缓存降级
24. Hadoop
25. Spark
26. Storm
27. Yarn
28. 机器学习
29. 云计算