---
title: 《Java并发编程的艺术》第二章 Java 并发机制的底层实现原理
date: 2019-06-13 00:00:01
tags: 
  - Java并发编程的艺术
categories:
  - 读书笔记
  - Java并发编程的艺术
visible: hide
---
![UTOOLS1563155664180.png](https://i.loli.net/2019/07/15/5d2bdcd10382530479.png)

<!-- More -->


# 第二章 Java 并发机制的底层实现原理

Java 代码在编译之后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终转化为汇编指令在 CPU 上执行。

Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。

## 2.1 volatile 的应用

volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。即当一个线程修改了一个共享变量时，另一个线程能够读到这个修改的值。

volatile 的官方定义：Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

volatile 实现相关的 CPU 术语：

| 术语     | 英文                   | 术语描述                                                     |
| -------- | ---------------------- | :----------------------------------------------------------- |
| 内存屏障 | memory barriers        | 是一组处理器指令，用于实现对内存操作的顺序限制               |
| 缓冲行   | cache line             | CPU 高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令 |
| 原子操作 | atomic operations      | 不可中断的一个或一系列操作                                   |
| 缓存命中 | cache hit              | 如果进行高速缓存行中操作的内存位置仍然是下次处理器访问的地址时，处理器将从缓存中读取操作数，而不是从内存中读取 |
| 写命中   | write hit              | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存 |
| 写缺失   | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |

volatile 修改的变量，在进行修改时，会引发两件事：

1. 通过 Lock 前缀指令，将当前处理缓存行的数据写回到系统内存
2. 写回内存的操作会使其他 CPU 里缓存了该内存地址的数据无效，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存中。

## 2.2 synchronized 的实现原理与应用

synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的 Class 对象
- 对于同步方法块，锁是 Synchronized 括号里配置的对象

Synchronized 在 JVM 里的实现原理：JVM基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但是两者的实现细节不一样。代码块同步是使用 monitorenter 和 monitorexit 指令实现的。

monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处，JVM保证每个 monitorenter 必须对应 monitorexit。线程执行到 monitorenter 指令时，会尝试获取monitor的所有权，即尝试获得对象的锁。

### 2.2.1 锁的升级与对比

Java1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。

在1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

锁可以升级但是不能降级，这种策略的目的是为了提高获得锁和释放锁的效率。

#### 1. 偏向锁

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让获得锁的代价更低而引入了偏向锁。

当一个线程访问同步块并获得锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要检查MarkWord 里是否存储着指向当前线程的偏向锁。

即线程获取资源之后，会在资源上记录当前线程地址，并不会释放，当出现竞争时才会释放锁。

> -XX:-UseBiasedLocking=false 关闭偏向锁    
>
> > -XX:BiasedLockingStartupDelay=0 关闭延迟(默认情况下，偏向锁在程序启动几秒后才会激活)

#### 2.轻量级锁

加锁：线程在执行同步块之前，JVM会将对象头中的MarkWord 复制到当前线程的锁记录中。然后线程尝试使用 CAS 将对象头中的 MarkWord 替换为指向锁记录的指针。如果成功，线程获得锁；失败，表示其他线程竞争锁，当前线程尝试使用 自旋(即当前线程不停地尝试请求资源，直到成功) 来获取锁。

解锁：解锁时，使用 CAS 操作将 MarkWord 替换回对象头。成功，则表示没有竞争发生；失败，则表示锁存在竞争，此时锁会膨胀成重量级锁。

![争夺锁导致的锁膨胀](https://gitee.com/chenssy/blog-home/raw/master/image/sijava/201812081005.png)

图中可以看出，自旋会消耗CPU，为了避免无用的自旋，一旦锁升级为重量级锁，就不会再降级为轻量级锁。重量级锁的所有线程在请求锁资源时，都会进入阻塞状态，只有当锁释放时，才会进行新一轮的夺锁之争。

锁的优缺点对比：

| 锁       | 优点                                                       | 缺点                                     | 适用场景                           |
| -------- | ---------------------------------------------------------- | ---------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁解锁不需要额外消耗，和执行非同步方法相比，仅纳秒级差距 | 如果线程间存在锁竞争，会带来锁撤销的消耗 | 只有一个线程访问同步块的场景       |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                   | 如果始终得不到锁竞争，会使用自旋消耗CPU  | 追求响应时间  同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                            | 线程阻塞，响应时间缓慢                   | 追求吞吐量   同步块执行速度较长    |

## 2.3 原子操作的实现原理

原子（atomic）：“不能被进一步分隔的最小粒子”。

原子操作（atomic operation）：“不可被中断的一个或一系列操作”。

### 原子操作的相关术语：

| 术语         | 英文                   | 解释                                                         |
| ------------ | ---------------------- | ------------------------------------------------------------ |
| 缓存行       | cache line             | 缓存的最小操作单位                                           |
| 比较并交换   | Compare and Swap       | CAS，比较旧值与新值。当旧值发生改变之后才进行替换            |
| CPU流水线    | CPU pipeline           | 在CPU内由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令分为5~6步后再由这些电路单元分别执行，这样就能在一个CPU时钟周期完成一条指令，从而提高CPU的运算速度 |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般由假共享引起，即多个CPU同时修改一个缓存行的不同部分，引起其中一个CPU操作无效，当出现该冲突时，CPU必须清空流水线 |

### 处理器如何实现原子操作：

1. 通过总线锁保证原子性：
   1. 即使用处理器提供 LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，该处理器则独占内存。
   2. 缺点：总线锁是把CPU和内存之间的通信锁住了，这使得锁定期内，其他处理器不能操作其他内存地址的数据，因此开销很大。
2. 通过缓存锁定来保证原子性：
   1. 指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器直接修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。
   2. 缓存一致性：该机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。
   3. 不能使用缓存锁定的场景：a. 操作的数据跨缓存行时，b. 处理器不支持缓存锁定。这两种情况都被调用总线锁定。

### Java 如何实现原子操作：

在 Java 中可以通过 `锁` 和 `循环CAS` 的方式来实现原子操作。

从 Java 1.5 开始，JDK提供了一些原子包装类来支持原子操作。

### CAS 实现原子操作的三大问题

1. `ABA 问题`。
   1. 原因：因为CAS 在操作值时，先比较旧值是否发生了变化，如果发生变化，再去修改该值。问题则出现在，如果A = 1；A=2；A=1；此时CAS检查时，并未发现A的变化，但是实际上却变化了。
   2. 解决思路：加上版本号即A1=1,A2=2,A3=1
   3. JDK 中提供了一个类 AtomicStampedReference，通过检查值和预期标记的方法来判断是否需要更新
2. `循环时间长开销大` 。
   1. 原因：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
   2. 解决方法：如果JVM能支持处理器提供的pause指令，则效率会有一定提升。pause指令能延迟流水线执行指令，避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，从而提升CPU执行效率。
3. 只能保证一个共享变量的原子操作。
   1. 原因：当对一个共享变量执行操作时，可以使用循环 CAS，但是对多个共享变量时，就无法保证操作的原子性，此时可以用锁。
   2. 解决方法：将多个共享变量合为一个共享变量来操作，如 i=2,j=a => ij=2a
   3. JDK解决方法，提供了AtomicReference类来保证引用对象之间的原子性，即可以把多个变量放在一个对象中进行CAS操作。

