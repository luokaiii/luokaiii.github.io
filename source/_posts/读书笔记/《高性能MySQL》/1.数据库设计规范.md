---
title: 《高性能MySQL》第一章 数据库设计规范
date: 2019-06-20 10:03:23
categories:
  - 读书笔记
  - 高性能MySQL
visible: hide
---

# 第一章 数据库设计规范

## 1. 数据库 - 命名规范

1. 所有数据库对象名称必须使用小写字母并用下划线分割
   1. eg：DbName != dbname
   2. eg: Table != table != tabLe
2. 所有数据库对象名称禁止使用 MySQL 保留关键字
   1. 保留关键字：<https://dev.mysql.com/doc/refman/8.0/en/keywords.html>
3. 数据库对象的命名要做到见名识义，并且最好不要超过 32 字符
   1. 数据库名过长，会增加网络开销
4. 临时库必须以 tmp 为前缀，并以日期为后缀
5. 备份库、备份表必须以 bak 为前缀，并以日期为后缀
6. 所有存储相同数据的列名和列类型必须一致
   1. 即表A与表B的某个属性相同，则列名与类型必须一致
   2. 如 A.cid与 B.cid，都必须是 `cid int unsigned not null`
   3. 这种属性一般用于关联列上，当保持一致时，对数据库查询效率有一定帮助

## 2. 数据库 - 基本设计规范

1. 所有表必须使用 Innodb 存储引擎
   1. 在 MySQL 5.5 之前，MylSAM 是默认的存储引擎，MylSAM 是表级锁，在高并发场景下，锁表会有很严重的性能问题
   2. InnoDB 是 5.6 以后的默认存储引擎
   3. InnoDB 支持事务，行级锁，拥有更好的恢复性，高并发场景下性能更好
2. 数据库和表的字符集统一使用 UTF8
   1. 统一字符集可以避免由于字符集转换产生的乱码
   2. MySQL 中 UTF8 字符集汉字占 3 个字节，ASCII 码占一个字符
3. 所有表和字段都需要添加注释
   1. 使用 comment 从句添加表和列的备注
   2. 从一开始就进行数据字典的维护
4. 尽量控制单表数据量的大小，建议控制在 500W 以内
   1. 500 W 并不是 MySQL 数据库的限制
   2. 可以使用历史数据归档，分库分表等手段限制单表的数据量大小
5. 谨慎使用 MySQL 分区表
   1. 分区表在物理上表现为多个文件，在逻辑上表现为一个表
   2. 谨慎选择分区键，跨分区查询效率可能更低
   3. 建议采用物理分表的方式管理大数据
6. 尽量做到冷热数据分离，减小表的宽度
   1. 减少磁盘IO，保证热数据的内存缓存命中率
   2. 更有效的利用缓存，避免读入无用的冷数据
   3. 经常一起使用的列放在一个表中
7. 禁止在表中建立预留字段
   1. 预留字段的命名很难做到见名识义
   2. 预留字段无法确认存储的数据类型，所以无法选择合适的类型
   3. 对预留字段类型的修改，会对表进行锁定
      1. 在 MySQL 中，对表类型修改的成本远远大于增加一个数据类型的成本
8. 禁止在数据库中存储图片，文件等二进制数据
   1. blob、text 等类型
9. 禁止在线上做数据库压力测试
10. 禁止从开发环境、测试环境直连生产环境数据库

## 3. 数据库 - 索引设计规范

1. 限制每张表的索引数量，建议单张表索引不超过 5 个
   1. 索引并不是越多越好，过多的索引可能会降低效率
   2. 禁止给表中的每一列都建立单独的索引
2. 每个 InnoDB 表必须有一个主键
   1. Innodb 是按照主键索引的顺序来组织表的，因此每个表必须有一个主键
   2. 如果表中未设置主键，MySQL 会自动选择第一个非空唯一性的属性作为主键；如果没有非空唯一约束的属性，MySQL 会自动生成一个 6 字节的主键，但是效率不高
   3. 不使用更新频繁的列作为主键，不使用多列主键
   4. 不使用 UUID、MD5、HASH、字符串列作为主键
   5. 主键建议选择使用主键自增ID
3. 常见索引建议
   1. SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
   2. 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
   3. 多表 JOIN 的字段
4. 如何选择索引列的顺序
   1. 区分度最高的列放在联合索引的最左侧
   2. 尽量把字段长度小的列放在联合索引的最左侧
   3. 使用最频繁的列放在联合索引的最左侧
5. 避免建议冗余索引和重复索引
   1. eg: primary key(id) 、index(id)、unique index(id)
   2. eg: index(a,b,c)，index(a,b)，index(a)
      1. 对于冗余索引，MySQL 执行优化器会对查询到的索引进行选择，降低了索引使用的效率
6. 对于频繁的查询优先考虑使用覆盖索引
   1. 避免 Innodb 表进行索引的二次查找
   2. 可以把随机 IO 变为顺序 IO，提高查询效率
7. 尽量避免使用外键
   1. 不建议使用外键约束，但一定在表与表之间的关联键上建立索引
   2. 外键可用于保证数据的参照完整性，但建议在业务端实现
   3. 外键会影响父表和子表的写操作从而降低性能
      1. 存在外键约束的表在进行写操作时，会检查外键约束的完整性，降低写操作的性能

