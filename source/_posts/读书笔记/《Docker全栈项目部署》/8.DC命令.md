---
title: Docker部署全栈：七、DockerCompose命令
date: 2019-09-17 17:11:00
tags: 
  - Docker全栈部署
  - hide
categories:
  - 运维
  - Docker全栈部署
---
# Docker-Compose

## 一、Compose 简介

通过创建 `Dockerfile` 模板文件，可以使用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成任务的情况。

例如，一个常见的 Web 项目，除了 Web 服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。

`Compose` 中有两个重要的概念：

- 服务 `service` ：一个应用的容器，实际上包含若干运行相关镜像的容器
- 项目 `project` ：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose` 中定义。

## 二、安装与卸载

### 使用二进制包安装

1. 从 [官方 GitHub Release](https://github.com/docker/compose/releases) 处下载编译好的二进制文件
       1. 

      ```
      curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
      
      chmod +x /usr/local/bin/docker-compose
      ```

2. 查看 Compose 是否安装成功

   1. `docker-compose --version`

## 三、使用

### 1. Web应用

SpringBoot  应用如下：

```java
@SpringBootApplication
@RestController
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
    
    @GetMapping("/")
    public String hello() {
        return "Hello World!";
    }
}
```

### 2. Dockerfile

在项目根目录下，创建 `Dockerfile` 文件：

```dockerfile
FROM openjdk:8-slim
EXPOSE 8080
ENV TZ Asia/Shanghai
COPY build/libs/app-1.0.0.jar /opt/app.jar
ENTRYPOINT ["/opt/app.jar"]
```

### 3. docker-compose.yml

编写 `docker-compose.yml` ，这是 Compose 使用的主模板文件：

```yml
version: '3'
services:
	web:
		build: .
		ports:
		 - "8080:8080"
    redis:
    	image: "redis:alpine"
```

### 4. 运行 Compose 项目

`docker-compose up`

## 四、Compose 命令

### 1. 命令对象与格式

`docker-compose` 命令的基本使用格式是：

```sh
docker-compose [-f=<arg>...] [options] [COMMAND] [ARGS...]
```

- `-f, --file FILE` 指定使用的 Compose 模板文件，默认为 docker-compose.yml
- `-p, --project-name` NAME 指定项目名称，默认为所在目录
- `--x-networking` 使用 Docker 的可拔插网络后端特性
- `--x-network-driver DRIVER` 指定网络后端的驱动，默认为bridge
- `--verbose` 输出更多调试信息
- `-v, --version` 打印版本并退出

### 2. 命令说明

#### 1. build

> 构建（重新构建）项目中的服务容器

#### 2. config

> 验证 Compose 文件格式是否正确

#### 3. down

> 停止 up 命令所启动的容器，并移除网络

#### 4. exec

> 进入指定的容器

#### 5. help

> 获得一个命令的帮助

#### 6. images

> 列出 Compose 文件中包含的镜像

#### 7. kill

> 通过发送 SIGKILL[(Linux 信号列表)](https://blog.csdn.net/DLUTBruceZhang/article/details/8821690) 信号来强制停止服务容器。

#### 8. logs

> 查看服务容器的输出

#### 9. pause

> 暂停一个服务容器

#### 10. port

> 打印某个容器端口所映射的公共端口

#### 11. ps

> 列出项目中目前的所有容器

#### 12. pull

> 拉取服务依赖的镜像

#### 13. push

> 推送服务依赖的镜像到 Docker 镜像仓库

#### 14. restart

> 重启项目中的服务

#### 15. rm

> 删除所有(停止状态的)服务容器

#### 16. run

> 在指定服务上执行一个命令

#### 17. scale

> 设置指定服务运行的容器个数

#### 18. start

> 启动已经存在的服务容器

#### 19. stop

> 停止运行中的容器，但不删除它

#### 20. top

> 查看各个服务容器内运行的进程

#### 21. unpause

> 恢复暂停状态的服务

#### 22. up

> 自动完成：构建镜像 > (重新)创建服务 > 启动服务 > 关联服务容器

#### 23. version

> 打印版本信息

## 五、Compose 模板文件



## 六、实战 Java Web

```yml
version: '3'

services:
  jenkins:
    container_name: 'jenkins.ci'
    image: 'jenkins/jenkins:lts'
    #ports:  不对外暴露端口，直接使用nginx容器转到8080
      #- '8080:8080'
      #- '50000:50000'
    volumes:
      - '/home/docker-images/jenkins/var/jenkins_home:/var/jenkins_home'
      - '/home/docker-images/jenkins/html:/usr/share/jenkins/html' #挂载编译打包后的存放路径
  nginx:
    container_name: 'nginx'
    depends_on:
      - jenkins
    image: nginx:alpine
    volumes:
      - '/home/luokaiii/backstage_page/html:/usr/www/luokaiii/cn/html'
      - '/home/docker-images/nginx/conf:/etc/nginx/conf.d'
      - '/home/docker-images/nginx/cert:/etc/nginx/cert'
    ports:
      - 80:80 # 对外统一使用80端口
      - 443:443
    restart: always

```

