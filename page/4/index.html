<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives/index.html"><span class="pull-left">文章</span><span class="pull-right">207</span></a><a class="author-info-articles__tags article-meta" href="/tags/index.html"><span class="pull-left">标签</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories/index.html"><span class="pull-left">分类</span><span class="pull-right">28</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives/index.html">归档</a><a class="site-page" href="/tags/index.html">标签</a><a class="site-page" href="/categories/index.html">分类</a><a class="site-page" href="/about/index.html">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/22/分布式/SpringBoot/SpringBoot参考指南/index.html">SpringBoot 参考指南</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SpringBoot-参考指南/index.html">SpringBoot 参考指南</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a></span><div class="content"><h1 id="SpringBoot-参考指南"><a href="#SpringBoot-参考指南" class="headerlink" title="SpringBoot 参考指南"></a>SpringBoot 参考指南</h1><p>我会从 SpringBoot 的安装、构建、配置、启动运行等方面简单的介绍 SpringBoot 的技术点。</p>
<p>构建系统：Maven｜Gradle｜Ant｜Starters<br>最佳实践：代码结构｜@Configuration｜@EnableAutoConfiguration｜Beans和依赖注入<br>运行代码：IDE｜Packaged｜Maven｜Gradle<br>应用打包：产品级jars<br>Spring Boot命令行：使用CLI</p>
<p>核心特性：SpringApplication｜外部化配置｜Profiles｜日志<br>Web应用：MVC｜内嵌容器<br>使用数据：SQL｜NO-SQL<br>消息：概述｜JMS<br>测试：概述｜Boot应用｜工具<br>扩展：Auto-configuration｜@Conditions</p>
<p>管理端点：概述｜自定义<br>连接选项：HTTP｜JMX｜SSH<br>监控：指标｜审计｜追踪｜进程</p>
<p>部署Spring Boot应用：云部署 | 操作系统服务<br>构建工具插件：Maven｜Gradle<br>附录：应用属性｜Auto-configuration类｜可执行Jars</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/11/分布式/SpringBoot/2.SpringBoot的三种启动方式/index.html">使用Gradle构建SpringBoot项目</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/index.html">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/gradle/index.html">gradle</a></span><div class="content"><h1 id="SpringBoot的三种启动方式"><a href="#SpringBoot的三种启动方式" class="headerlink" title="SpringBoot的三种启动方式"></a>SpringBoot的三种启动方式</h1><h2 id="一、Main方法"><a href="#一、Main方法" class="headerlink" title="一、Main方法"></a>一、Main方法</h2><pre><code class="java">/**
 * @SpringBootApplication SpringBoot的组合注解，标注为SpringBoot的应用
 *  scanBasePackages  扫描的包
 * @EnableAsync 开启异步方法
 */
@SpringBootApplication(scanBasePackages = &quot;com.pgc&quot;)
@Import(CommonApplication.class)
@EnableAsync
public class Application {
    /**
     * 项目的入口
     */
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</code></pre>
<h2 id="二、Maven方式"><a href="#二、Maven方式" class="headerlink" title="二、Maven方式"></a>二、Maven方式</h2><h2 id="三、Gradle方式"><a href="#三、Gradle方式" class="headerlink" title="三、Gradle方式"></a>三、Gradle方式</h2><h2 id="四、运行jar文件"><a href="#四、运行jar文件" class="headerlink" title="四、运行jar文件"></a>四、运行jar文件</h2><p>通过 jar 文件启动的方式，需要先将项目编译为jar文件。</p>
<pre><code class="java">mvn install</code></pre>
<h2 id="五、war文件方式"><a href="#五、war文件方式" class="headerlink" title="五、war文件方式"></a>五、war文件方式</h2><p>如果项目的打包方式为“war”，则将打包之后的 war 文件，直接复制到对应的服务器下即可。由应用服务器来启动。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/11/分布式/SpringBoot/1.用Gradle构建SpringBoot项目/index.html">使用Gradle构建SpringBoot项目</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/index.html">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/gradle/index.html">gradle</a></span><div class="content"><h1 id="使用Gradle构建SpringBoot项目"><a href="#使用Gradle构建SpringBoot项目" class="headerlink" title="使用Gradle构建SpringBoot项目"></a>使用Gradle构建SpringBoot项目</h1><p><img src="https://upload-images.jianshu.io/upload_images/13603359-a178a9b22adf602a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>本章中包含了 <code>Gradle工程的创建</code>、<code>依赖SpringBoot</code>、<code>生成IDE工程文件</code>、<code>调试模式</code>、<code>自动化测试</code> 五个部分。<a href="https://github.com/davenkin/gradle-spring-boot.git" target="_blank" rel="noopener">本文 Github 代码</a></p></div><a class="more" href="/2018/10/11/分布式/SpringBoot/1.用Gradle构建SpringBoot项目/index.html#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/11/后端/java/MockMvc测试/index.html">SpringMVC测试框架</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><div class="content"><h1 id="SpringMVC测试框架"><a href="#SpringMVC测试框架" class="headerlink" title="SpringMVC测试框架"></a>SpringMVC测试框架</h1><h3 id="基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring-MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。"><a href="#基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring-MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。" class="headerlink" title="基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。"></a>基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。</h3><h2 id="快速入门-这个方法中包含了大多数的常见情况："><a href="#快速入门-这个方法中包含了大多数的常见情况：" class="headerlink" title="快速入门-这个方法中包含了大多数的常见情况："></a>快速入门-这个方法中包含了大多数的常见情况：</h2><pre><code class="java">    @RunWith(SpringRunner.class)
    @SpringBootTest
    @AutoConfigureMockMvc
    public class CourseControllerTest {

        @Autowired
        private MockMvc mockMvc;

        //ObjectMapper是一个可以重复使用的对象
        @Autowired
        private ObjectMapper mapper;

        @Test
        public void courseListTest() throws Exception{
            mockMvc.perform(MockMvcRequestBuilders.get(&quot;/course&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk());
        }

        @Test
        public void createTest() throws Exception{
            String json = &quot;{\&quot;name\&quot;:\&quot;Mock测试\&quot;,\&quot;classHour\&quot;:\&quot;4课时\&quot;,\&quot;id\&quot;:\&quot;rn:practice:Course:5af27fa5d34f435e581e5bbf\&quot;}&quot;;
            //将json格式字符串转换成Course对象里的属性值
            Course course = mapper.readValue(json,Course.class);
            //perform,执行一个RequestBuilders请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理
            mockMvc.perform(
                    //构造一个post请求
                    MockMvcRequestBuilders.post(&quot;/course&quot;)
                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    //使用writeValueAsString()方法来获取对象的JSON字符串表示
                    .content(mapper.writeValueAsString(course)))
            //andExpect，添加ResultMathcers验证规则，验证控制器执行完成后结果是否正确，【这是一个断言】
            .andExpect(MockMvcResultMatchers.status().is(200))

            .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8))

            //假定返回的结果中，&quot;name&quot; 值为 &quot;Mock测试2&quot;,如果不是的话，会抛出异常java.lang.AssertionError，并给出期望值和实际值
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;Mock测试2&quot;))

            //添加ResultHandler结果处理器，比如调试时 打印结果(print方法)到控制台
            .andDo(print())

            //返回相应的MvcResult
            .andReturn();
    }</code></pre>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><h2 id="一-MockMvcBuilder"><a href="#一-MockMvcBuilder" class="headerlink" title="一 MockMvcBuilder"></a>一 MockMvcBuilder</h2><p>MockMvcBuilder是用来构造MockMvc的构造器，其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应两种测试方式，即独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。对于我们来说直接使用静态工厂MockMvcBuilders创建即可。</p>
<h3 id="1-集成Web环境方式"><a href="#1-集成Web环境方式" class="headerlink" title="1.集成Web环境方式"></a>1.集成Web环境方式</h3><pre><code>MockMvcBuilders.webAppContextSetup(WebApplicationContext context)：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc；

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:config/IncotermsRestServiceTest-context.xml&quot;)
@WebAppConfiguration
public class IncotermsRestServiceTest {
    @Autowired
    private WebApplicationContext wac;
    private MockMvc mockMvc;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();   //构造MockMvc
    }
    ...
}

注意：
    (1)@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；
    (2)通过@Autowired WebApplicationContext wac：注入web环境的ApplicationContext容器；
    (3)然后通过MockMvcBuilders.webAppContextSetup(wac).build()创建一个MockMvc进行测试；</code></pre><h3 id="2-独立测试方式"><a href="#2-独立测试方式" class="headerlink" title="2.独立测试方式"></a>2.独立测试方式</h3><pre><code>MockMvcBuilders.standaloneSetup(Object... controllers)：通过参数指定一组控制器，这样就不需要从上下文获取了；
public class PricingExportResultsRestServiceTest {
    @InjectMocks
    private PricingExportResultsRestService pricingExportResultsRestService;
    @Mock
    private ExportRateScheduleService exportRateScheduleService;
    @Mock
    private PricingUrlProvider pricingUrlProvider;
    private MockMvc mockMvc;
    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        mockMvc = MockMvcBuilders.standaloneSetup(pricingExportResultsRestService).build();  //构造MockMvc
    }
    ...
}

主要是两个步骤：
(1)首先自己创建相应的控制器，注入相应的依赖
(2)通过MockMvcBuilders.standaloneSetup模拟一个Mvc测试环境，通过build得到一个MockMvc</code></pre><h2 id="二-MockMvc"><a href="#二-MockMvc" class="headerlink" title="二 MockMvc"></a>二 MockMvc</h2><h4 id="先看一个测试例子1："><a href="#先看一个测试例子1：" class="headerlink" title="先看一个测试例子1："></a>先看一个测试例子1：</h4><pre><code>　　@Test
    public void createIncotermSuccess() throws Exception {
        IncotermTo createdIncoterm = new IncotermTo();
        createdIncoterm.setId(new IncotermId(UUID.fromString(&quot;6305ff33-295e-11e5-ae37-54ee7534021a&quot;)));
        createdIncoterm.setCode(&quot;EXW&quot;);
        createdIncoterm.setDescription(&quot;code exw&quot;);
        createdIncoterm.setLocationQualifier(LocationQualifier.DEPARTURE);
when(inventoryService.create(any(IncotermTo.class))).thenReturn(createdIncoterm);   mockMvc.perform(post(&quot;/secured/resources/incoterms/create&quot;).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
                .content(&quot;{\&quot;code\&quot; : \&quot;EXW\&quot;, \&quot;description\&quot; : \&quot;code exw\&quot;, \&quot;locationQualifier\&quot; : \&quot;DEPARTURE\&quot;}&quot;.getBytes()))
                //.andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;id.value&quot;).exists())
                .andExpect(jsonPath(&quot;id.value&quot;).value(&quot;6305ff33-295e-11e5-ae37-54ee7534021a&quot;))
                .andExpect(jsonPath(&quot;code&quot;).value(&quot;EXW&quot;));
    }

perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；
andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；
andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；
andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</code></pre><h4 id="看一个具体的例子2："><a href="#看一个具体的例子2：" class="headerlink" title="看一个具体的例子2："></a>看一个具体的例子2：</h4><pre><code>@Test  
public void testView() throws Exception {  
    MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/1&quot;))  
            .andExpect(MockMvcResultMatchers.view().name(&quot;user/view&quot;))  
            .andExpect(MockMvcResultMatchers.model().attributeExists(&quot;user&quot;))  
            .andDo(MockMvcResultHandlers.print())  
            .andReturn();  
    Assert.assertNotNull(result.getModelAndView().getModel().get(&quot;user&quot;));  
}  </code></pre><blockquote>
<p>   整个过程：<br>   1、mockMvc.perform执行一个请求；<br>   2、MockMvcRequestBuilders.get(“/user/1”)构造一个请求<br>   3、ResultActions.andExpect添加执行完成后的断言<br>   4、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。<br>   5、ResultActions.andReturn表示执行完成后返回相应的结果。   </p>
</blockquote>
<pre><code>整个测试过程非常有规律：
1、准备测试环境
2、通过MockMvc执行请求
3.1、添加验证断言
3.2、添加结果处理器
3.3、得到MvcResult进行自定义断言/进行下一步的异步请求
4、卸载测试环境</code></pre><h2 id="三-RequestBuilder-MockMvcRequestBuilders"><a href="#三-RequestBuilder-MockMvcRequestBuilders" class="headerlink" title="三 RequestBuilder/MockMvcRequestBuilders"></a>三 RequestBuilder/MockMvcRequestBuilders</h2><p>从名字可以看出，RequestBuilder用来构建请求的，其提供了一个方法buildRequest(ServletContext servletContext)用于构建MockHttpServletRequest；其主要有两个子类MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder（如文件上传使用），即用来Mock客户端请求需要的所有数据。</p>
<h3 id="1-MockMvcRequestBuilders主要API"><a href="#1-MockMvcRequestBuilders主要API" class="headerlink" title="1.MockMvcRequestBuilders主要API"></a>1.MockMvcRequestBuilders主要API</h3><pre><code>MockHttpServletRequestBuilder get(String urlTemplate, Object... urlVariables)：根据uri模板和uri变量值得到一个GET请求方式的MockHttpServletRequestBuilder；如get(/user/{id}, 1L)；

MockHttpServletRequestBuilder post(String urlTemplate, Object... urlVariables)：同get类似，但是是POST方法；

MockHttpServletRequestBuilder put(String urlTemplate, Object... urlVariables)：同get类似，但是是PUT方法；

MockHttpServletRequestBuilder delete(String urlTemplate, Object... urlVariables) ：同get类似，但是是DELETE方法；

MockHttpServletRequestBuilder options(String urlTemplate, Object... urlVariables)：同get类似，但是是OPTIONS方法；

MockHttpServletRequestBuilder request(HttpMethod httpMethod, String urlTemplate, Object... urlVariables)： 提供自己的Http请求方法及uri模板和uri变量，如上API都是委托给这个API；

MockMultipartHttpServletRequestBuilder fileUpload(String urlTemplate, Object... urlVariables)：提供文件上传方式的请求，得到MockMultipartHttpServletRequestBuilder；

RequestBuilder asyncDispatch(final MvcResult mvcResult)：创建一个从启动异步处理的请求的MvcResult进行异步分派的RequestBuilder；</code></pre><h3 id="2-MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder-API"><a href="#2-MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder-API" class="headerlink" title="2.MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder API"></a>2.MockHttpServletRequestBuilder和MockMultipartHttpServletRequestBuilder API</h3><h2 id="1-MockHttpServletRequestBuilder-API"><a href="#1-MockHttpServletRequestBuilder-API" class="headerlink" title="(1)MockHttpServletRequestBuilder API"></a>(1)MockHttpServletRequestBuilder API</h2><pre><code>MockHttpServletRequestBuilder header(String name, Object... values)/MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders)：添加头信息；

MockHttpServletRequestBuilder contentType(MediaType mediaType)：指定请求的contentType头信息；

MockHttpServletRequestBuilder accept(MediaType... mediaTypes)/MockHttpServletRequestBuilder accept(String... mediaTypes)：指定请求的Accept头信息；

MockHttpServletRequestBuilder content(byte[] content)/MockHttpServletRequestBuilder content(String content)：指定请求Body体内容；

MockHttpServletRequestBuilder cookie(Cookie... cookies)：指定请求的Cookie；

MockHttpServletRequestBuilder locale(Locale locale)：指定请求的Locale；

MockHttpServletRequestBuilder characterEncoding(String encoding)：指定请求字符编码；

MockHttpServletRequestBuilder requestAttr(String name, Object value) ：设置请求属性数据；

MockHttpServletRequestBuilder sessionAttr(String name, Object value)/MockHttpServletRequestBuilder sessionAttrs(Map&lt;string, object=&quot;&quot;&gt; sessionAttributes)：设置请求session属性数据；

MockHttpServletRequestBuilder flashAttr(String name, Object value)/MockHttpServletRequestBuilder flashAttrs(Map&lt;string, object=&quot;&quot;&gt; flashAttributes)：指定请求的flash信息，比如重定向后的属性信息；

MockHttpServletRequestBuilder session(MockHttpSession session) ：指定请求的Session；

MockHttpServletRequestBuilder principal(Principal principal) ：指定请求的Principal；

MockHttpServletRequestBuilder contextPath(String contextPath) ：指定请求的上下文路径，必须以“/”开头，且不能以“/”结尾；

MockHttpServletRequestBuilder pathInfo(String pathInfo) ：请求的路径信息，必须以“/”开头；

MockHttpServletRequestBuilder secure(boolean secure)：请求是否使用安全通道；

MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor)：请求的后处理器，用于自定义一些请求处理的扩展点；</code></pre><h2 id="2-MockMultipartHttpServletRequestBuilder"><a href="#2-MockMultipartHttpServletRequestBuilder" class="headerlink" title="(2)MockMultipartHttpServletRequestBuilder"></a>(2)MockMultipartHttpServletRequestBuilder</h2><pre><code>继承自MockHttpServletRequestBuilder，又提供了如下API
MockMultipartHttpServletRequestBuilder file(String name, byte[] content)/MockMultipartHttpServletRequestBuilder file(MockMultipartFile file)：指定要上传的文件；</code></pre><h2 id="四-ResultActions"><a href="#四-ResultActions" class="headerlink" title="四 ResultActions"></a>四 ResultActions</h2><pre><code>调用MockMvc.perform(RequestBuilder requestBuilder)后将得到ResultActions，通过ResultActions完成如下三件事：
ResultActions andExpect(ResultMatcher matcher) ：添加验证断言来判断执行请求后的结果是否是预期的；
ResultActions andDo(ResultHandler handler) ：添加结果处理器，用于对验证成功后执行的动作，如输出下请求/结果信息用于调试；
MvcResult andReturn() ：返回验证成功后的MvcResult；用于自定义验证/下一步的异步处理；</code></pre><h2 id="五-ResultMatcher-MockMvcResultMatchers"><a href="#五-ResultMatcher-MockMvcResultMatchers" class="headerlink" title="五 ResultMatcher/MockMvcResultMatchers"></a>五 ResultMatcher/MockMvcResultMatchers</h2><pre><code>1.ResultMatcher用来匹配执行完请求后的结果验证，其就一个match(MvcResult result)断言方法，如果匹配失败将抛出相应的异常；spring mvc测试框架提供了很多***ResultMatchers来满足测试需求。注意这些***ResultMatchers并不是ResultMatcher的子类，而是返回ResultMatcher实例的。Spring mvc测试框架为了测试方便提供了MockMvcResultMatchers静态工厂方法方便操作；</code></pre><p>2.具体的API如下：</p>
<pre><code>HandlerResultMatchers handler()：请求的Handler验证器，比如验证处理器类型/方法名；此处的Handler其实就是处理请求的控制器；

RequestResultMatchers request()：得到RequestResultMatchers验证器；

ModelResultMatchers model()：得到模型验证器；

ViewResultMatchers view()：得到视图验证器；

FlashAttributeResultMatchers flash()：得到Flash属性验证；

StatusResultMatchers status()：得到响应状态验证器；

HeaderResultMatchers header()：得到响应Header验证器；

CookieResultMatchers cookie()：得到响应Cookie验证器；

ContentResultMatchers content()：得到响应内容验证器；

JsonPathResultMatchers jsonPath(String expression, Object ... args)/ResultMatcher jsonPath  (String expression, Matcher matcher)：得到Json表达式验证器；

XpathResultMatchers xpath(String expression, Object... args)/XpathResultMatchers xpath(String expression, Map&lt;string, string=&quot;&quot;&gt; namespaces, Object... args)：得到Xpath表达式验证器；

ResultMatcher forwardedUrl(final String expectedUrl)：验证处理完请求后转发的url（绝对匹配）；

ResultMatcher forwardedUrlPattern(final String urlPattern)：验证处理完请求后转发的url（Ant风格模式匹配，@since spring4）；

ResultMatcher redirectedUrl(final String expectedUrl)：验证处理完请求后重定向的url（绝对匹配）；

ResultMatcher redirectedUrlPattern(final String expectedUrl)：验证处理完请求后重定向的url（Ant风格模式匹配，@since spring4）</code></pre><h2 id="六-一些常用的测试"><a href="#六-一些常用的测试" class="headerlink" title="六 一些常用的测试"></a>六 一些常用的测试</h2><h3 id="1-测试普通控制器"><a href="#1-测试普通控制器" class="headerlink" title="1.测试普通控制器"></a>1.测试普通控制器</h3><pre><code>mockMvc.perform(get(&quot;/user/{id}&quot;, 1)) //执行请求  
        .andExpect(model().attributeExists(&quot;user&quot;)) //验证存储模型数据  
        .andExpect(view().name(&quot;user/view&quot;)) //验证viewName  
        .andExpect(forwardedUrl(&quot;/WEB-INF/jsp/user/view.jsp&quot;))//验证视图渲染时forward到的jsp  
        .andExpect(status().isOk())//验证状态码  
        .andDo(print()); //输出MvcResult到控制台</code></pre><h3 id="2-得到MvcResult自定义验证"><a href="#2-得到MvcResult自定义验证" class="headerlink" title="2.得到MvcResult自定义验证"></a>2.得到MvcResult自定义验证</h3><pre><code>MvcResult result = mockMvc.perform(get(&quot;/user/{id}&quot;, 1))//执行请求  
        .andReturn(); //返回MvcResult  
Assert.assertNotNull(result.getModelAndView().getModel().get(&quot;user&quot;)); //自定义断言   </code></pre><h3 id="3-验证请求参数绑定到模型数据及Flash属性"><a href="#3-验证请求参数绑定到模型数据及Flash属性" class="headerlink" title="3.验证请求参数绑定到模型数据及Flash属性"></a>3.验证请求参数绑定到模型数据及Flash属性</h3><pre><code>mockMvc.perform(post(&quot;/user&quot;).param(&quot;name&quot;, &quot;zhang&quot;)) //执行传递参数的POST请求(也可以post(&quot;/user?name=zhang&quot;))  
            .andExpect(handler().handlerType(UserController.class)) //验证执行的控制器类型  
            .andExpect(handler().methodName(&quot;create&quot;)) //验证执行的控制器方法名  
            .andExpect(model().hasNoErrors()) //验证页面没有错误  
            .andExpect(flash().attributeExists(&quot;success&quot;)) //验证存在flash属性  
            .andExpect(view().name(&quot;redirect:/user&quot;)); //验证视图  </code></pre><h3 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4.文件上传"></a>4.文件上传</h3><pre><code>byte[] bytes = new byte[] {1, 2};  
mockMvc.perform(fileUpload(&quot;/user/{id}/icon&quot;, 1L).file(&quot;icon&quot;, bytes)) //执行文件上传  
        .andExpect(model().attribute(&quot;icon&quot;, bytes)) //验证属性相等性  
        .andExpect(view().name(&quot;success&quot;)); //验证视图  </code></pre><h3 id="5-JSON请求-响应验证"><a href="#5-JSON请求-响应验证" class="headerlink" title="5.JSON请求/响应验证"></a>5.JSON请求/响应验证</h3><pre><code>String requestBody = &quot;{\&quot;id\&quot;:1, \&quot;name\&quot;:\&quot;zhang\&quot;}&quot;;  
    mockMvc.perform(post(&quot;/user&quot;)  
            .contentType(MediaType.APPLICATION_JSON).content(requestBody)  
            .accept(MediaType.APPLICATION_JSON)) //执行请求  
            .andExpect(content().contentType(MediaType.APPLICATION_JSON)) //验证响应contentType  
            .andExpect(jsonPath(&quot;$.id&quot;).value(1)); //使用Json path验证JSON 请参考http://goessner.net/articles/JsonPath/   
    String errorBody = &quot;{id:1, name:zhang}&quot;;  
    MvcResult result = mockMvc.perform(post(&quot;/user&quot;)  
            .contentType(MediaType.APPLICATION_JSON).content(errorBody)  
            .accept(MediaType.APPLICATION_JSON)) //执行请求  
            .andExpect(status().isBadRequest()) //400错误请求  
            .andReturn();   
    Assert.assertTrue(HttpMessageNotReadableException.class.isAssignableFrom(result.getResolvedException().getClass()));//错误的请求内容体</code></pre><h3 id="6-异步测试"><a href="#6-异步测试" class="headerlink" title="6.异步测试"></a>6.异步测试</h3><pre><code>//Callable  
MvcResult result = mockMvc.perform(get(&quot;/user/async1?id=1&amp;name=zhang&quot;)) //执行请求  
        .andExpect(request().asyncStarted())  
        .andExpect(request().asyncResult(CoreMatchers.instanceOf(User.class))) //默认会等10秒超时  
        .andReturn();  

mockMvc.perform(asyncDispatch(result))  
        .andExpect(status().isOk())  
        .andExpect(content().contentType(MediaType.APPLICATION_JSON))  
        .andExpect(jsonPath(&quot;$.id&quot;).value(1));  </code></pre><h3 id="7-全局配置"><a href="#7-全局配置" class="headerlink" title="7.全局配置"></a>7.全局配置</h3><pre><code>mockMvc = webAppContextSetup(wac)  
        .defaultRequest(get(&quot;/user/1&quot;).requestAttr(&quot;default&quot;, true)) //默认请求 如果其是Mergeable类型的，会自动合并的哦mockMvc.perform中的RequestBuilder  
        .alwaysDo(print())  //默认每次执行请求后都做的动作  
        .alwaysExpect(request().attribute(&quot;default&quot;, true)) //默认每次执行后进行验证的断言  
        .build();  

mockMvc.perform(get(&quot;/user/1&quot;))  
        .andExpect(model().attributeExists(&quot;user&quot;));  </code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/11/后端/java/GC算法/index.html">GC算法、垃圾收集器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><div class="content"><h1 id="GC算法、垃圾收集器"><a href="#GC算法、垃圾收集器" class="headerlink" title="GC算法、垃圾收集器"></a>GC算法、垃圾收集器</h1><p>在 Java 中有两个最基本的回收算法：复制算法和标记清理算法</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两个区域A和B，初始对象在A，继续存活的对象被转移到B。为新生代最常用的算法</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>一块区域，标记可达对象(可达性分析)，然后回收不可达对象。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>通过标记清理算法回收会，会出现碎片，通过碎片整理算法，整理出更大的内存存放更大的对象</p>
<h2 id="新生代和年老代"><a href="#新生代和年老代" class="headerlink" title="新生代和年老代"></a>新生代和年老代</h2><p>新生代：初始对象，生命周期短</p>
<p>永久代：长时间存在的对象</p>
<p>整个Java 的垃圾回收是 新生代和年老代的协作，被称为 分代回收。</p>
<hr>
<p>Serial New 收集器，是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New 并行收集器，新生代采用复制算法，年老代采用标记整理</p>
<p>Parallel Scavenge 并行收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old 串行收集器，新生代采用复制，年老代采用标记整理</p>
<p>CMS 收集器，基于标记清理</p>
<p>G1 收集器，整体上基于标记整理，局部采用复制</p>
<ul>
<li>新生代基本采用复制算法，年老代采用标记整理算法，CMS采用标记清理</li>
</ul>
<h2 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h2><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>通过一个计数器记录该对象被引用的次数，简单高效。</p>
<p>弊端：无法解决循环引用问题。例如A包含指向B的引用，B包含指向A的引用，但是没有引用指向A和B，此时AB的引用次数都为1，都不会被回收。</p>
<h3 id="2-根搜索"><a href="#2-根搜索" class="headerlink" title="2. 根搜索"></a>2. 根搜索</h3><p>通过选取一些 <code>根对象</code> 作为起始点，开始向下搜索，如果一个对象到跟对象不可达时，则说明此对象没有被引用，可以回收。</p>
<p>可作为 <code>根对象</code> 的有：栈中变量引用的对象，类静态属性引用对象，常量引用对象等。</p>
<h3 id="3-策略：垃圾回收算法"><a href="#3-策略：垃圾回收算法" class="headerlink" title="3. 策略：垃圾回收算法"></a>3. 策略：垃圾回收算法</h3><p>即上面说的几种算法</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/30/分布式/SpringBoot/OSS-阿里云文件上传/index.html">基于阿里云OSS的文件上传服务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/index.html">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a></span><div class="content"><h1 id="基于阿里云OSS的文件上传服务"><a href="#基于阿里云OSS的文件上传服务" class="headerlink" title="基于阿里云OSS的文件上传服务"></a>基于阿里云OSS的文件上传服务</h1><h2 id="1-阿里云-OSS-服务介绍"><a href="#1-阿里云-OSS-服务介绍" class="headerlink" title="1.阿里云 OSS 服务介绍"></a>1.阿里云 OSS 服务介绍</h2><pre><code>OSS(Object Storage Service) 即对象存储服务，在 OSS 中每个文件都有一个 Key，通过这个 Key 来指向不同的文件对象。      

如果你提交的key为&quot;/attachment/2016/123.txt&quot;，那么在web管理平台上你可以看到上述以&quot;/&quot;分开的文件夹形式，即 OSS 中的 Key 就是&quot;/attachement/2016/123.txt&quot;</code></pre><h2 id="2-Java-SDK"><a href="#2-Java-SDK" class="headerlink" title="2.Java SDK"></a>2.Java SDK</h2><blockquote>
<p>aliyun-sdk-oss</p>
</blockquote>
<h2 id="3-如何使用-OSS"><a href="#3-如何使用-OSS" class="headerlink" title="3.如何使用 OSS"></a>3.如何使用 OSS</h2><pre><code>阿里云OSS方服务，通过自身提供的Client来实现上传和下载。所以在使用OSS服务上传文件时，需要创建三个类： Client类 、 Config类 和 上传类。</code></pre><h2 id="4-构建-OSS-Client-类"><a href="#4-构建-OSS-Client-类" class="headerlink" title="4.构建 OSS Client 类"></a>4.构建 OSS Client 类</h2><blockquote>
<p>获得 OSS 连接的工具类</p>
</blockquote>
<pre><code>@Component
public class DefaultOssClient{

    @Value(&quot;${oss.endpoint})
    String ENDPOINT;

    @Value(&quot;${oss.access.key.id}&quot;)
    String ACCESS_KEY_ID;

    @Value(&quot;${oss.access.key.secret}&quot;)
    String ACCESS_KEY_SECRET;

    @Value(&quot;${oss.bucket.name}&quot;)
    String BUCKET_NAME;

    private static OSSClient client = new OSSClient(ENDPOINT,ACCESS_KEY_ID,ACCESS_KEY_SECRETT,DefaultConfig.getDefaultConfig());

    static OSSClient getConnection(){
        if(client == null){
            client = new OSSClient(ENDPOINT,ACCESS_KEY_ID,ACCESS_KEY_SECRET,DefaultConfig.getDefaultConfig());
        }
        return client;
    }

    static void shutdownOSSClient(){
        client.shutdown();
        client = null;
    }
}</code></pre><blockquote>
<p>创建一个保存 OSS 地址的文件类，这个文件用户返回给界面</p>
</blockquote>
<pre><code>public class OSSFile{
    String fileId;
    String ossUrl;
    String fielname;
    double sizeKb;

    /* getter and setter*/
}</code></pre><blockquote>
<p>构建 OSS Config 类，用于指定文件上传的配置</p>
</blockquote>
<pre><code>static final ClientConfiguration conf = new ClientCOnfiguration();

public class DefaultConfig{
    private DefaultConfig(){
        conf.setMaxConnections(100);
        conf.setConnectionTimeout(5000);
        conf.setMaxErrorRetry(3);
        conf.setSocketTimeout(2000);
    }

    static ClientConfiguration getDefaultConfig(){
        return conf;
    }
}</code></pre><blockquote>
<p>构建 OSS 文件上传类</p>
</blockquote>
<pre><code>public class OSSUpload{

    static String put1(File file){
        String return_key = null;
        try{
            OSSClient client = DefaultOssClient.getConnection();
            if(file !=null){
                String fileName = file.getName();
                String timeStamp = Date2Str.getCurrentTimeStamp();
                String timeDate = Date2Str.getCurrentDate5();
                String key = Constant.bashFilePath + timeDate + timeStamp +&quot;/&quot; +fileName;

                client.putObject(new PutObjectRequest(Constant.bucketName,key,file));

                return_key = key;
            }
            DefaultOssClient.shutdownOSSClient();
        }catch(ClientException e){
            return null;
        }
        return return_key;
    }

    static String put2(InputStream in,String filename){
        String return_key = null;
        try{
            OSSClient client = DefaultOssClient.getConnection();
            if(in != null){
                String fileName = filename;
                try{
                    fileName = new String(filename.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);
                }catch(UnsupportedEncodingException e){
                    e.printStackTrace();
                }
                String timeStamp = System.getCurrentTimeStamp();
                String timeDate = Date2Str.getCurrentDate5();
                String key = Constant.bashFilePath + timeDate + timeStamp + &quot;/&quot; + fileName;

                client.put(new PutObjectRequest(Constant.bucketName,key,in));

                return_key = key;
            }

            DefaultOssClient.shutdownOSSClient();
        }catch(ClientException e){
            return null;
        }

        return return_key;
    }
}</code></pre><blockquote>
<p>上传测试</p>
</blockquote>
<pre><code>public class FileUpload{
    public static void main(String[] args){
        try{
            uploadOSS();
        }catch(IOException e){
            e.printStackTrace();
        }
    }

    public static void uploadOSS() throws ClientProtocolExcetion{
        HttpPost httpPost = new HttpPost(&quot;http://127.0.0.1:7001/test/autonavi/shanghai/api/attachment/oss/index.html);
        httpPost.addHeader(&quot;key&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;user&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;method&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;filename&quot;,new String(&quot;黄山［哈哈］.jpg&quot;.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
        httpPost.addHeader(&quot;type&quot;,&quot;01&quot;);

        FileEntity reqEntity = new FileEntity(new File(&quot;/Users/123/Pictures/Huangshan.jpg&quot;));

        httpPost.setEntity(reqEntity);

        HttpClient client = new DefaultHttpClient();
        HttpResponse response = client.execute(httpPost);

        System.out.println(response);
    }
}</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/30/后端/java/Java中使用Properties/index.html">读取 Properties 文件的几种方式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a></span><div class="content"><h1 id="读取Properties文件的几种方式"><a href="#读取Properties文件的几种方式" class="headerlink" title="读取Properties文件的几种方式"></a>读取Properties文件的几种方式</h1><p><img src="https://upload-images.jianshu.io/upload_images/13603359-9bc057f7c3fab711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读取Properties文件的几种方式"></p></div><a class="more" href="/2018/09/30/后端/java/Java中使用Properties/index.html#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/30/分布式/SpringBoot/SpringBoot/index.html">SpringBoot QA</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/index.html">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a></span><div class="content"><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-RestController-和-Controller"><a href="#1-RestController-和-Controller" class="headerlink" title="1. @RestController 和 @Controller"></a>1. @RestController 和 @Controller</h2><pre><code class="java">@RestController : 将所有返回的结果以字符串形式返回
@Controller ：返回结果由视图解析器返回视图</code></pre>
<h2 id="2-SpringBootApplication"><a href="#2-SpringBootApplication" class="headerlink" title="2. @SpringBootApplication"></a>2. @SpringBootApplication</h2><blockquote>
<p>是SpringBoot的核心注解，目的是开启自动配置。</p>
</blockquote>
<p>关闭自动配置：@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p>
<p>运行原理：相当于是以下注解的集合：</p>
<pre><code class="java">@Target(Element.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documentd
@Inherited
@Import({EnableAutoConfigurationImportSelector.class,AutoConfigurationPackages.Register.class})</code></pre>
<h2 id="3-Thymeleaf模板引擎-同Freemarker"><a href="#3-Thymeleaf模板引擎-同Freemarker" class="headerlink" title="3. Thymeleaf模板引擎(同Freemarker)"></a>3. Thymeleaf模板引擎(同Freemarker)</h2><ol>
<li>通过 <code>xmlns:th=http://www.thymeleaf.org</code> 命名空间，转换位动态视图；</li>
<li>使用 <code>“@{}”</code> 方式引用web静态资源</li>
<li>通过“${}”访问model中的属性，如：<span th:text="${singlePerson.name}"></span><br>注：需要处理的动态内容需要加上“th：”前缀</li>
<li>迭代：使用“th：each”，如：th:each=”person:${person}”  其中person作为迭代元素使用</li>
<li>数据判断： <code>th:if=&quot;${not #lists.isEmpty(people)}&quot;</code></li>
<li>js中访问model  </li>
</ol>
<pre><code class="javascript">&lt;script th:inline=&quot;javascript&quot;&gt; 
    var singlePerson=[[${singlePerson}]]
&lt;script&gt;</code></pre>
<blockquote>
<p>使用 <code>th:inline=&quot;javascript&quot;</code> 使js能够访问model<br>通过[[${}]]获取实际的值</p>
</blockquote>
<h2 id="4-注册Servlet、Filter、Listener"><a href="#4-注册Servlet、Filter、Listener" class="headerlink" title="4. 注册Servlet、Filter、Listener"></a>4. 注册Servlet、Filter、Listener</h2><p>Servlet:ServletRegistrationBean</p>
<pre><code class="java">@Bean
public ServletRegistrationBean serbletRegistrationBean(){
    //直接注册servlet及其请求路径
    return new ServletRegistrationBean(new XXServlet(),&quot;/xx/*&quot;);
}</code></pre>
<p>Filter:FilterRegisterationBean</p>
<pre><code class="java">@Bean
public FilterRegisterationBean filterRegisterationBean(){
    //设置过滤器
    FilterRegisterationBean filterRegisterationBean = new filterRegisterationBean.setFilter(new YYFilter());
    //执行顺序  
    filterRegisterationBean.setOrder(2);
    filterRegisterationBean.setName(&quot;MyFilter&quot;);//设置名称
    filterRegisterationBean.setUrlPatterns(&quot;/*&quot;);//设置过滤路径
    return filterRegisterationBean;
}</code></pre>
<p>Listener:ServletListenerRegisterationBean</p>
<pre><code class="java">@Bean
public ServletListenerRegisterationBean&lt;ZZListener&gt; servletListenerRegisterationBean(){
    return new ServletListenerRegisterationBean&lt;ZZListener&gt;(new ZZListener);
}</code></pre>
<h2 id="5-修改tomcat、jetty、undertow"><a href="#5-修改tomcat、jetty、undertow" class="headerlink" title="5.修改tomcat、jetty、undertow"></a>5.修改tomcat、jetty、undertow</h2><p>直接在pom文件中，修改依赖</p>
<pre><code class="java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; //将web对应的服务器修改为其它
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
  &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
  &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="6-WebSocket"><a href="#6-WebSocket" class="headerlink" title="6. WebSocket"></a>6. WebSocket</h2><h3 id="1-websocket的配置"><a href="#1-websocket的配置" class="headerlink" title="1. websocket的配置"></a>1. websocket的配置</h3><ol>
<li>使用@Configuration及@EnableWebSocketMessageBroker  来开启WebSocket支持</li>
<li>继承AbstratWebSocketMessageBrokerConfigurer类<ol>
<li>重写 <code>registerStomEndpoint(StomEndpointRegister)</code> 与 <code>configureMessageBroker(essageBrokerRegistry)</code> 方法</li>
<li><code>Sregistry.addEndpoint(&quot;/endpointWisely&quot;).withSockJS()</code>;  即通过endpointWisely连接SockJs</li>
<li>Mregistry.enableSimpleBroker(“/topic”);  配置一个topic消息代理</li>
</ol>
</li>
</ol>
<h3 id="2-wscontroller"><a href="#2-wscontroller" class="headerlink" title="2. wscontroller"></a>2. wscontroller</h3><p>@MessageMapping(“/welcome”) 同RequestMapping,映射地址</p>
<p>@SendTo(“/topic/getResponse”) 当服务端有消息时，会对订阅了”/topic/getResponse”的客户端发送消息</p>
<pre><code class="java">public WiselyResponse say(WiselyMessage message) throws Exception{
    return new WiselyResponse(&quot;Welcome &quot; +message.getName()+&quot; ! &quot;);  返回发送的消息
}</code></pre>
<h3 id="3-ws-html"><a href="#3-ws-html" class="headerlink" title="3. ws.html"></a>3. ws.html</h3><pre><code class="javascript">//连接并订阅
var socket = new SockJS(&#39;/endpointWisely&#39;);  //连接名称为“。。。”的endpoint
var stompClient = Stomp.over(socket);     //使用stomp子协议
    stompClient.connect({},function(name){
        stompClient.subscribe(&#39;topic/getResponse&#39;,function(response){//订阅
        show();//自定义的展示方法
    })
})
stompClient.send(&quot;/welcome&quot;,{},JSON.stringify({&#39;name&#39;:name}));//发送消息</code></pre>
<h2 id="7-Spring-Data-JPA"><a href="#7-Spring-Data-JPA" class="headerlink" title="7.Spring Data JPA"></a>7.Spring Data JPA</h2><h3 id="1-EnableJpaRepositories"><a href="#1-EnableJpaRepositories" class="headerlink" title="1. @EnableJpaRepositories"></a>1. @EnableJpaRepositories</h3><pre><code>使用@EnableJpaRepositories(&quot;com.wisely.repos&quot;)来开启Spring Data JPA支持 其中的value参数用来扫描数据访问层所在包下的数据访问的接口定义</code></pre><h3 id="2-定义查询方法"><a href="#2-定义查询方法" class="headerlink" title="2. 定义查询方法"></a>2. 定义查询方法</h3><blockquote>
<p><code>常规查询</code> ：find、read、readBy、query、queryBy、get、getBy<br><code>查询关键字</code> ：And(和)、Or(或)、Is = Equals(等)、Between(位于之间)、LessThan(小于)、LessThanEqual(小于等于)<br>GreaterThan(大于)、GreaterThanEqual(大于等于)、After(日期大于)、Before(日期之前)<br>IsNull、IsNotNull = NotNull、Like、Not Like、Starting With(前面加%)<br>EndingWith(后面加%)、Containing(前后都加%)、OrderBy(排序)、Not、In<br>NotIn、True、False、IgnoreCase<br><code>限制查询结果</code> ：Top、First<br><code>@NamedQuery</code> : 一个名称映射一个查询语句<br>    eg:    @NamedQuery(name = “Person.findByName”,query = “select p from Person p where p.name=?1”)<br>        写在实体类名上<br>@Query查询<br>    直接在@Query的value中书写sql语句，参数可以使用索引(“?1”)或者命名(“:name”)<br>更新查询：使用@Modifying 和 @Query 来组合更新查询</p>
</blockquote>
<h3 id="3-排序与分页"><a href="#3-排序与分页" class="headerlink" title="3. 排序与分页"></a>3. 排序与分页</h3><pre><code>Sort排序对象：     List&lt;Person&gt; findByName(String name,Sort sort);
Pageable对象：    List&lt;Person&gt; findByName(String name,Pageable pageable);
使用：    List&lt;Person&gt; persons = personRepository.findByName(&quot;xx&quot;,new Sort(Direction.ASC,&quot;age&quot;));
        List&lt;Person&gt; persons = personRepository.findByName(&quot;xx&quot;,new Pageable(0,10));</code></pre><h3 id="4-repository默认的方法："><a href="#4-repository默认的方法：" class="headerlink" title="4. repository默认的方法："></a>4. repository默认的方法：</h3><pre><code>save()    保存；        
findAll()    查询所有；        
findAll(new Sort(Sort.Direction.ASC,&quot;age&quot;))        排序查询所有；
findAll(new PageRequest(0,10))        分页查询；
findAll(new PageRequest(1,2,new Sort(Sort.Direction.DESC,&quot;age&quot;)))    分页排序</code></pre><h2 id="8-SpringBoot的注解式事务-Transactional"><a href="#8-SpringBoot的注解式事务-Transactional" class="headerlink" title="8.SpringBoot的注解式事务  @Transactional"></a>8.SpringBoot的注解式事务  @Transactional</h2><pre><code>属性：
    1.propagation 定义事务的生命周期
        REQUIRED             如果没有事务则新建
        REQUIRED_NEW        始终开启新事务
        SUPPORTS            有就用，没有就不用
        NESTED                类似于REQUIRED_NEW，但是不支持jps与hibernate
        NOT_SUPPORTS        不在事务中执行
        NEVER                强制不在事务中执行，有事务则抛出异常
        MANDATORY            强制在事务中执行，没有则抛出异常
    2.isolation  事务的隔离机制，决定了事务的完整性
        READ_UNCOMMITED      读不提交(脏读、幻读、不可重复读)
        READ_COMMITED        读提交(不可重复读和幻读)，解决脏读
        REPEATABLE_READ        A读取某条数据时，B不许修改(幻读)
        SERIALIZABLE        序列化
    3.timeout    事务过期时间
    4.readOnly    指当前事务是否是只读事务
    5.rollbackFor    指定哪个异常会回滚
    6.noRollBackFor    指定哪个异常不会回滚</code></pre><p>1.@GetMapping注解：相当于 @RequestMapping(Method=RequestMethod.GET)<br>    该注解将HTTP GET映射到特定的方法上<br>2.@RequestParam注解：将Request参数绑定到处理函数的参数中<br>    如：public String getUserId(@RequestParam(“id”) int id); 这样就可以将localhost:8080/?id=123中的id参数赋给方法中的id<br>3.@JsonIgnoreProperties(ignoreUnknown = true)<br>    将这个注解卸载类上之后，就会忽略类中不存在的字段<br>    使用@JsonIgnoreProperties({“internalId”,”secretKey”})指定的字段不会被序列化和反序列化<br>4.数据校验<br>    1.在实体类的属性前添加如：@NotEmpty、@Min(value=18,message=”未成年禁止入内”)等<br>    2.在Controller层的方法，要校验的参数上添加@Valid注解<br>        如果需要返回错误信息，则需要传入BindingResult对象，用于获取校验失败情况下的反馈信息<br>5.ModelMapper对象<br>    一个从对象到对象的框架，能将javaBean对象从一种表现形式转化为另一种表现形式，采用“约定”来配置<br>    eg:        Person person = modelMapper.map(personDTO,Person.class);            //将PersonDTO的对象，转换成Person对象<br>            Person personInDB = personService.getById(userId,PersonDTO.getId())    //在service层对userid和person.id做了处理，从数据库取出person.id对应的Person，userid则是权限判断<br>            return modelMapper.map(personService.save(userId,person),PersonDTO.class);    //再将保存返回的person转为personDTO<br>6.@PathVariable注解<br>    可以绑定占位符传过来的值到方法的参数上<br>7.@RequestMapping的变形<br>    @GetMapping、@PostMapping、@PutMapping、@DeleteMapping<br>8.@RequestParam和@PathVariable的区别<br>    1.@RequestParam和@PathVariable都是从request中接收请求的，都可以接收参数<br>    2.@RequestParam  支持defaultValue（默认值）、name、value、required参数<br>    3.@PathVariable  能够识别URL里面的一个模板 eg:@RequestMapping(“/hello/{id}”)<br>    4.@PathParam     同@PathVariable，但是属于JBoss的<br>    5.@QueryParam     同@RequestParam,属于JAX-RS<br>    6.@ResponseBody  服务器返回的时候以一种什么样的方式进行返回<br>    7.@RequestBody<br>9.@Documentd注解<br>    映射实体类与MongoDB文件<br>10.http状态码<br>    1XX 临时响应，并需要请求者继续执行操作的状态代码<br>    2XX 请求成功<br>    3XX 重定向代码<br>    4XX 表示请求出错<br>    5XX 服务器内部错误<br>11.自定义注解<br>    @Retention注解<br>        定义被它所注解的注解保留多久，一共有三种策略：<br>            public enum RetentionPolicy{<br>                SOURCE,CLASS,RUNTIME<br>            }<br>        1.SOURCE  被编译器忽略<br>        2.CLASS  注解会被保留在Class文件中，但在运行时并不会被vm保留(默认)<br>        3.RUNTIME  保留至运行时，可以通过反射去获取注解信息。<br>    @Target注解<br>        说明该注解可以被声明在哪些元素之前<br>            public enum ElementType{<br>                TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,<br>                ANNOTATION_TYPE,PACKAGE,TYPE_PARAMETER,TYPE_USE<br>            }<br>        1.TYPE  类之前<br>        2.FIELD  类的字段前<br>        3.METHOD  类的方法前<br>        4.PARAMETER  方法参数前<br>        5.CONSTRUCTOR  构造方法前<br>        6.LOCAL_VARIABLE  局部变量之前<br>        7.ANNOTATION_TYPE  注解类型之前<br>        8.PACKAGE  包名前<br>12.Spring框架下的AOP Annotation<br>    1.切入点语法：<br>        execution(public * * (..))<br>        execution(* set* (..))<br>        execution(* com.xyz.servie.AccountService.* (..))<br>        execution(* com.xyz.service.<em>.</em> (..))<br>        within(com.xyz.service.<em>)    //service包中<br>        within(com.xyz.service..</em>)    //service或其子包<br>    2.声明通知<br>        1.@Before 前置通知<br>        2.@AfterReturning  后置通知<br>        3.AfterThrowing  异常通知，在一个方法抛出异常后执行<br>        4.@After  最终通知，必会执行的<br>        5.@Around  环绕通知，在方法执行前及执行后，常用于线程安全的情况下，共享数据<br>13.Spring Security<br>    1.安全处理方法：<br>        1.access(String)                Spring EL表达式结果为true时可访问<br>        2.anonymouns()                    匿名可访问<br>        3.denyAll()                        用户不能访问<br>        4.fullyAuthenticated()            用户完全认证可访问(非remeber me)<br>        5.hasAnyAuthority(String..)        如果用户有参数，则其中任一权限可访问<br>        6.hasAnyRole(String..)                    如果用户有参数，则其中任一角色可访问<br>        7.hasAuthority(String)            如果用户有参数，则其权限可访问<br>        8.hasRole(String)                若用户由参数中的角色可访问<br>        9.permitAll()                    用户可任意访问<br>        10.rememberMe()                    允许通过remember-me登陆的用户访问<br>        11.authenticated()                用户登陆后可访问<br>14.JMS<br>    1.安装ActiveMQ<br>    2.在application.properties中配置ActiveMQ的消息代理地址<br>        spring.activemq.broker-url=tcp://localhost:61616<br>    3.定义发送端<br>        需要实现MessageCreator接口，并重写其createMessage方法<br>        eg:     class Msg implements MessageCreator{<br>                    @override<br>                    public Message createMessage() throws JMSException{<br>                        return session.createTextMessage(“发送了消息”);<br>                    }<br>                }<br>    4.定义发送及目的地<br>        1.使用CommandLineRunner接口，用于程序启动后执行的代码，通过重写其run方法执行<br>        2.注入Springboot提供的JmsTemplate的Bean<br>        3.通过JmsTemplate的send方法向 “my-destination” 目的地发送Msg 的消息<br>        eg:        class Ch934Application implements CommandLineRunner{<br>                    @AutoWired<br>                    JmsTemplate jmsTemplate;</p>
<pre><code>                @Override
                public void run(String... args) throws Exception{
                    jmsTemplate.send(&quot;my-destination”,new Msg());
                }
            }
    4.定义消息监听
        使用@JmsListener注解，来简化JMS开发。只需要在这个注解的属性destination指定要监听的目的地，即可接收该目的地发送的消息。
    eg:        class Receiver{
                @JmsListener(destination = &quot;my-destination”)
                public void receiveMessage(String message){
                    sout(&quot;收到：&quot;+message+&quot;，消息&quot;)
                }
            }














    #SpringBoot的配置文件.properties</code></pre><h1 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h1><pre><code>logging.config=classpath:logback-spring.xml</code></pre><h1 id="Mysql-Configuration"><a href="#Mysql-Configuration" class="headerlink" title="Mysql Configuration"></a>Mysql Configuration</h1><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/pgc                          #数据库地址
spring.datasource.username=root                                                #账号
spring.datasource.password=password                                            #密码</code></pre><h1 id="Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production"><a href="#Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production" class="headerlink" title="Keep the connection alive if idle for a long time (needed in production)"></a>Keep the connection alive if idle for a long time (needed in production)</h1><pre><code>spring.datasource.testWhileIdle=true                                        #指定连接是否被空闲来连接回收器检验
spring.datasource.validationQuery=SELECT 1                                    #验证从连接池取出的连接</code></pre><h1 id="Show-or-not-log-for-each-sql-query"><a href="#Show-or-not-log-for-each-sql-query" class="headerlink" title="Show or not log for each sql query"></a>Show or not log for each sql query</h1><pre><code>spring.jpa.show-sql=true                                                    #运行时输出sql语句</code></pre><h1 id="Hibernate-ddl-auto-save-save-drop-update"><a href="#Hibernate-ddl-auto-save-save-drop-update" class="headerlink" title="Hibernate ddl auto (save, save-drop, update)"></a>Hibernate ddl auto (save, save-drop, update)</h1><pre><code>spring.jpa.hibernate.ddl-auto=update                                        #hibernate数据定义的规则，更新</code></pre><h1 id="Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’"><a href="#Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’" class="headerlink" title="Set to true if we need to populate the database using ‘data.sql’."></a>Set to true if we need to populate the database using ‘data.sql’.</h1><pre><code>spring.datasource.initialize=false                                            #指定初始化数据源，是否用data.sql来初始化，默认: true</code></pre><h1 id="Naming-strategy"><a href="#Naming-strategy" class="headerlink" title="Naming strategy"></a>Naming strategy</h1><pre><code>spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy    #指定命名策略</code></pre><h1 id="The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database"><a href="#The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database" class="headerlink" title="The SQL dialect makes Hibernate generate better SQL for the chosen database"></a>The SQL dialect makes Hibernate generate better SQL for the chosen database</h1><pre><code>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect    #hibernate方言</code></pre><h1 id="Mongodb-Configuration"><a href="#Mongodb-Configuration" class="headerlink" title="Mongodb Configuration"></a>Mongodb Configuration</h1><pre><code>spring.data.mongodb.uri=mongodb://localhost:27000/pgc                        #mongodb的uri</code></pre><h1 id="OSS-Configuration"><a href="#OSS-Configuration" class="headerlink" title="OSS Configuration"></a>OSS Configuration</h1><pre><code>oss.endpoint=oss-cn-shanghai.aliyuncs.com                                    #oss阿里云的相关配置
oss.access.key.id=LTAIxYKpaBqbAIK3
oss.access.key.secret=WuTDXWS8PBqSdqMuMxrPfT5ryYmmd0
oss.bucket.name=new-pgc
spring.http.multipart.maxFileSize=100MB
spring.http.multipart.maxRequestSize=100MB</code></pre><h1 id="SSO-Configuration"><a href="#SSO-Configuration" class="headerlink" title="SSO Configuration"></a>SSO Configuration</h1><pre><code>security.enabled=true</code></pre><p>#默认callback<br>    security.defaultCallback=/</p>
<p>#sso验证token地址<br>    security.ssoServerValidate=<a href="http://106.15.179.107:7127/api/c/sso/validate-token" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/validate-token</a></p>
<p>#如果本地应用没有登陆就去验证<br>    security.ssoServerAuth=<a href="http://106.15.179.107:7127/api/c/sso/auth" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/auth</a></p>
<p>#本地应用密码<br>    security.ssoKey=574163310</p>
<p>#本地应用地址, should be defined by the same field under each app</p>
<h1 id="security-appHost-http-localhost-8000"><a href="#security-appHost-http-localhost-8000" class="headerlink" title="security.appHost=http://localhost:8000"></a>security.appHost=<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a></h1><p>#gizp<br>    spring.resources.chain.gzipped=true</p>
<p>注：<br>1.Java Web获取IP，及ip所在地址<br>    在请求头getHeader()中，”x-forwarded-for”、”Proxy-Client-IP”、”WL-Proxy-Client-IP”<br>    请求地址:getRemoteAddr();<br>2.请求参数与路径变量<br>    1.请求参数<br>        采用key = value形式，并用 “&amp;” 分隔<br>            eg:localhost:8080/user?name=spring&amp;pwd=123<br>        在传统的servlet中，可以通过HttpServletRequest的getParameter()方法取值<br>        在SpringMVC中则提供了一个注解”@RequestParam”来注释方法参数<br>    2.路径参数<br>        类似请求参数，但是没有key部分，只是一个值<br>            eg:localhost:8080/user/spring<br>        为了使用路径变量，首先需要在@RequestMapping注解的值属性中添加一个变量，该变量必须放在花括号之间<br>            eg:@RequestMapping(value=”/user/{pwd}”)<br>        使用时，在方法签名中加上@PathVariable注解<br>            eg:public String test(@PathVariable(name=”pwd”) string password)<br>3.lambda表达式<br>    1.用lambda实现Runnable<br>        new Thread( () -&gt; sout(“Lambda expression rocks！！”) ).start();<br>        等价于：<br>        new Thread(<br>            new Runnable(){<br>                @Override<br>                public void run(){<br>                    sout(“Lambda expression rocks！！”) ;<br>                }<br>            }<br>        ).start();<br>    2.对列表进行迭代<br>        list.forEach( n -&gt; sout(n) );<br>        如果输出和参数相同，则可以省略参数<br>        list.forEach( System.out::println() );<br>    3.函数式接口Predicate<br>        可以向API添加逻辑，用更少的代码支持更多的动态行为。<br>        eg:    public void filter(String name,Predicate condition){<br>                if(condition.test(name)){<br>                    sout(name+” “);<br>                }<br>            }<br>        那么在调用时，我们就可以通过predicate来进行判断<br>        eg:<br>            List languages = Arrays.asList(“Java”, “Scala”, “C++”, “Haskell”, “Lisp”);<br>            filter(langugages,str -&gt; str.startWith(“J”));<br>    4.Map和Reduce(是Stream的方法)<br>        1.map允许你将对象进行转换，将列表中的每个元素转换为修改之后的值。<br>        eg:    List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>            costBeforeTax.stream().map( (cost)-&gt;cost+.12<em>cost )<br>                                        .forEach(System.out::println);<br>        2.reduce可以对所有值进行合并，比较类似SQL中的sum()、avg()、count()等<br>        eg:对修改后的数据进行计算，接收多个值，返回一个值<br>            costBeforeTax.stream().map( (cost)-&gt;cost+.12</em>cost )<br>                                        .reduce( (sum,cost)-&gt; sum+cost).get();<br>    5.filter过滤<br>        使用lambda表达式和流API过滤大规模数据集合，流提供了一个filter()方法，接受一个Predicate对象，即可以传入一个lambda表达式作为过滤逻辑<br>        eg:    List<string> filtered = strList.stream().filter( x-&gt; x.length()&gt;10).collect(Collectors.toList);<br>            得到的结果为：过滤后的strList，长度都是大于10的<br>    6.distinct()去重<br>        numbers.stream().distinct().collect(Collectors.toList);<br>    7.集合的最大值、最小值、总和及平均值<br>        IntStream、LongStream和DoubleStream等流的类中，有个方法叫做summaryStatistics()，可以返回IntSummaryStatistics、LongSummaryStatistics或者DoubleSummaryStatistic<br>        eg:    IntSumnumberList stats = numberList.stream().mapToInt((x)-&gt;x).summaryStatistics()<br>            stats存在    getMax、getMin、getSum、getAverage、getCount方法<br>    8.Lambda表达式与匿名类<br>        this关键字：<br>            匿名类的this关键字指向匿名类<br>            lambda表达式的this关键字指向包围lambda表达式的类<br>        编译方式：<br>            java编译器将lambda表达式编译成类的私有方法，使用java7的invokedynamic字节码指令来动态绑定这个方法。<br>    9.限制：<br>        1.lambda表达式只能引用final或final局部变量，即在lambda内部不能修改定义在域外的变量。<br>    10.避免Null<br>        当出现多层嵌套时，调用其中的方法可能会抛出NullPointException异常,所以我们可以通过Optional类型来预防null检查<br>        eg:new Outer().getNested().getInner().getFoo()中可能会出现Null异常<br>            修改过后：<br>            Optional.of(new Outer())<br>                    .map(Outer::getNested)<br>                    .map(Nested::getInner)<br>                    .map(Inner::getFoo)<br>                    .ifPresent(System.out::println);<br>    11.Optional类<br>        是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象。<br>        Optional是个容器，它可以保存类型T的值，或者仅仅保存null。<br>        Optional类的引入很好的解决空指针异常。<br>4.Git使用规范流程<br>    1.新建分支<br>        每次开发新功能，都应该新建一个单独的分支<br>        #获取主分支最新代码<br>            git checkout master<br>            git pull<br>        #新建一个开发分支<br>            git checkout -b myfeature<br>    2.提交分支commit<br>        分支修改后，就可以提交commit了<br>            git add -all            #all表示保存所有变化，也是默认的<br>            git status                #查看发生变动的文件<br>            git commit –verbose    #verbose参数，会列出diff的结果<br>    3.撰写提交信息<br>        提交commit时，必须给出完整的提交信息<br>         eg：第一行是不超过50字的提要<br>             空一行<br>             *罗列出改动原因、主要变动、需要注意的问题（可多行）<br>             空一行<br>             提供对应的网址<br>    4.与主干同步<br>        git fetch master<br>    5.合并commit<br>        分支开发完成后，可能有一堆commit，但是合并到主干时，最好只有一个commit，清晰易管理<br>            git rebase -i origin/master        #i参数表示互动，此时会打开一个互动界面<br>        可用的命令：<br>            1.pick        #正常选中<br>            2.reword    #选中，并且修改提交信息<br>            3.edit        #钻中，rebase时会暂停，允许你修改这个commit<br>            4.squash    #选张，会将当前commit与上一个commit合并<br>            5.fixup        #与squash相同，但不会保存当前commit的提交信息<br>            6.exec        #执行其他shell命令<br>        其中，squash和fixup可以用来合并commit<br>        另外，PonyFoo提出另一种合并commit的简洁方法，就是先撤销过去5个commit，再建一个新的<br>            git reset HEAD~5<br>            git add<br>            git commit -am “Here’s the bug fix that closes #28”<br>            git push –force<br>    6.推送到远程仓库<br>        合并commit之后，就可以推送当前分支到远程仓库了<br>            git push –force origin myfeature<br>        “–force”表示强行推送，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，可能需要强行推送<br>    7.发出Pull Request<br>        提交到远程仓库以后，就可以发出Pull Request到master分支，然后请求别人进行代码review，确认可以合并到master</string></p>
<p>4.2    Git分支管理策略<br>    Vincent Driessen提出了一个分支管理的策略，使得版本库的演进保持简洁，主干清晰。<br>    1.主分支Master<br>        代码库有且仅有的一个主分支，提供给用户使用的正式版本，都在此分支上发布<br>    2.开发分支Develop<br>        这个分支可以用来生成代码的最新隔夜版本(nightly)，如果想正式对外发布，就在Master分支上，对Develop分支进行合并(merge)<br>        git merge –no-ff develop<br>    3.临时性分支<br>        1.feature     功能分支<br>        2.release    预发布分支<br>        3.fixbug    修补bug分支<br>        这三种分支都属于临时性需要，使用完以后，应该删除，代码库的常设分支只有Master和Develop</p>
<ol start="5">
<li>组合(Composition)与聚合(Aggregation)的区别<br>1.Composition 表示的是’Part-od’的关系<br>  比如：引擎Engine是汽车Car的一部分，脱离了汽车的引擎毫无作用，没有实在的意义<br>2.而Aggregation表示的是’Has-a’的关系<br>  比如：Person有一个Address，但是Address的存在不依赖于Person，即地址本身就有其独立存在的意义，不受人的约束。<br>3.就强弱关系而言：<br>  Composition应该更强一些</li>
<li>交并补<br>  1.List集合的交并补<pre><code>  list1.addAll(list2);    //并集
  list1.retainAll(list2);    //交集,返回Boolean
  list1.removeAll(list2);    //差集
  list2.removeAll(list1);
  list1.addAll(list2);    //无重复并集</code></pre></li>
<li>SpringMVC迁移至SpringBoot</li>
</ol>
<p>8.lucene和solr<br>    1.lucene<br>        lucene是一个开放源代码的 全文检索 引擎工具包,并不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本引擎。目的在于为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以此为基础建立起完整的全文检索引擎。</p>
<pre><code>2.solr
    是一个高性能，给予lucene的全文搜索服务器。同时对其进行了拓展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可拓展并对查询性能进行了优化，并且提供了一个完整的功能管理界面，是一款非常优秀的全文搜索引擎。它对外提供类似于WebService的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Solr Get操作提出查找请求，并得到XML格式的返回结果、

3.Solr和Lucene的区别
    1.搜索服务器：
        lucene本质上是搜索库，不是独立的应用程序
    2.企业级
        lucene专注于搜索底层的建设，而Solr专注于企业应用。
    3.管理
        lucene不负责支撑搜索服务所必须的管理
    一句话总结：Solr是Lucene面向企业搜索应用的扩展</code></pre><p>9.Gradle<br>    1.简介：<br>        是一个基于JVM的构建工具</p>
<p>10.Nginx<br>    1.反向代理-解决前端跨域问题<br>        跨域-浏览器为了安全问题而限制了跨域访问，如果a，b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的。<br>        由配置来完成：<br>            1.让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。<br>            2.配置一个特殊的’/api’目录的访问，并且对url执行了重写<br>                rewrite ^/api/(.*)$/$1 break;<br>            代表重写拦截进来的请求，并且只能对域名后边以’/api’开头的起作用，break表示匹配一个之后停止匹配</p>
<p>11.详解SpringData<br>    1.概念<br>        Spring Data的目的是为了简化构建基于Spring框架应用的数据访问技术，包括非关系型数据库、Map-Reduce框架、云数据服务等等；另外也包含对关系数据库的访问支持。<br>    2.Spring Data的子项目：<br>        1.Commons    提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化<br>        2.Hadoop    基于Spring的Hadoop作业配置和一个POJO编程模型的MapReduce作业<br>            MapReduce是一种编程模型，用于大规模数据集(大于1TB)的并行运算<br>        3.Key-value 集成了Redis和Riak，提供多个常用场景下的简单封装<br>        4.Document  集成文档数据库，CouchDB和MongoDB并提供基本的配置映射和资料库的支持<br>        5.Graph        集成Neo4j提供强大的基于POJO的编程模型<br>        6.Graph Roo AddOn - Rooney support for Neo4j<br>        7.JDBC Extensions    支持Oracle RAD、高级队列和高级数据类型<br>        8.JPA         简化创建JPA数据访问层和跨存储的持久层功能<br>        9.Mapping     基于Grails的提供对象映射框架，支持不同的数据库<br>        10.Examples    示例程序、文档和图数据库<br>        11.Guidance 高级文档<br>    3.Repository<br>        1.如果dao接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean注入到IOC容器中，进而可以再该接口中定义满足一定规则的接口<br>            或者通过一个朱姐@RepositoryDefination注解来替代Repository接口<br>        2.在Repository接口中声明方法<br>            1.查询方法以 find|read|get开头<br>            2.设计条件查询，条件的属性需要定义关键字连接<br>            3.条件的属性以字母大写<br>            4.支持属性的级联查询，若当前类由符合条件的属性，则优先使用，则不使用级联属性<br>        3.通过自定义的JPQL完成update和delete操作<br>            注意：JPQL不支持Insert操作<br>            在@Query注解中编写JPQL语句，单必须使用@Modify进行修饰，以通知SpringData，这是一个Update或者delete<br>            因为update和delete需要使用事务，而默认情况下springdata的每个方法上都有一个只读事务，不能完成修改操作<br>            因此需要使用@Modify修饰</p>
<p>23种设计模式:<br>    1.装饰者模式<br>        允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰者可以在所委托被装饰者的行为之前或者之后加上自己的行为，以达到特定的目的。<br>        参考：<a href="https://blog.csdn.net/wwh578867817/article/details/51480441" target="_blank" rel="noopener">https://blog.csdn.net/wwh578867817/article/details/51480441</a><br>        eg：<br>            假设我们去咖啡店点了一杯咖啡，可以加奶加糖，咖啡、奶、糖各有不同的价格。<br>                此时咖啡就是我们的组件，奶和糖就是我们的装饰者<br>        实现细节：<br>            Component 抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互<br>            ConcreteComponent具体构件角色（真实对象）：io流中的FileInputStream、　　　　FileOutputStream<br>            Decorator 装饰对象：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。<br>            ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。</p>
<p>OAuth 2.0 关于授权的开放网络标准<br>    1.几个专用名词<br>        Third-party application:    第三方应用程序，又称“客户端”(client)<br>        HTTP service:                HTTP服务提供商<br>        Resource Owner：            资源所有者，即“用户”(user)<br>        User Agent:                    用户代理，即浏览器<br>        Authorization server：        认证服务器，即服务提供商专门用来处理认证的服务器<br>        Resource server:            资源服务器，即服务提供商存放用户生成的资源的服务器。与认证服务器可以是同一台，也可以不是<br>    2.OAuth的思路<br>        OAuth在客户端与服务提供商之间，设置了一个授权层，客户端不能直接登录“服务提供商”，只能登录授权层，以此将用户与客户端区分开来。“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>        “客户端”登录授权层以后，“服务提供商”根据令牌的权限范围和有效期，向“客户端”开放用户存储的资料</p>
<pre><code>                ----    (A)Authorization Request---&gt;       |Resource|
                &lt;---    (B)Authorization Grant    ----    | Owner  |

      +------+    ----    (c)Authorization Grant    ---&gt;    |Authorization|
      |Client|  &lt;---    (D)Access Token            ----    |    Server    |
      +------+                
                ----    (E)Access Token            ---&gt;    |Resource  |
                &lt;---    (F)Protected Resrouce    ----    |    Server |
    解析：
        （A）用户打开客户端以后，客户端要求用户给予授权
        （B）用户同意给予客户端授权
        （C）客户端使用上一步获得的授权，向认证服务器申请令牌
        （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌
        （E）客户端使用令牌，向资源服务器申请获取资源
        （F）资源服务器确认令牌无误，同意向客户端开发资源
3.其中B步骤的客户端授权模式
    1.授权码模式（authorization code）

    2.简化模式（implicit）

    3.密码模式（resource owner password credentials）

    4.客户端模式（client credentials）

    具体参数查看：http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
4.更新令牌
    如果用户访问的时候，客户端的“访问令牌”已经过期，则需要使用“更新令牌”申请一个新的访问令牌。
    客户端发出更新令牌的HTTP请求，包含以下参数：
        granttype：表示使用的授权模式，此处的值固定为&quot;refreshtoken&quot;，必选项。
        refresh_token：表示早前收到的更新令牌，必选项。
        scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。
    eg： 
        POST /token HTTP/1.1
         Host: server.example.com
         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
         Content-Type: application/x-www-form-urlencoded
         grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</code></pre><p>Swagger<br>    1.概念：<br>        Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步<br>    2.SpringBoot集成Swagger<br>        1.添加maven依赖，在pom文件中添加：<br>            springfox-swagger2<br>        2.添加swagger配置文件，如下：<br>            @Configuration<br>            @EnableSwagger2<br>            public class SwaggerConfiguration {<br>                @Bean<br>                public Docket api() {<br>                    return new Docket(DocumentationType.SWAGGER_2)<br>                            .ignoredParameterTypes(HttpSession.class)<br>                            .apiInfo(apiInfo())<br>                            .select()            //选择那些路径和api会生成document<br>                            .apis(RequestHandlerSelectors.any())    //对所有api进行监控<br>                            .paths(PathSelectors.any())        //对所有路径进行监控<br>                            .build();<br>                }</p>
<pre><code>            private ApiInfo apiInfo() {
                return new ApiInfoBuilder()
                        .title(&quot;pgc接口调用说明&quot;)
                        .description(&quot;该文档仅供内部人员使用.&quot;)
                        .termsOfServiceUrl(&quot;http://xxxx&quot;)
                        .version(&quot;1.0&quot;)
                        .build();
            }
        }
    3.此时访问项目下的api-docs，能返回json形式的界面
3.添加SwaggerUI
    springfox-swagger-ui
    生成一个可读性良好的API页面。
    此时可以访问项目下的swagger-ui.html
4.Swagger对RESTful风格的api支持的比较好。</code></pre><p>SpringBoot拦截器之WebMvcConfigurerAdapter</p>
<pre><code>1.几个比较常见的：
    /* 这里配置视图解析器 */
    void configureViewResolvers(ViewResolverRegistry registry);

    /* 配置内容裁决的一些选项*/
    void configureContentNegotiation(ContentNegotiationConfigurer configurer);

    /* 视图跳转控制器 */
    void addViewControllers(ViewControllerRegistry registry);

    /* 静态资源处理 */
    void addResourceHandlers(ResourceHandlerRegistry registry);

    /* 默认静态资源处理器 */
    void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);
具体方法查看：https://blog.csdn.net/wujiaqi0921/article/details/78324722</code></pre><p>SpringBoot 序列化器注解使用方法<br>    1.@JsonIgnoreProperties<br>        类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响<br>    2.@JsonIgnore<br>        属性或方法注解（最好在属性上），作用同JsonIgnoreProperties<br>    3.@JsonFormat<br>        属性或方法注解（最好在属性上），可以方便的把Date类型直接转化为我们想要的模式，例如@JsonFormat(pattern=”yyyy-MM-dd HH-mm-ss”)<br>    4.@JsonSerialize<br>        用于属性或getter方法上，用于在序列化时嵌入我们自定义的代码<br>    5.@JsonDeserialize<br>        用于属性或getter方法上，用于在反序列化时可以嵌入我们自定义的代码</p>
<p>SpringBoot 使用 JavaMailSender发送邮件<br>—–.SpringBoot<br>        添加依赖<br>        <dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-mail</artifactid><br>        </dependency><br>    2.配置属性<br>        spring.mail.host=smtp.qq.com<br>        spring.mail.username=用户名<br>        spring.mail.password=密码<br>        spring.mail.properties.mail.smtp.auth=true<br>        spring.mail.properties.mail.smtp.starttls.enable=true<br>        spring.mail.properties.mail.smtp.starttls.required=true<br>    3.测试<br>        @Autowired<br>        private JavaMailSender mailSender;</p>
<pre><code>    SimpleMailMessage message = new SimpleMailMessage();
    message.setFrom(&quot;1153693791@qq.com&quot;);
    message.setTo(&quot;1153693791@qq.com&quot;);
    message.setSubject(&quot;主题：&quot;+title);
    message.setText(content);
    mailSender.send(message);</code></pre><p>Spring JPA 开启审计功能：<br>    JPA Audit:<br>        在Spring jpa中，支持在字段或者方法上进行注解@CreateDate,@CreatedBy,@LastModifiedDate,@LastModifiedBy<br>    使用：<br>        1.申明实体类，需要在类上添加注解@EntityListeners(AuditingEntityListener.class)，<br>            @Entity<br>            @Table(name = “store_source_bind”)<br>            @EntityListeners(AuditingEntityListener.class)<br>            public class StoreSourceBind {</p>
<pre><code>    2.在需要的字段上加上@CreateDate,@CreatedBy,@LastModifiedDate,@LastModifiedBy
    @Column(name = &quot;create_time&quot;)
    @CreatedDate
    private Date createTime;

    3.继承AuditorAware&lt;T&gt;来指定返回的创建信息:
        @Component(&quot;auditorAware&quot;)
        public class SpringSecurityAuditorAware implements AuditorAware&lt;String&gt; {

            private HttpSession session;

            @Override
            public String getCurrentAuditor() {
                return Utils.getUserIdFromSession(session);
            }
        }
    4.在application启动类中加上注解EnableJpaAuditing或者EnableMongoAuditing（MongoDB的审计），

    @EnableJpaAuditing
    @EnableMongoAuditing(auditorAwareRef = &quot;auditorAware&quot;)//开启审计功能
    public class WalletApplication {
        public static void main(String[] args) {
            new SpringApplicationBuilder(WalletApplication.class).web(true).run(args);
        }
    }</code></pre><p>SpringBoot 定时任务：</p>
<pre><code>1.开启定时任务的配置
  在启动文件上，添加注解 @EnableScheduling
2.创建定时任务
  在需要定时执行的文件上方添加注解：
      @Scheduled(fixedRate = 5000)
3. @Scheduled 详解：
    1.fixedRate = 5000 ：上次开始执行时间点之后5秒执行
    2.initialDelay = 1000 , fixedRate = 5000 
        第一次延迟 1 秒后执行，之后按照 5 秒的规则执行
    3.cron = &quot;*/5 ***&quot;) :
        通过 cron 表达式定义规则</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/POI操作EXCEl/index.html">通过 POI 将数据库中的数据上传至 OSS 对象存储</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/poi/index.html">poi</a></span><div class="content"><h1 id="通过-POI-将数据库中的数据上传至-OSS-对象存储"><a href="#通过-POI-将数据库中的数据上传至-OSS-对象存储" class="headerlink" title="通过 POI 将数据库中的数据上传至 OSS 对象存储"></a>通过 POI 将数据库中的数据上传至 OSS 对象存储</h1><center>
`我爱你，第一句是假的，第二句也是假的。`
</center>

<p><img src="https://upload-images.jianshu.io/upload_images/13603359-996a2c470135ea09.png" alt="我爱你，第一句是假的，第二句也是假的。"></p></div><a class="more" href="/2018/09/29/后端/java/POI操作EXCEl/index.html#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/DB-MySQL常用命令/index.html">模拟Ping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/工具函数/index.html">工具函数</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a></span><div class="content"><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code class="mysql">/* Windows服务 */
-- 启动 MySQL
    net start mysql
-- 创建Windows 服务
    sc create mysql binPath= mysqld_bin_path(等号与值之间有空格)
/* 连接与断开服务器 */
    mysql -h 地址 -P 端口 -u 用户名 -p 密码
-- 显示哪些线程正在运行
    SHOW PROCESSLIST
-- 显示系统变量信息
    SHOW VARIABLES</code></pre>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><pre><code class="mysql">/* 数据库操作 */
-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES [ LIKE &#39;PATTERN&#39; ]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 数据库名 选项信息
-- 删除库
    DROP DATABASE [ IF EXISTS ] 数据库名
        同时删除数据库相关的目录及目录内容</code></pre>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><pre><code class="mysql">-- 创建表
    CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [数据库名.]表名 (
        表的结构定义
    ) [表选项]
        - 每个字段必须有数据类型
        - 最后一个字段后不能有都好
        - TEMPORARY 临时表，会话结束时表自动消失
        - 对于字段的定义：
            字段名 数据类型 [NOT NULL|NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | PRIMARY [KEY]] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        - 如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        - 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        - 常见的引擎：InnoDB、MyISAM、Memory/Heap、BDB、Merge、Example、CSV、MaxDB、Archive
        - 不同的引擎在保存表的结构和数据时采用不同的方式
            - MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
            - InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        - 显示存储引擎的状态信息
            SHOW ENGINES；
        - 显示存储引擎的日志或状态信息
            SHOW ENGINE 引擎名 {LOGS|STATUS}
    -- 自增起始数
        AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ...
-- 查看所有表
    SHOW TABLES [LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 库名
-- 查看表结构
    SHOW CREATE TABLE 表名
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;pattern&#39;]
    SHOW TABLE STATUS [FROM db_name] [like &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        - eg: ALTER TABLE db_name ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名
        - RENAME 可以交换两个表名
    -- 修改表的字段结构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD [COLUMN] 字段定义               -- 增加字段
            ADD [COLUMN] AFTER 字段名            -- 增加在该字段名后面
            ADD [COLUMN] FIRST                   -- 增加在第一个
            ADD PRIMARY KEY(字段名)            -- 创建主键
            ADD UNIQUE [索引名] (字段名)          -- 创建唯一索引
            ADD INDEX [索引名] (字段名)          -- 创建普通索引
            DROP [COLUMN] 字段名                 -- 删除字段
            MODIFY [COLUMN] 字段名 字段属性     -- 支持对字段属性修改，不支持修改字段名
            CHANGE [COLUMN] 原字段名 新字段名 属性 -- 支持对字段名修改
            DROP PRIMARY KEY                  -- 删除主键(删除主键前，需要删除其 AUTO_INCREMENT 属性)
            DROP INDEX 索引名                    -- 删除索引
            DROP FOREIGN KEY 外键                 -- 删除外键
-- 删除表
    DROP TABLE [IF EXISTS] 表名...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 复制名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tb_name [,tb_name2] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name]...</code></pre>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><pre><code class="mysql">-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[,(值列表),...]
        - 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表
        - 可同时插入多条数据记录
        - REPLACE 与 INSERT 完全一样，可互换
    INSERT [INTO] 表名 SET 字段名=值[,字段名=值,...]
-- 删
    DELETE FROM 表名 [删除条件子句]
        - 没有条件子句，会删除全部
-- 改
    UPDATE 表名 SET 字段名=值[,字段名=值,...] [更新条件]
-- 查
    SELECT 字段列表 FROM 表名 [其他子句]
        - 可来自多个表的多个字段
        - 其他子句可以不使用
        - 字段列表可以用*代替，表示所有字段</code></pre>
<h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><pre><code class="mysql">-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码无需一致
-- 查看所有字符集编码项
SHOW VARIABLES LIKE &#39;character_set_%&#39;
    character_set_client    -- 客户端向服务器发送数据时使用的编码
    character_set_results    -- 服务器端将结果返回给客户端所使用的编码
    character_set_connection-- 连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES gbk;     -- 以上三个配置
-- 校对集
    校对集用以排序
    -- 查看所有字符集
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;] / SHOW CHARSET [LIKE &#39;pattern&#39;]
    -- 查看所欲校对集
    SHOW COLLATION [LIKE &#39;pattern&#39;]
    -- 设置字符集编码
    CHARSET 字符集编码
    -- 设置校对集编码
    COLLATE 校对集编码</code></pre>
<h2 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h2><pre><code class="mysql">1. 数值类型
-- a.整型
    类型            字节        范围
    tinyint       1字节     -128~127 无符号位：0~255
    smallint      2字节      -32768~32767
    mediumint      3字节     -8388608~8388607
    int          4字节    
    bigint         8字节
    int(M)         M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例如：int(5) 插入&#39;123&#39;,补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好
    - 1表示bool真，0表示bool假。常用 tinyint(1) 表示布尔型
-- b.浮点型
    类型            字节        范围
    float         4字节
    double         8字节
    - 浮点型既支持符号位 unsigned，也支持显示宽度 zerofill
        - 不同于整型，前后均会补填0
    - 定义浮点型时，需指定总位数和小数位数
        - float(M,D)    double(M,D)
        - M表示总位数，D表示小数位数
        - M和D的大小会决定浮点数的范围，不同于整型的固定范围
        - M既表示总位数(不包括小数点和正负号)，也表示显示宽度(所有显示符号均包括)
        - 支持科学计数法表示
        - 浮点数表示近似值
-- c.定点数
    decimal  -- 可变长度
    decimal(M,D)  -- M表示总位数，D表示小数位数
    - 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入
    - 将浮点数转换为字符串来保存，每9位数字保存为4个字节
2. 字符串类型
-- a.char，varchar
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    - M表示能存储的最大长度，此长度为字符数，非字节数
    - 不同的编码，所占用的空间不同
    - char，最多255个字符，与编码无关
    - varchar，最多65535个字符，与编码有关
    - 一条有效记录最大不能超过 65535 个字节
     - utf8 最大为21844个字符，gbk 最大为 32766个字符，latin 最大为65532个字符
    - varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存
    - varchar 的最大有效长度由最大行大小和使用的字符集确定。
    - 最大有效长度是 65532 字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是 64432-1-2=65532字节
     - 例如：表 定义为 CREATE TABLE tb(c1 int,c2 char(30),c3 varchar(N)) charset=utf8；问N的最大值是多少？答：(65535-1-2-4-30*3)/3
-- b.blob,text
    blob    二进制字符串（字节字符串）
        tinyblob,blob,mediumblob,longblob
    text    非二进制字符串（字符字符串）
        tinytext,text,mediumtext,longtext
    - text 在定义时，不需要定义长度，也不会计算总长度
    - text 类型在定义时，不可给default值
-- c,binary,varbinary
    类似于 char 和 varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串
    char、varchar、text 对应 binary、varbinary、blob
3. 日期时间类型
    一般用整型保存时间戳
    datetime        8字节    日期及时间
        YYYY-MM-DD hh:mm:ss
    date            3字节 日期
        YYYY-MM-DD
        YY-MM-DD
        YYYYMMDD
        YYMMDD
    timestamp        4字节 时间戳
        YY-MM-DD hh:mm:ss
        YYYYMMDDhhmmss
        YYMMDDhhmmss
    time            3字节 时间
        hh:mm:ss
        hhmmss
    year            1字节 年份
        YYYY
        YY
4. 枚举和集合
-- 枚举
    enum(val1,val2,val3...)
        - 在已知的值中进行单选，最大数量为65535
        - 枚举值在保存时，以2字节的整型保存，每个枚举值，按保存的位置顺序，从1开始逐一递增
        - 表现为字符串类型，存储却是整型
        - NULL值的索引是NULL
        - 空字符串错误值的索引值是0
-- 集合
    set(val1,val2,val3....)
        - CREATE TABLE tb(gener set(&#39;男&#39;,&#39;女&#39;,&#39;无&#39;))
        - INSERT INTO tb values (&#39;男，女&#39;)
        - 最多可以有64个不同成员，以bigint存储，共8字节，采取位运算的形式
        - 当创建表时，SET 成员值的尾部空格将自动删除</code></pre>
<p>文章摘抄自 <a href="https://juejin.im/post/5d6faf8f6fb9a06b0b1c9535?utm_source=gold_browser_extension" target="_blank" rel="noopener">掘金 - 一千行MySQL命令</a> 。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>