<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives/index.html"><span class="pull-left">文章</span><span class="pull-right">239</span></a><a class="author-info-articles__tags article-meta" href="/tags/index.html"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories/index.html"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives/index.html">归档</a><a class="site-page" href="/tags/index.html">标签</a><a class="site-page" href="/categories/index.html">分类</a><a class="site-page" href="/about/index.html">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/20/读书笔记/《高性能MySQL》/1.数据库设计规范/index.html">《高性能MySQL》第一章 数据库设计规范</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/index.html">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/高性能MySQL/index.html">高性能MySQL</a></span><div class="content"><h1 id="第一章-数据库设计规范"><a href="#第一章-数据库设计规范" class="headerlink" title="第一章 数据库设计规范"></a>第一章 数据库设计规范</h1><h2 id="1-数据库-命名规范"><a href="#1-数据库-命名规范" class="headerlink" title="1. 数据库 - 命名规范"></a>1. 数据库 - 命名规范</h2><ol>
<li>所有数据库对象名称必须使用小写字母并用下划线分割<ol>
<li>eg：DbName != dbname</li>
<li>eg: Table != table != tabLe</li>
</ol>
</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字<ol>
<li>保留关键字：<a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/keywords.html</a></li>
</ol>
</li>
<li>数据库对象的命名要做到见名识义，并且最好不要超过 32 字符<ol>
<li>数据库名过长，会增加网络开销</li>
</ol>
</li>
<li>临时库必须以 tmp 为前缀，并以日期为后缀</li>
<li>备份库、备份表必须以 bak 为前缀，并以日期为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致<ol>
<li>即表A与表B的某个属性相同，则列名与类型必须一致</li>
<li>如 A.cid与 B.cid，都必须是 <code>cid int unsigned not null</code></li>
<li>这种属性一般用于关联列上，当保持一致时，对数据库查询效率有一定帮助</li>
</ol>
</li>
</ol>
<h2 id="2-数据库-基本设计规范"><a href="#2-数据库-基本设计规范" class="headerlink" title="2. 数据库 - 基本设计规范"></a>2. 数据库 - 基本设计规范</h2><ol>
<li>所有表必须使用 Innodb 存储引擎<ol>
<li>在 MySQL 5.5 之前，MylSAM 是默认的存储引擎，MylSAM 是表级锁，在高并发场景下，锁表会有很严重的性能问题</li>
<li>InnoDB 是 5.6 以后的默认存储引擎</li>
<li>InnoDB 支持事务，行级锁，拥有更好的恢复性，高并发场景下性能更好</li>
</ol>
</li>
<li>数据库和表的字符集统一使用 UTF8<ol>
<li>统一字符集可以避免由于字符集转换产生的乱码</li>
<li>MySQL 中 UTF8 字符集汉字占 3 个字节，ASCII 码占一个字符</li>
</ol>
</li>
<li>所有表和字段都需要添加注释<ol>
<li>使用 comment 从句添加表和列的备注</li>
<li>从一开始就进行数据字典的维护</li>
</ol>
</li>
<li>尽量控制单表数据量的大小，建议控制在 500W 以内<ol>
<li>500 W 并不是 MySQL 数据库的限制</li>
<li>可以使用历史数据归档，分库分表等手段限制单表的数据量大小</li>
</ol>
</li>
<li>谨慎使用 MySQL 分区表<ol>
<li>分区表在物理上表现为多个文件，在逻辑上表现为一个表</li>
<li>谨慎选择分区键，跨分区查询效率可能更低</li>
<li>建议采用物理分表的方式管理大数据</li>
</ol>
</li>
<li>尽量做到冷热数据分离，减小表的宽度<ol>
<li>减少磁盘IO，保证热数据的内存缓存命中率</li>
<li>更有效的利用缓存，避免读入无用的冷数据</li>
<li>经常一起使用的列放在一个表中</li>
</ol>
</li>
<li>禁止在表中建立预留字段<ol>
<li>预留字段的命名很难做到见名识义</li>
<li>预留字段无法确认存储的数据类型，所以无法选择合适的类型</li>
<li>对预留字段类型的修改，会对表进行锁定<ol>
<li>在 MySQL 中，对表类型修改的成本远远大于增加一个数据类型的成本</li>
</ol>
</li>
</ol>
</li>
<li>禁止在数据库中存储图片，文件等二进制数据<ol>
<li>blob、text 等类型</li>
</ol>
</li>
<li>禁止在线上做数据库压力测试</li>
<li>禁止从开发环境、测试环境直连生产环境数据库</li>
</ol>
<h2 id="3-数据库-索引设计规范"><a href="#3-数据库-索引设计规范" class="headerlink" title="3. 数据库 - 索引设计规范"></a>3. 数据库 - 索引设计规范</h2><ol>
<li>限制每张表的索引数量，建议单张表索引不超过 5 个<ol>
<li>索引并不是越多越好，过多的索引可能会降低效率</li>
<li>禁止给表中的每一列都建立单独的索引</li>
</ol>
</li>
<li>每个 InnoDB 表必须有一个主键<ol>
<li>Innodb 是按照主键索引的顺序来组织表的，因此每个表必须有一个主键</li>
<li>如果表中未设置主键，MySQL 会自动选择第一个非空唯一性的属性作为主键；如果没有非空唯一约束的属性，MySQL 会自动生成一个 6 字节的主键，但是效率不高</li>
<li>不使用更新频繁的列作为主键，不使用多列主键</li>
<li>不使用 UUID、MD5、HASH、字符串列作为主键</li>
<li>主键建议选择使用主键自增ID</li>
</ol>
</li>
<li>常见索引建议<ol>
<li>SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>
<li>多表 JOIN 的字段</li>
</ol>
</li>
<li>如何选择索引列的顺序<ol>
<li>区分度最高的列放在联合索引的最左侧</li>
<li>尽量把字段长度小的列放在联合索引的最左侧</li>
<li>使用最频繁的列放在联合索引的最左侧</li>
</ol>
</li>
<li>避免建议冗余索引和重复索引<ol>
<li>eg: primary key(id) 、index(id)、unique index(id)</li>
<li>eg: index(a,b,c)，index(a,b)，index(a)<ol>
<li>对于冗余索引，MySQL 执行优化器会对查询到的索引进行选择，降低了索引使用的效率</li>
</ol>
</li>
</ol>
</li>
<li>对于频繁的查询优先考虑使用覆盖索引<ol>
<li>避免 Innodb 表进行索引的二次查找</li>
<li>可以把随机 IO 变为顺序 IO，提高查询效率</li>
</ol>
</li>
<li>尽量避免使用外键<ol>
<li>不建议使用外键约束，但一定在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能<ol>
<li>存在外键约束的表在进行写操作时，会检查外键约束的完整性，降低写操作的性能</li>
</ol>
</li>
</ol>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/14/读书笔记/《Java并发编程的艺术》/0.0_目录/index.html">《Java并发编程的艺术》读书笔记 - 目录</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java并发编程的艺术/index.html">Java并发编程的艺术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/index.html">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/并发编程/index.html">并发编程</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/高并发/index.html">高并发</a></span><div class="content"><p><img src="https://images.gitbook.cn/FqT6_h3A4raxz0Sw6-cR9o8TdQIo?imageView2/2/h/500" alt="Java并发编程的艺术"></p></div><a class="more" href="/2019/06/14/读书笔记/《Java并发编程的艺术》/0.0_目录/index.html#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/14/读书笔记/《Java并发编程的艺术》/11.Java并发编程实践/index.html">《Java并发编程的艺术》Java并发编程实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-14</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/13/读书笔记/《Java并发编程的艺术》/10.Executor框架/index.html">《Java并发编程的艺术》第十章 Executor框架</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-13</time><div class="content"><h1 id="第十章-Executor-框架"><a href="#第十章-Executor-框架" class="headerlink" title="第十章 Executor 框架"></a>第十章 Executor 框架</h1><p>从 JDK 1.5 开始，Java 将工作单元与执行机制分离开来。</p>
<p>工作单元包括 Runnable 和 Callable，而执行机制由 Executor 框架提供。</p>
<h2 id="10-1-Executor-框架介绍"><a href="#10-1-Executor-框架介绍" class="headerlink" title="10.1 Executor 框架介绍"></a>10.1 Executor 框架介绍</h2><h2 id="10-1-1-Executor-框架的两级调度模型"><a href="#10-1-1-Executor-框架的两级调度模型" class="headerlink" title="10.1.1 Executor 框架的两级调度模型"></a>10.1.1 Executor 框架的两级调度模型</h2><p>上层：Java 多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor 框架）将这些任务映射为固定数量的线程。</p>
<p>底层：操作系统内核将这些线程映射到硬件处理器上。</p>
<h2 id="10-1-2-Executor-框架结构与成员"><a href="#10-1-2-Executor-框架结构与成员" class="headerlink" title="10.1.2 Executor 框架结构与成员"></a>10.1.2 Executor 框架结构与成员</h2><h4 id="1-Executor-框架的结构"><a href="#1-Executor-框架的结构" class="headerlink" title="1. Executor 框架的结构"></a>1. Executor 框架的结构</h4><p>Executor 框架主要由 3 部分组成：</p>
<ul>
<li>任务。包括被执行任务需要实现的接口：Runnable、Callable接口<ul>
<li>Runnable 接口和 Callable 接口 都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行</li>
</ul>
</li>
<li>任务的执行。包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。<ul>
<li>Executor ，是 Executor 框架的基础，将任务的提交与任务的执行分离开来</li>
<li>ThreadPoolExecutor，是线程池的核心实现类，用来执行被提交的任务</li>
<li>ScheduledThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令，比 Timer 更灵活、强大。</li>
</ul>
</li>
<li>异步计算的结果。包括接口 Future 和实现 Future 的 FutureTask 类<ul>
<li>Future 接口和实现 Future 的 FutureTask 类，代表异步计算的结果。</li>
</ul>
</li>
</ul>
<p>主要流程为：</p>
<ol>
<li>主线程创建实现 Runnable、Callable 接口的任务对象</li>
<li>Executors 将 Runnable 对象封装为 Callable 对象</li>
<li>将 Runnable 对象交给 ExecutorService.execute(Runnable command) 执行，或者交给 ExecutorService.submit(Callable<t> task) 执行<ol>
<li>如果执行 submit，则 ExecutorService 返回一个实现 Future 接口的对象。</li>
<li>由于 FutureTask 实现了 Runnable，因此FutureTask 也可以直接交给 ExecutorService 执行</li>
</ol>
</t></li>
<li>主线程执行 FutureTask.get() 方法等待任务执行完成；或者执行 FutureTask.cancel(boolean mayInterruptIfRunning) 来取消任务执行</li>
</ol>
<h4 id="2-Executor-框架的成员"><a href="#2-Executor-框架的成员" class="headerlink" title="2. Executor 框架的成员"></a>2. Executor 框架的成员</h4><ol>
<li>ThreadPoolExecutor：通常由工厂类 Executors 创建，可创建以下 3 种类型的ThreadPoolExecutor<ol>
<li>FixedThreadPool：创建使用固定线程数的ThreadPool，适用于需要限制当前线程数量的应用场景，适用于负载较重的服务器。</li>
<li>SingleThreadExecutor：创建使用单个线程的 ThreadPool，适用于需要顺序执行各个任务；且在任意时间点，不会有多个线程是活动的应用场景</li>
<li>CachedThreadPool：创建一个会根据需要创建新线程的 ThreadPool，是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</li>
</ol>
</li>
<li>ScheduledThreadPoolExecutor：通常由工厂类 Executors 创建，可创建以下 2 种类型的 ScheduledThreadPoolExecutor<ol>
<li>ScheduledThreadPoolExecutor，包含若干线程，适用于需要多个后台线程周期执行任务，同时需要限制后台线程数量的场景</li>
<li>SingleThreadScheduledExecutor，只包含一个线程，适用于需要单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景</li>
</ol>
</li>
<li>Future/FutureTask：表示异步计算的结果</li>
<li>Runnable/Callable：被 ThreadPoolExecutor 执行的任务。<ol>
<li>Runnable 不返回结果</li>
<li>Callable 返回结果</li>
</ol>
</li>
</ol>
<h2 id="10-2-ThreadPoolExecutor-详解"><a href="#10-2-ThreadPoolExecutor-详解" class="headerlink" title="10.2 ThreadPoolExecutor 详解"></a>10.2 ThreadPoolExecutor 详解</h2><ul>
<li><p>corePool：核心线程池的大小</p>
</li>
<li><p>maximumPool：最大线程池大小</p>
</li>
<li><p>BlockingQueue：阻塞队列，用来暂存任务的工作队列</p>
</li>
<li><p>RejectedExecutionHandler：拒绝策略，当 ThreadPoolExecutor 关闭或饱和时，将要调用的 Handler</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/12/读书笔记/《Java并发编程的艺术》/9.Java中的线程池/index.html">《Java并发编程的艺术》第九章 Java中的线程池</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-12</time><div class="content"><h1 id="第九章-Java-中的线程池"><a href="#第九章-Java-中的线程池" class="headerlink" title="第九章 Java 中的线程池"></a>第九章 Java 中的线程池</h1><p>Java 中的线程池是运用场景最多的并发框架，几乎所有异步或并发执行的程序都可以使用线程池。合理使用线程池的好处有：</p>
<ol>
<li>降低资源消耗<ol>
<li>通过重复利用已创建的线程降低线程创建和销毁时的消耗</li>
</ol>
</li>
<li>提高响应速度<ol>
<li>当任务抵达时，无需创建线程，就能立即执行</li>
</ol>
</li>
<li>提高线程的可管理型<ol>
<li>线程池能够统一分配、调优和监控线程</li>
<li>线程属于稀缺资源，不能无限制的创建</li>
</ol>
</li>
</ol>
<h2 id="9-1-线程池的实现原理"><a href="#9-1-线程池的实现原理" class="headerlink" title="9.1 线程池的实现原理"></a>9.1 线程池的实现原理</h2><p><img src="http://fcsimg.weifuw.com/thread_pool.png" alt="线程池的主要处理流程"></p>
<p><img src="https://images2017.cnblogs.com/blog/584724/201708/584724-20170828233957765-2055354276.png" alt="ThreadPoolExecutor 执行示意图"></p>
<p><code>ThreadPoolExecutor.execute(Runnable command)</code> 方法如下：</p>
<pre><code class="java">    /**
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn&#39;t, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }</code></pre>
<h2 id="9-2-线程池的使用"><a href="#9-2-线程池的使用" class="headerlink" title="9.2 线程池的使用"></a>9.2 线程池的使用</h2><h3 id="9-2-1-创建线程池"><a href="#9-2-1-创建线程池" class="headerlink" title="9.2.1 创建线程池"></a>9.2.1 创建线程池</h3><pre><code class="java">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></pre>
<p>通过上面的构造方法来创建一个线程池，其具体参数如下：</p>
<ol>
<li><p>corePoolSize 线程池的基本大小</p>
<ol>
<li>线程池的基本大小，当任务提交时，会创建线程进行执行，且不会销毁。</li>
<li>调用 prestartAllCoreThreads() 提前创建并启动所有基本线程</li>
</ol>
</li>
<li><p>maximumPoolSize</p>
<ol>
<li>线程池允许创建的最大线程数</li>
</ol>
</li>
<li><p>keepAliveTime</p>
<ol>
<li>线程活动保持时间</li>
</ol>
</li>
<li><p>workQueue</p>
<ol>
<li>任务队列，用于保存等待执行的任务的阻塞队列<ol>
<li>ArrayBlockingQueue</li>
<li>DelayedWorkQueue</li>
<li>ForwardingBlockingQueue</li>
<li>SynchronousQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
</ol>
</li>
</ol>
</li>
<li><p>threadFactory</p>
<ol>
<li><p>用于设置创建线程的工厂</p>
</li>
<li><p>如使用 guava 提供的 ThreadFactoryBuilder 可以快速给线程池中的线程设置有意义的名字，如：</p>
</li>
<li><blockquote>
<p>new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();</p>
</blockquote>
</li>
</ol>
</li>
<li><p>handler</p>
<ol>
<li>饱和策略，当队列和线程池都满了，则需要一种策略来处理新提交的任务</li>
<li>默认策略为 AbortPolicy</li>
<li>JDK 提供的几种策略：<ol>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="9-2-2-提交任务至线程池"><a href="#9-2-2-提交任务至线程池" class="headerlink" title="9.2.2 提交任务至线程池"></a>9.2.2 提交任务至线程池</h3><p>execute() 方法，用于提交不需要返回值的任务，所以无法判断任务是否执行成功。</p>
<p>submit() 方法，用于提交需要返回值的任务。线程池会返回一个 future 类型对象。</p>
<h3 id="9-2-3-关闭线程池"><a href="#9-2-3-关闭线程池" class="headerlink" title="9.2.3 关闭线程池"></a>9.2.3 关闭线程池</h3><p>通过 shutdown 或 shutdownNow 方法来关闭线程池。</p>
<p>原理：遍历线程池中的工作线程，逐个调用线程的 interrupt 方法来中断线程，所以无法相应的线程可能永远无法终止。</p>
<p>调用这两个方法后，isShutdown 会返回true；当所有任务都关闭后，isTerminated 返回true。</p>
<p>通常会使用 shutdown 来关闭线程池，但是如果任务不一定要执行完毕，可以调用 shutdownNow 方法。</p>
<h3 id="9-2-4-合理地配置线程池"><a href="#9-2-4-合理地配置线程池" class="headerlink" title="9.2.4 合理地配置线程池"></a>9.2.4 合理地配置线程池</h3><p>想要合理配置线程池，需要先分析任务的特性：</p>
<ul>
<li>任务的性质：CPU 密集型任务、IO 密集型任务、混合型任务<ul>
<li>CPU 密集型任务应该配置尽可能小的线程，如 N(cpu) + 1 个线程的线程池</li>
<li>IO 密集型任务并非一直执行任务，应该配置尽可能多的线程，如 2*N(cpu) 个线程的线程池</li>
<li>混合型任务：如果可以拆分，将其拆分为一个 CPU 密集型任务和一个 IO 密集型任务</li>
</ul>
</li>
<li>任务的优先级：高、中、低<ul>
<li>优先级不同的任务，可以使用 PriorityBlockingQueue 优先级队列来处理</li>
<li>如果一直提交高优先级任务，则低优先级任务可能永远不会执行</li>
</ul>
</li>
<li>任务的执行时间：长、中、短<ul>
<li>可以使用优先级队列，让执行时间短的任务先执行</li>
<li>或者不同时间的任务交给不同规模的线程池来处理</li>
</ul>
</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接<ul>
<li>如依赖数据库连接的线程，当提交SQL 给数据库后需要等待数据库返回结果，等待时间越长，CPU空闲越久。那么线程数可以设置的越大，更好的利用CPU</li>
</ul>
</li>
</ul>
<blockquote>
<p>Runtime.getRuntime().availableProcessors() 获取当前设备的 CPU 个数。</p>
</blockquote>
<blockquote>
<p><code>建议使用有界队列</code> 。有界队列能增加系统的稳定性和预警能力。</p>
</blockquote>
<h3 id="9-2-5-线程池监控"><a href="#9-2-5-线程池监控" class="headerlink" title="9.2.5 线程池监控"></a>9.2.5 线程池监控</h3><p>监控线程池时可以使用以下属性：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，&lt;= taskCount</li>
<li>largestPoolSize：线程池里曾创建过的最大线程数量。<ul>
<li>可以通过该数据知道线程池是否满过</li>
</ul>
</li>
<li>getPoolSize：线程池的线程数量<ul>
<li>如果线程池不销毁的话，线程池里的线程不会自动销毁</li>
</ul>
</li>
<li>getActiveCount：获取活动的线程数</li>
</ul>
<p>或者可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated 方法。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/34/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><span class="page-number current">35</span><a class="page-number" href="/page/36/">36</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/36/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>