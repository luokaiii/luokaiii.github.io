<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="回廊一寸相思地，落月成孤倚。背灯和月就花阴，已是十年踪迹十年心。"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>回廊一寸相思地，落月成孤倚。背灯和月就花阴，已是十年踪迹十年心。 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">回廊一寸相思地，落月成孤倚。背灯和月就花阴，已是十年踪迹十年心。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">266</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">44</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">回廊一寸相思地，落月成孤倚。背灯和月就花阴，已是十年踪迹十年心。</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/07/读书笔记/《Java并发编程的艺术》/8.Java中的并发工具类/">《Java并发编程的艺术》第八章 Java 并发工具类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/">Java并发编程的艺术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java并发编程的艺术/">Java并发编程的艺术</a></span><div class="content"><h1 id="第八章-Java-中的并发工具类"><a href="#第八章-Java-中的并发工具类" class="headerlink" title="第八章 Java 中的并发工具类"></a>第八章 Java 中的并发工具类</h1><h2 id="8-1-CountDownLatch-等待多线程完成"><a href="#8-1-CountDownLatch-等待多线程完成" class="headerlink" title="8.1 CountDownLatch 等待多线程完成"></a>8.1 CountDownLatch 等待多线程完成</h2><p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。</p>
<p>CountDownLatch 在构造时接收 int 参数作为计数器，当线程执行到 countDown 是，计数器数值 N - 1 。可以是 1 个线程执行 N 个步骤，也可以是多个线程共同执行 N 个步骤。</p>
<p>await 方法会使线程进入等待状态，如果线程执行过久，可以使用 await(long time,TimeUnit unit)，等待特定时间。</p>
<h2 id="8-2-CyclicBarrier-同步屏障"><a href="#8-2-CyclicBarrier-同步屏障" class="headerlink" title="8.2 CyclicBarrier 同步屏障"></a>8.2 CyclicBarrier 同步屏障</h2><p>CyclicBarrier 意思为可循环使用的屏障，当一组达到一个屏障时被阻塞，知道最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续运行。</p>
<p>CountDownLatch 的计数器只能使用一次</p>
<h3 id="8-2-1-CyclicBarrier"><a href="#8-2-1-CyclicBarrier" class="headerlink" title="8.2.1 CyclicBarrier"></a>8.2.1 CyclicBarrier</h3><p>CyclicBarrier(int parties) 构造函数的参数表示需要屏障拦截的线程数量，线程调用 await 方法通知 CyclicBarrier 已到达屏障，然后线程被阻塞。</p>
<ol>
<li>如果 parties 参数为 3，但是只有两个线程执行 await 方法，那么这两个线程会一直阻塞</li>
<li>构造函数：CyclicBarrier(int parties,Runnable barrierAction) ，会在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。</li>
<li>getNumberWaiting ：获取 CyclicBarrier 阻塞的线程数量</li>
<li>isBroken() ：用来了解阻塞的线程是否被中断</li>
<li>reset() ：重置 CyclicBarrier 的计数器</li>
</ol>
<h2 id="8-3-Semaphore-控制并发线程数"><a href="#8-3-Semaphore-控制并发线程数" class="headerlink" title="8.3 Semaphore 控制并发线程数"></a>8.3 Semaphore 控制并发线程数</h2><p>Semaphore（信号量）用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理使用公共资源。</p>
<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><p>Semaphore 可以用于流量控制，特别是公共资源有限的应用场景，如数据库连接等。比如几十条线程并发读取数据，但是数据库只支持10个连接数，此时就需要使用 Semaphore 做流量控制，否则会报错，无法获取数据库连接。</p>
<p>Semaphore 的常用方法：</p>
<ul>
<li>acquire() ：获取一个许可证</li>
<li>release() ：释放一个许可证</li>
<li>tryAcquire：尝试获取许可证</li>
<li>int availablePermits()：返回此信号量中当前可用的许可证数</li>
<li>int getQueueLength()：返回正在等待获取许可证的线程数</li>
<li>boolean hasQueuedThreads()：是否有线程正在等待获取许可证</li>
<li>void reducePermits(int reduction)：减少reduction 个许可证（protected方法）</li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合（protected方法）</li>
</ul>
<h2 id="8-4-Exchanger-线程间交换数据"><a href="#8-4-Exchanger-线程间交换数据" class="headerlink" title="8.4 Exchanger 线程间交换数据"></a>8.4 Exchanger 线程间交换数据</h2><p>Exchange（交换者）是一个用于线程间协作的工具类。</p>
<p>Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p>
<p>当第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点后，会将彼此线程生产出来的数据传递给对方。</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li>Exchanger 可以用于遗传算法<ol>
<li>如AB进行交配，当交换数据后使用交叉规则得出两个交配结果</li>
</ol>
</li>
<li>Exchanger 可以用于校对工作<ol>
<li>如A、B线程同时执行，结果是否相同</li>
</ol>
</li>
</ol>
<blockquote>
<p>如果有一个线程一直未执行 exchange() ，则会一直等待。可以使用 exchange(V x,long timeout,TimeUnit unit) 设置最大等待时间。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/06/读书笔记/《Java并发编程的艺术》/9.Java中的线程池/">《Java并发编程的艺术》第九章 Java中的线程池</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/">Java并发编程的艺术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java并发编程的艺术/">Java并发编程的艺术</a></span><div class="content"><h1 id="第九章-Java-中的线程池"><a href="#第九章-Java-中的线程池" class="headerlink" title="第九章 Java 中的线程池"></a>第九章 Java 中的线程池</h1><p>Java 中的线程池是运用场景最多的并发框架，几乎所有异步或并发执行的程序都可以使用线程池。合理使用线程池的好处有：</p>
<ol>
<li>降低资源消耗<ol>
<li>通过重复利用已创建的线程降低线程创建和销毁时的消耗</li>
</ol>
</li>
<li>提高响应速度<ol>
<li>当任务抵达时，无需创建线程，就能立即执行</li>
</ol>
</li>
<li>提高线程的可管理型<ol>
<li>线程池能够统一分配、调优和监控线程</li>
<li>线程属于稀缺资源，不能无限制的创建</li>
</ol>
</li>
</ol>
<h2 id="9-1-线程池的实现原理"><a href="#9-1-线程池的实现原理" class="headerlink" title="9.1 线程池的实现原理"></a>9.1 线程池的实现原理</h2><p><img src="http://fcsimg.weifuw.com/thread_pool.png" alt="线程池的主要处理流程"></p>
<p><img src="https://images2017.cnblogs.com/blog/584724/201708/584724-20170828233957765-2055354276.png" alt="ThreadPoolExecutor 执行示意图"></p>
<p><code>ThreadPoolExecutor.execute(Runnable command)</code> 方法如下：</p>
<pre><code class="java">    /**
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn&#39;t, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }</code></pre>
<h2 id="9-2-线程池的使用"><a href="#9-2-线程池的使用" class="headerlink" title="9.2 线程池的使用"></a>9.2 线程池的使用</h2><h3 id="9-2-1-创建线程池"><a href="#9-2-1-创建线程池" class="headerlink" title="9.2.1 创建线程池"></a>9.2.1 创建线程池</h3><pre><code class="java">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</code></pre>
<p>通过上面的构造方法来创建一个线程池，其具体参数如下：</p>
<ol>
<li><p>corePoolSize 线程池的基本大小</p>
<ol>
<li>线程池的基本大小，当任务提交时，会创建线程进行执行，且不会销毁。</li>
<li>调用 prestartAllCoreThreads() 提前创建并启动所有基本线程</li>
</ol>
</li>
<li><p>maximumPoolSize</p>
<ol>
<li>线程池允许创建的最大线程数</li>
</ol>
</li>
<li><p>keepAliveTime</p>
<ol>
<li>线程活动保持时间</li>
</ol>
</li>
<li><p>workQueue</p>
<ol>
<li>任务队列，用于保存等待执行的任务的阻塞队列<ol>
<li>ArrayBlockingQueue</li>
<li>DelayedWorkQueue</li>
<li>ForwardingBlockingQueue</li>
<li>SynchronousQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
</ol>
</li>
</ol>
</li>
<li><p>threadFactory</p>
<ol>
<li><p>用于设置创建线程的工厂</p>
</li>
<li><p>如使用 guava 提供的 ThreadFactoryBuilder 可以快速给线程池中的线程设置有意义的名字，如：</p>
</li>
<li><blockquote>
<p>new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();</p>
</blockquote>
</li>
</ol>
</li>
<li><p>handler</p>
<ol>
<li>饱和策略，当队列和线程池都满了，则需要一种策略来处理新提交的任务</li>
<li>默认策略为 AbortPolicy</li>
<li>JDK 提供的几种策略：<ol>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="9-2-2-提交任务至线程池"><a href="#9-2-2-提交任务至线程池" class="headerlink" title="9.2.2 提交任务至线程池"></a>9.2.2 提交任务至线程池</h3><p>execute() 方法，用于提交不需要返回值的任务，所以无法判断任务是否执行成功。</p>
<p>submit() 方法，用于提交需要返回值的任务。线程池会返回一个 future 类型对象。</p>
<h3 id="9-2-3-关闭线程池"><a href="#9-2-3-关闭线程池" class="headerlink" title="9.2.3 关闭线程池"></a>9.2.3 关闭线程池</h3><p>通过 shutdown 或 shutdownNow 方法来关闭线程池。</p>
<p>原理：遍历线程池中的工作线程，逐个调用线程的 interrupt 方法来中断线程，所以无法相应的线程可能永远无法终止。</p>
<p>调用这两个方法后，isShutdown 会返回true；当所有任务都关闭后，isTerminated 返回true。</p>
<p>通常会使用 shutdown 来关闭线程池，但是如果任务不一定要执行完毕，可以调用 shutdownNow 方法。</p>
<h3 id="9-2-4-合理地配置线程池"><a href="#9-2-4-合理地配置线程池" class="headerlink" title="9.2.4 合理地配置线程池"></a>9.2.4 合理地配置线程池</h3><p>想要合理配置线程池，需要先分析任务的特性：</p>
<ul>
<li>任务的性质：CPU 密集型任务、IO 密集型任务、混合型任务<ul>
<li>CPU 密集型任务应该配置尽可能小的线程，如 N(cpu) + 1 个线程的线程池</li>
<li>IO 密集型任务并非一直执行任务，应该配置尽可能多的线程，如 2*N(cpu) 个线程的线程池</li>
<li>混合型任务：如果可以拆分，将其拆分为一个 CPU 密集型任务和一个 IO 密集型任务</li>
</ul>
</li>
<li>任务的优先级：高、中、低<ul>
<li>优先级不同的任务，可以使用 PriorityBlockingQueue 优先级队列来处理</li>
<li>如果一直提交高优先级任务，则低优先级任务可能永远不会执行</li>
</ul>
</li>
<li>任务的执行时间：长、中、短<ul>
<li>可以使用优先级队列，让执行时间短的任务先执行</li>
<li>或者不同时间的任务交给不同规模的线程池来处理</li>
</ul>
</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接<ul>
<li>如依赖数据库连接的线程，当提交SQL 给数据库后需要等待数据库返回结果，等待时间越长，CPU空闲越久。那么线程数可以设置的越大，更好的利用CPU</li>
</ul>
</li>
</ul>
<blockquote>
<p>Runtime.getRuntime().availableProcessors() 获取当前设备的 CPU 个数。</p>
</blockquote>
<blockquote>
<p><code>建议使用有界队列</code> 。有界队列能增加系统的稳定性和预警能力。</p>
</blockquote>
<h3 id="9-2-5-线程池监控"><a href="#9-2-5-线程池监控" class="headerlink" title="9.2.5 线程池监控"></a>9.2.5 线程池监控</h3><p>监控线程池时可以使用以下属性：</p>
<ul>
<li>taskCount：线程池需要执行的任务数量</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，&lt;= taskCount</li>
<li>largestPoolSize：线程池里曾创建过的最大线程数量。<ul>
<li>可以通过该数据知道线程池是否满过</li>
</ul>
</li>
<li>getPoolSize：线程池的线程数量<ul>
<li>如果线程池不销毁的话，线程池里的线程不会自动销毁</li>
</ul>
</li>
<li>getActiveCount：获取活动的线程数</li>
</ul>
<p>或者可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated 方法。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/05/读书笔记/《Java并发编程的艺术》/10.Executor框架/">《Java并发编程的艺术》第十章 Executor框架</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/">Java并发编程的艺术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java并发编程的艺术/">Java并发编程的艺术</a></span><div class="content"><h1 id="第十章-Executor-框架"><a href="#第十章-Executor-框架" class="headerlink" title="第十章 Executor 框架"></a>第十章 Executor 框架</h1><p>从 JDK 1.5 开始，Java 将工作单元与执行机制分离开来。</p>
<p>工作单元包括 Runnable 和 Callable，而执行机制由 Executor 框架提供。</p>
<h2 id="10-1-Executor-框架介绍"><a href="#10-1-Executor-框架介绍" class="headerlink" title="10.1 Executor 框架介绍"></a>10.1 Executor 框架介绍</h2><h2 id="10-1-1-Executor-框架的两级调度模型"><a href="#10-1-1-Executor-框架的两级调度模型" class="headerlink" title="10.1.1 Executor 框架的两级调度模型"></a>10.1.1 Executor 框架的两级调度模型</h2><p>上层：Java 多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor 框架）将这些任务映射为固定数量的线程。</p>
<p>底层：操作系统内核将这些线程映射到硬件处理器上。</p>
<h2 id="10-1-2-Executor-框架结构与成员"><a href="#10-1-2-Executor-框架结构与成员" class="headerlink" title="10.1.2 Executor 框架结构与成员"></a>10.1.2 Executor 框架结构与成员</h2><h4 id="1-Executor-框架的结构"><a href="#1-Executor-框架的结构" class="headerlink" title="1. Executor 框架的结构"></a>1. Executor 框架的结构</h4><p>Executor 框架主要由 3 部分组成：</p>
<ul>
<li>任务。包括被执行任务需要实现的接口：Runnable、Callable接口<ul>
<li>Runnable 接口和 Callable 接口 都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行</li>
</ul>
</li>
<li>任务的执行。包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。<ul>
<li>Executor ，是 Executor 框架的基础，将任务的提交与任务的执行分离开来</li>
<li>ThreadPoolExecutor，是线程池的核心实现类，用来执行被提交的任务</li>
<li>ScheduledThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令，比 Timer 更灵活、强大。</li>
</ul>
</li>
<li>异步计算的结果。包括接口 Future 和实现 Future 的 FutureTask 类<ul>
<li>Future 接口和实现 Future 的 FutureTask 类，代表异步计算的结果。</li>
</ul>
</li>
</ul>
<p>主要流程为：</p>
<ol>
<li>主线程创建实现 Runnable、Callable 接口的任务对象</li>
<li>Executors 将 Runnable 对象封装为 Callable 对象</li>
<li>将 Runnable 对象交给 ExecutorService.execute(Runnable command) 执行，或者交给 ExecutorService.submit(Callable<t> task) 执行<ol>
<li>如果执行 submit，则 ExecutorService 返回一个实现 Future 接口的对象。</li>
<li>由于 FutureTask 实现了 Runnable，因此FutureTask 也可以直接交给 ExecutorService 执行</li>
</ol>
</t></li>
<li>主线程执行 FutureTask.get() 方法等待任务执行完成；或者执行 FutureTask.cancel(boolean mayInterruptIfRunning) 来取消任务执行</li>
</ol>
<h4 id="2-Executor-框架的成员"><a href="#2-Executor-框架的成员" class="headerlink" title="2. Executor 框架的成员"></a>2. Executor 框架的成员</h4><ol>
<li>ThreadPoolExecutor：通常由工厂类 Executors 创建，可创建以下 3 种类型的ThreadPoolExecutor<ol>
<li>FixedThreadPool：创建使用固定线程数的ThreadPool，适用于需要限制当前线程数量的应用场景，适用于负载较重的服务器。</li>
<li>SingleThreadExecutor：创建使用单个线程的 ThreadPool，适用于需要顺序执行各个任务；且在任意时间点，不会有多个线程是活动的应用场景</li>
<li>CachedThreadPool：创建一个会根据需要创建新线程的 ThreadPool，是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</li>
</ol>
</li>
<li>ScheduledThreadPoolExecutor：通常由工厂类 Executors 创建，可创建以下 2 种类型的 ScheduledThreadPoolExecutor<ol>
<li>ScheduledThreadPoolExecutor，包含若干线程，适用于需要多个后台线程周期执行任务，同时需要限制后台线程数量的场景</li>
<li>SingleThreadScheduledExecutor，只包含一个线程，适用于需要单个后台线程执行周期任务，同时需要保证顺序执行各个任务的应用场景</li>
</ol>
</li>
<li>Future/FutureTask：表示异步计算的结果</li>
<li>Runnable/Callable：被 ThreadPoolExecutor 执行的任务。<ol>
<li>Runnable 不返回结果</li>
<li>Callable 返回结果</li>
</ol>
</li>
</ol>
<h2 id="10-2-ThreadPoolExecutor-详解"><a href="#10-2-ThreadPoolExecutor-详解" class="headerlink" title="10.2 ThreadPoolExecutor 详解"></a>10.2 ThreadPoolExecutor 详解</h2><ul>
<li><p>corePool：核心线程池的大小</p>
</li>
<li><p>maximumPool：最大线程池大小</p>
</li>
<li><p>BlockingQueue：阻塞队列，用来暂存任务的工作队列</p>
</li>
<li><p>RejectedExecutionHandler：拒绝策略，当 ThreadPoolExecutor 关闭或饱和时，将要调用的 Handler</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/04/读书笔记/《Java并发编程的艺术》/11.Java并发编程实践/">《Java并发编程的艺术》Java并发编程实践</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/">Java并发编程的艺术</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java并发编程的艺术/">Java并发编程的艺术</a></span><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/26/读书笔记/《React》简书慕课/0.目录/">《React》慕课笔记</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><ul>
<li><a href="/2019/05/07/读书笔记/《React》简书慕课/1.基础语法/index.html">基础语法</a></li>
<li><a href="/2019/05/08/读书笔记/《React》简书慕课/2.ReduxFlow/index.html">ReduxFlow</a></li>
<li><a href="/2019/05/09/读书笔记/《React》简书慕课/3.ReduxThunk/index.html">ReduxThunk</a></li>
<li><a href="/2019/05/10/读书笔记/《React》简书慕课/4.ReactRedux/index.html">ReactRedux</a></li>
<li><a href="/2019/05/11/读书笔记/《React》简书慕课/5.Immutable/index.html">Immutable</a></li>
<li><a href="/2019/05/12/读书笔记/《React》简书慕课/6.ReactRouterDom/index.html">ReactRouterDom</a></li>
<li><a href="/2019/05/13/读书笔记/《React》简书慕课/7.完整配置/index.html">完整项目初始化</a></li>
</ul></div><a class="more" href="/2019/05/26/读书笔记/《React》简书慕课/0.目录/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/13/读书笔记/《React》简书慕课/7.完整配置/">完整React配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><h1 id="React-入门"><a href="#React-入门" class="headerlink" title="React 入门"></a>React 入门</h1><h2 id="一、初始化项目结构"><a href="#一、初始化项目结构" class="headerlink" title="一、初始化项目结构"></a>一、初始化项目结构</h2><h3 id="1-创建-ReactApp"><a href="#1-创建-ReactApp" class="headerlink" title="1. 创建 ReactApp"></a>1. 创建 ReactApp</h3><blockquote>
<p>create-react-app leetcode</p>
</blockquote>
<h3 id="2-引入其他可能用到的依赖"><a href="#2-引入其他可能用到的依赖" class="headerlink" title="2. 引入其他可能用到的依赖"></a>2. 引入其他可能用到的依赖</h3><blockquote>
<p>yarn add antd // Ant Design 设计库<br>yarn add redux // Redux 数据层框架<br>yarn add react-redux // React-Redux React 更加方便集成 Redux<br>yarn add redux-thunk // Redux-Thunk 异步 Action<br>yarn add axios // Axios Http 请求工具<br>yarn add react-router-dom // ReactRouterDom 路由工具<br>yarn add immutable // Immutable 封装工具，将 store 封装起来<br>yarn add redux-immutable // ReactImmutable 子组件封装工具，将 store 的子 reducer 封装起来<br>yarn add styled-components // StyledComponents 使用 JS 编写 CSS 样式<br>yarn add react-loadable // 异步加载组件</p>
</blockquote>
<h3 id="3-创建-Redux-中的-Store，并使用-Redux-DevelopTools"><a href="#3-创建-Redux-中的-Store，并使用-Redux-DevelopTools" class="headerlink" title="3. 创建 Redux 中的 Store，并使用 Redux-DevelopTools"></a>3. 创建 Redux 中的 Store，并使用 Redux-DevelopTools</h3><h4 id="3-1-在-src-目录下，创建-store-reducer-js"><a href="#3-1-在-src-目录下，创建-store-reducer-js" class="headerlink" title="3.1 在 src 目录下，创建 store/reducer.js"></a>3.1 在 src 目录下，创建 store/reducer.js</h4><p>defaultState 为默认的 state，此文件导出一个函数，state 为 store 中存储的内容，action 为视图层发出的事件。</p>
<blockquote>
<p>需要先引入 redux。</p>
</blockquote>
<pre><code class="js">const defaultState = {};

export default (state = defaultState, action) =&gt; {
  return state;
};</code></pre>
<p>官方定义：Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。<br>其格式大致为：</p>
<pre><code class="js">const action = {
  type: &quot;ADD_TODO&quot;,
  value: &quot;xxx&quot;
};
dispatch(action);</code></pre>
<p>通过 dispatch 发送至 store，再由具体的 reducer 对 action 进行处理，将修改之后的 state 返回给 store，由 store 自己更新 state。</p>
<h4 id="3-2-在-src-目录下，创建-store-index-js"><a href="#3-2-在-src-目录下，创建-store-index-js" class="headerlink" title="3.2 在 src 目录下，创建 store/index.js"></a>3.2 在 src 目录下，创建 store/index.js</h4><p>Store 就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action) 方法更新 state；</li>
<li>通过 subscribe(listener) 注册监听器;</li>
<li>通过 subscribe(listener) 返回的函数注销监听器。</li>
</ul>
<pre><code class="js">import { createStore } from &quot;redux&quot;;
import reducer from &quot;./reducer&quot;;

const store = createStore(
  reducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
);

export default store;</code></pre>
<blockquote>
<p>注：<code>window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()</code> 为开启 Redux_Devtools<br>在使用其他中间件时，需要引入 applyMiddleware,下面会有 <a href="xxx">示例</a>。</p>
</blockquote>
<h4 id="3-3-测试-store-是否可用"><a href="#3-3-测试-store-是否可用" class="headerlink" title="3.3 测试 store 是否可用"></a>3.3 测试 store 是否可用</h4><p>第一步：在 reducer 的 defaultState 中加入一个属性 value</p>
<pre><code class="js">const defaultState = {
  value: &quot;Hello World!&quot;
};</code></pre>
<p>第二步：在任意组件引入 store/index.js，并获取到该 value 值。这里以 src/App.js 为例：</p>
<pre><code class="js">import React from &quot;react&quot;;
import &quot;./App.css&quot;;
import store from &quot;./store&quot;;

function App() {
  return &lt;div className=&quot;App&quot;&gt;{store.getState().value}&lt;/div&gt;;
}

export default App;</code></pre>
<p>第三步：启动项目，访问首页即可看到 value 值。</p>
<h3 id="4-使用-Immutable-封装-state"><a href="#4-使用-Immutable-封装-state" class="headerlink" title="4. 使用 Immutable 封装 state"></a>4. 使用 Immutable 封装 state</h3><p>immutable 是 facebook 开源的一个项目，用于实现 js 中的数据不可变，解决引用带来的副作用。</p>
<p>非常类似 Java 中的封装特性，即将属性私有化，提供公有方法访问私有变量。</p>
<blockquote>
<p>需要先引入 immutable</p>
</blockquote>
<p>修改之前的 src/store/reducer.js，将 defaultState 使用 immutable 提供的 fromJS 方法进行封装。</p>
<pre><code class="js">import { fromJS } from &quot;immutable&quot;;

const defaultState = fromJS({
  value: &quot;Hello World!&quot;
});

export default (state = defaultState, action) =&gt; {
  return state;
};</code></pre>
<p>完成之后，也需要在调用 store.getState().value 的地方，将其改为 store.getState().get(‘value’)。如上面的 src/App.js：</p>
<pre><code class="js">function App() {
  return &lt;div className=&quot;App&quot;&gt;{store.getState().get(&quot;value&quot;)}&lt;/div&gt;;
}</code></pre>
<h3 id="5-拆分-reducer，各组件分别管理各自的-reducer"><a href="#5-拆分-reducer，各组件分别管理各自的-reducer" class="headerlink" title="5. 拆分 reducer，各组件分别管理各自的 reducer"></a>5. 拆分 reducer，各组件分别管理各自的 reducer</h3><blockquote>
<p>需要依赖 redux-immutable</p>
</blockquote>
<p>使用 redux 自身的 combineReducers 也可以做到管理子 reducer，如下：</p>
<pre><code class="js">import { combineReducers } from &quot;redux&quot;;
import { reducer as premiumReducer } from &quot;../premium/store&quot;;

const reducer = combineReducers({
  premium: premiumReducer
});

export default reducer;</code></pre>
<p>但是 combineReducers 只能处理普通的 JS 对象，而 Store 中的所有属性已经被 Immutable 封装，此时我们要想使用子 reducer 中的属性时，需要这样写 <code>store.getState().premium.get(&#39;value&#39;)</code> 的方式获取数据。</p>
<p>显然，premium 依然可以存在被修改的副作用。</p>
<p>因此，我们只需要将 combineReducers 改为从 <code>redux-immutable</code> 中导入即可。</p>
<pre><code class="js">import { combineReducers } from &quot;redux-immutable&quot;;
import { reducer as premiumReducer } from &quot;../premium/store&quot;;

const reducer = combineReducers({
  premium: premiumReducer
});

export default reducer;</code></pre>
<p>获取数据的方式也会变为：<code>store.getState().getIn([&#39;premium&#39;,&#39;value&#39;])</code></p>
<h3 id="6-增加-Router-路由功能"><a href="#6-增加-Router-路由功能" class="headerlink" title="6. 增加 Router 路由功能"></a>6. 增加 Router 路由功能</h3><blockquote>
<p>需要依赖 react-router-dom</p>
</blockquote>
<p>第一步：创建另一个组件 src/premium/index.js</p>
<pre><code class="js">import React from &quot;react&quot;;

function Premium() {
  return &lt;div&gt;Premium page&lt;/div&gt;;
}

export default Premium;</code></pre>
<p>第二步：修改 App.js，将其改为 Router.js</p>
<p>定义两个路由， ‘/‘ 直接返回一个 Div dom；’/premium’ 返回刚刚创建的组件。</p>
<pre><code class="js">import React from &quot;react&quot;;
import { BrowserRouter, Route } from &quot;react-router-dom&quot;;
import Premium from &quot;./premium&quot;;

function Router() {
  return (
    &lt;div&gt;
      &lt;BrowserRouter&gt;
        &lt;Route path=&quot;/&quot; exact render={() =&gt; &lt;div&gt;Home Page&lt;/div&gt;} /&gt;
        &lt;Route path=&quot;/premium&quot; exact component={Premium} /&gt;
      &lt;/BrowserRouter&gt;
    &lt;/div&gt;
  );
}

export default Router;</code></pre>
<p>同时，src/index.js 也需要将 App 组件名换成 Router。</p>
<p>第三步：测试路由功能是否有效</p>
<p>启动项目，分别访问 <code>localhost:3000</code> 和 <code>localhost:3000/premium</code> 即可。</p>
<h3 id="7-使用-React-Redux-控制-Store"><a href="#7-使用-React-Redux-控制-Store" class="headerlink" title="7. 使用 React-Redux 控制 Store"></a>7. 使用 React-Redux 控制 Store</h3><p>通过 React-Redux 提供的 <code>&lt;Provider store&gt;</code> 标签，使 Provider 内的任何组件，都能够有权利使用 store 中的数据。</p>
<p>前提是组件需要先通过 connect 进行连接。</p>
<blockquote>
<p>需要依赖 react-redux</p>
</blockquote>
<h4 id="7-1-修改-Router-js-原-App-js"><a href="#7-1-修改-Router-js-原-App-js" class="headerlink" title="7.1 修改 Router.js (原 App.js)"></a>7.1 修改 Router.js (原 App.js)</h4><p>将需要用到 store 存储的组件，放在 Provider 标签内。并指定所使用的 store</p>
<pre><code class="js">import React from &quot;react&quot;;
import { BrowserRouter, Route } from &quot;react-router-dom&quot;;
import Premium from &quot;./premium&quot;;
import { Provider } from &quot;react-redux&quot;;
import store from &quot;./store&quot;;

function Router() {
  return (
    &lt;Provider store={store}&gt;
      &lt;BrowserRouter&gt;
        &lt;Route path=&quot;/&quot; exact render={() =&gt; &lt;div&gt;Home Page&lt;/div&gt;} /&gt;
        &lt;Route path=&quot;/premium&quot; exact component={Premium} /&gt;
      &lt;/BrowserRouter&gt;
    &lt;/Provider&gt;
  );
}

export default Router;</code></pre>
<h4 id="7-2-修改-premium-index-js"><a href="#7-2-修改-premium-index-js" class="headerlink" title="7.2 修改 premium/index.js"></a>7.2 修改 premium/index.js</h4><p>Premium 组件，使用 connect 进行连接。</p>
<pre><code class="js">import React from &quot;react&quot;;
import { connect } from &quot;react-redux&quot;;

function Premium(props) {
  const { value } = props;
  return &lt;div&gt;{value}&lt;/div&gt;;
}

const mapStateToProps = state =&gt; ({
  value: state.getIn([&quot;premium&quot;, &quot;value&quot;])
});

const mapDispatchToProps = dispatch =&gt; ({});

export default connect(mapStateToProps, mapDispatchToProps)(Premium);</code></pre>
<h4 id="7-3-connect-mapState-mapDispatch-module"><a href="#7-3-connect-mapState-mapDispatch-module" class="headerlink" title="7.3 connect(mapState,mapDispatch)(module)"></a>7.3 connect(mapState,mapDispatch)(module)</h4><p>mapStateToProps 函数，接收一个 state，即 store 中存储的 state，返回一个对象。该对象即组件的 props。<br>所以可以理解为，mapStateToProps 将 store 中的数据存入 this.props 中。</p>
<p>mapDispatchToProps 函数，接收一个 dispatch，用来派发 action 给 store。由 reducer 接收并处理 action。</p>
<p>module 即需要进行连接的组件。</p>
<h3 id="8-测试-State-与-Action"><a href="#8-测试-State-与-Action" class="headerlink" title="8. 测试 State 与 Action"></a>8. 测试 State 与 Action</h3><p>一个简单的测试，使用一个 input，值为 store 中的 value，当 input 修改时，发送 action 修改 store 中的 value，与此同时更改 input 的 value。</p>
<p>依旧使用 /premium/store/reducer 中的 value 作为测试数据。</p>
<h4 id="8-1-修改-premium-index-js"><a href="#8-1-修改-premium-index-js" class="headerlink" title="8.1 修改 premium/index.js"></a>8.1 修改 premium/index.js</h4><pre><code class="js">import React from &quot;react&quot;;
import { connect } from &quot;react-redux&quot;;

function Premium(props) {
  const { value, changeInputValue } = props;
  return (
    &lt;div&gt;
      &lt;input value={value} onChange={changeInputValue} /&gt;
    &lt;/div&gt;
  );
}

const mapStateToProps = state =&gt; ({
  value: state.getIn([&quot;premium&quot;, &quot;value&quot;])
});

const mapDispatchToProps = dispatch =&gt; ({
  changeInputValue(e) {
    const value = e.target.value;
    const action = {
      type: &quot;CHANGE_INPUT_VALUE&quot;,
      value: value
    };
    dispatch(action);
  }
});

export default connect(mapStateToProps, mapDispatchToProps)(Premium);</code></pre>
<h4 id="8-2-修改-premium-store-reducer-js"><a href="#8-2-修改-premium-store-reducer-js" class="headerlink" title="8.2 修改 premium/store/reducer.js"></a>8.2 修改 premium/store/reducer.js</h4><p>reducer.js 接收 action，并进行处理，修改 store 中存储的 state 属性。</p>
<pre><code class="js">import { fromJS } from &quot;immutable&quot;;

const defaultState = fromJS({
  value: &quot;Hello World!&quot;
});

export default (state = defaultState, action) =&gt; {
  switch (action.type) {
    case &quot;CHANGE_INPUT_VALUE&quot;:
      return state.set(&quot;value&quot;, action.value);
    default:
      return state;
  }
};</code></pre>
<h4 id="8-3-测试"><a href="#8-3-测试" class="headerlink" title="8.3 测试"></a>8.3 测试</h4><p>启动项目，并打开 Redux DevTools 控制台，更改 input 内容，观察 state 中的数据变动。</p>
<p><img src="https://koral-home.oss-cn-beijing.aliyuncs.com/blog/ReduxDevTools.png" alt="Redux DevTools"></p>
<h3 id="9-Redux-Thunk-异步加载数据"><a href="#9-Redux-Thunk-异步加载数据" class="headerlink" title="9. Redux-Thunk 异步加载数据"></a>9. Redux-Thunk 异步加载数据</h3><p>当某一时刻触发的事件，需要从后端接口请求数据渲染页面时。可以通过 Redux-Thunk 使 Action 支持异步函数(原 Action 只是返回一个带 type 属性的对象)。</p>
<blockquote>
<p>需要依赖 redux-thunk</p>
</blockquote>
<h4 id="9-1-添加-Redux-Thunk-中间件"><a href="#9-1-添加-Redux-Thunk-中间件" class="headerlink" title="9.1 添加 Redux-Thunk 中间件"></a>9.1 添加 Redux-Thunk 中间件</h4><p>在 Redux 的 Store 创建时，引入 thunk 中间件，并使用它。</p>
<p>配置方法来源于 <a href="https://github.com/zalmoxisus/redux-devtools-extension#12-advanced-store-setup" target="_blank" rel="noopener">github：redux-devtools-extension</a></p>
<pre><code class="js">import { createStore, applyMiddleware, compose } from &quot;redux&quot;;
import reducer from &quot;./reducer&quot;;
import thunk from &quot;redux-thunk&quot;;

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));

export default store;</code></pre>
<h4 id="9-2-Mock-数据-public-api-list-json"><a href="#9-2-Mock-数据-public-api-list-json" class="headerlink" title="9.2 Mock 数据 /public/api/list.json"></a>9.2 Mock 数据 /public/api/list.json</h4><p>在 src 同级的 public 目录下创建文件 <code>/public/api/list.json</code>：</p>
<p>如果能使用后端语言直接返回也可以</p>
<pre><code class="js">{
    &quot;success&quot;:true,
    &quot;data&quot;: [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;刘六&quot;]
}</code></pre>
<h4 id="9-3-修改-premium-index-js，发送-ajax-请求，获取-list-json"><a href="#9-3-修改-premium-index-js，发送-ajax-请求，获取-list-json" class="headerlink" title="9.3 修改 premium/index.js，发送 ajax 请求，获取 list.json"></a>9.3 修改 premium/index.js，发送 ajax 请求，获取 list.json</h4><blockquote>
<p>需要依赖 axios</p>
</blockquote>
<p>点击 <code>获取数据</code> 的按钮时，触发事件 getList。获取 ajax 请求，并生成一个 action 发送给 store，替换 reducer 中的 list。</p>
<pre><code class="js">import React from &#39;react&#39;;
import { connect } from &#39;react-redux&#39;;
import axios from &#39;axios&#39;;
import { fromJS } from &#39;immutable&#39;;

function Premium(props) {
    const { list, getList } = props;
    return (
            &lt;button onClick={getList}&gt;获取数据&lt;/button&gt;
            &lt;br/&gt;
            {
                list &amp;&amp; list.map((item) =&gt; (&lt;div key={item}&gt;{item}&lt;/div&gt;))
            }
        &lt;/div&gt;
    );
}

const mapStateToProps = (state) =&gt; ({
    list: state.getIn([&#39;premium&#39;,&#39;list&#39;])
});

const mapDispatchToProps = (dispatch) =&gt; ({
    getList() {
        const action = () =&gt; {
            axios.get(&#39;/api/list.json&#39;).then(res =&gt; {
                const list = res.data.data;
                const action2 = {
                    type: &#39;UPDATE_LIST&#39;,
                    // 注意这里：因为store中的数据是Immutable类型的，所以其属性也应该是Immutable类型的
                    list: fromJS(list)
                };
                dispatch(action2);
            }).catch(err =&gt; {
                console.log(err);
            })
        }
        dispatch(action);
    }
});

export default connect(mapStateToProps, mapDispatchToProps)(Premium);</code></pre>
<blockquote>
<p>因为前面配置了 Redux-Thunk 中间件，所以 action 能够直接返回一个函数，并且在 dispatch 时自动执行。</p>
</blockquote>
<h4 id="9-4-premium-store-reducer-支持-UPDATE-LIST-的-Action"><a href="#9-4-premium-store-reducer-支持-UPDATE-LIST-的-Action" class="headerlink" title="9.4 premium/store/reducer 支持 UPDATE_LIST 的 Action"></a>9.4 premium/store/reducer 支持 UPDATE_LIST 的 Action</h4><p>reducer 接收 action，并将值设置到 state 中。</p>
<pre><code class="js">const defaultState = fromJS({
  list: []
});

export default (state = defaultState, action) =&gt; {
  switch (action.type) {
    case &quot;UPDATE_LIST&quot;:
      return state.set(&quot;list&quot;, action.list);
    default:
      return state;
  }
};</code></pre>
<h4 id="9-5-测试-ajax-异步获取数据"><a href="#9-5-测试-ajax-异步获取数据" class="headerlink" title="9.5 测试 ajax 异步获取数据"></a>9.5 测试 ajax 异步获取数据</h4><p>启动项目，点击 button 按钮。页面会显示 list.json 中的数据。</p>
<h3 id="10-优化-Redux-层"><a href="#10-优化-Redux-层" class="headerlink" title="10. 优化 Redux 层"></a>10. 优化 Redux 层</h3><h4 id="10-1-将常量抽离"><a href="#10-1-将常量抽离" class="headerlink" title="10.1 将常量抽离"></a>10.1 将常量抽离</h4><p>将 premium/reducer.js 和 /premium/index.js 中 action.type 属性，抽离为一个单独的文件，在使用时直接调用该常量文件进行获取。方便进行调试和代码报错排查。</p>
<h4 id="10-2-将-Action-的创建抽离"><a href="#10-2-将-Action-的创建抽离" class="headerlink" title="10.2 将 Action 的创建抽离"></a>10.2 将 Action 的创建抽离</h4><p>将 premium/index.js 中所有 action 的创建，抽离到一个 ActionCreator.js 中。</p>
<h4 id="10-3-将抽离之后的文件统一管理"><a href="#10-3-将抽离之后的文件统一管理" class="headerlink" title="10.3 将抽离之后的文件统一管理"></a>10.3 将抽离之后的文件统一管理</h4><p>抽离之后的文件大致分为如下：</p>
<ul>
<li>public<ol>
<li>api<ul>
<li>list.json // 测试 ajax 请求的数据</li>
</ul>
</li>
<li>favicon.ico</li>
<li>index.html</li>
<li>mainifest.json</li>
</ol>
</li>
<li>src<ol>
<li>premium<ol>
<li>store<ul>
<li>actionCreator.js // 管理 Action 的创建</li>
<li>constants.js // 管理常量</li>
<li>reducer.js // 处理 action</li>
<li>index.js // 将上面三个文件导出</li>
</ul>
</li>
<li>index.js // 首页</li>
<li>style.js</li>
</ol>
</li>
<li>store // redux 的存储层、redux-thunk、redux-devtools 的配置<ol>
<li>index.js // 使用当前目录下的 reducer 创建 store</li>
<li>reducer.js // react-redux 引入组件的 store/index.js，并管理子 reducer</li>
</ol>
</li>
<li>index.js // React 项目的入口</li>
<li>index.css</li>
<li>router.js // 路由文件，包含 store 作用域的限制、路由的配置</li>
</ol>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/12/读书笔记/《React》简书慕课/6.ReactRouterDom/">React-Router-Dom</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><h1 id="路由-ReactRouterDom"><a href="#路由-ReactRouterDom" class="headerlink" title="路由 ReactRouterDom"></a>路由 ReactRouterDom</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><blockquote>
<p>yarn add react-router-dom</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/11/读书笔记/《React》简书慕课/5.Immutable/">Immutable</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="拆分-reducer"><a href="#拆分-reducer" class="headerlink" title="拆分 reducer"></a>拆分 reducer</h2><p>当 Reducer 中需要接收的 action 过多，且各个组件都有自己的 action、reducer、constants 时，可以将 reducer.js 分散到各个组件模块中。在总的 reducer 中使用 combineReducers ，将各个子 reducer 连接起来。</p>
<h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="https://koral-home.oss-cn-beijing.aliyuncs.com/blog/Reducer%E6%8B%86%E5%88%86.jpg" alt="拆分Reducer"></p>
<p>common/header - /store<br>/actionCreator.js<br>/constants.js<br>/reducer.js<br>/index.js - /index.js<br>store<br>/index.js<br>/reducer.js</p>
<h2 id="Immutable-将-state-属性私有"><a href="#Immutable-将-state-属性私有" class="headerlink" title="Immutable 将 state 属性私有"></a>Immutable 将 state 属性私有</h2><p>在 Redux 的开发中，要求 store 中的 state，只能由其自己进行修改，因此我们可以使用 Immutable 来对 state 进行封装。将其改为一个不可变对象。</p>
<p>只能通过操作 Immutable 提供的 get、set 方法来修改数据。</p>
<h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><blockquote>
<p>yarn add immutable // 项目中添加 Immutable 依赖</p>
</blockquote>
<h3 id="2-将-state-转换为-Immutable-对象"><a href="#2-将-state-转换为-Immutable-对象" class="headerlink" title="2. 将 state 转换为 Immutable 对象"></a>2. 将 state 转换为 Immutable 对象</h3><p>在使用时，将 state 通过 Immutable 提供的 fromJS 方法进行包装。包装之后的 state 便无法再通过 . 属性的方式获取到值。非常类似 Java 中的封装。</p>
<p>下面是 Header 组件的 reducer.js：</p>
<pre><code class="js">import { fromJS } from &quot;immutable&quot;;

const defaultState = fromJS({
  value: &quot;Hello React !&quot;,
  focused: false
});

export default (state = defaultState, action) =&gt; {
  switch (action.type) {
    case &quot;aaa&quot;:
      return state.set(&quot;value&quot;, action.value);
    case &quot;bbb&quot;:
      return state.set(&quot;focused&quot;, true);
    default:
      return state;
  }
};</code></pre>
<h3 id="3-将子组件的-state-转换为-Immutable-对象"><a href="#3-将子组件的-state-转换为-Immutable-对象" class="headerlink" title="3. 将子组件的 state 转换为 Immutable 对象"></a>3. 将子组件的 state 转换为 Immutable 对象</h3><p>重点是将 combineReducers 方法，改为从 redux-immutalbe 中获取。</p>
<pre><code class="js">import { combineReducers } from &quot;redux-immutable&quot;;
import { reducer as headerReducer } from &quot;../common/header/store&quot;;

const reducers = combineReducers({
  header: headerReducer
});

export default reducers;</code></pre>
<h3 id="4-Header-组件使用-state-header-value"><a href="#4-Header-组件使用-state-header-value" class="headerlink" title="4. Header 组件使用 state.header.value"></a>4. Header 组件使用 state.header.value</h3><p>下面是使用 redux-saga 进行组件与 store 的连接，请查阅 <a href="www.xx.cc">Redux-Saga</a></p>
<pre><code class="js">class Header extends Component {
    // ......
}

const mapStateToProps = (state) =&gt; {
    return {
        value: state.get(&#39;header&#39;).get(&#39;value&#39;),
        focused: state.get(&#39;header&#39;).get(&#39;focused&#39;),
        list: state.get(&#39;header&#39;).get(&#39;list&#39;)
    }
}

const mapDispatchToProps ...

export default connect(mapStateToProps,mapDispatchToProps)(Header);</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/10/读书笔记/《React》简书慕课/4.ReactRedux/">ReactRedux</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><h1 id="React-Redux-入门"><a href="#React-Redux-入门" class="headerlink" title="React-Redux 入门"></a>React-Redux 入门</h1><p>以下内容来源于 <img src="https://react-redux.js.org/introduction/quick-start" alt="React-Redux官网"></p>
<p>使用 React-Redux + Redux-saga 重构 TodoList</p>
<ol>
<li>新增 Redux 依赖</li>
<li>设置 Redux store</li>
<li>添加 React-Redux 依赖</li>
</ol>
<h2 id="一、使用-Provider-标签"><a href="#一、使用-Provider-标签" class="headerlink" title="一、使用 Provider 标签"></a>一、使用 Provider 标签</h2><p>React Redux 提供了 <code>&lt;Provider/&gt;</code> 标签，使 Redux Store 可以用于被包含的程序组件内。</p>
<pre><code class="js">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

import { Provider } from &quot;react-redux&quot;;
import store from &quot;./store&quot;;

import App from &quot;./App&quot;;

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  rootElement
);</code></pre>
<h2 id="二、组件连接-Store"><a href="#二、组件连接-Store" class="headerlink" title="二、组件连接 Store"></a>二、组件连接 Store</h2><p>React Redux 提供了 connect 将组件连接到 store。</p>
<pre><code class="js">import { connect } from &quot;react-redux&quot;;
import { increment, decrement, reset } from &quot;./actionCreators&quot;;

// const Counter = ...

const mapStateToProps = (state /*, ownProps*/index.html) =&gt; {
  return {
    counter: state.counter
  };
};

const mapDispatchToProps = { increment, decrement, reset };

export default connect(mapStateToProps, mapDispatchToProps)(Counter);</code></pre>
<h2 id="三、拆分-Reducer-js"><a href="#三、拆分-Reducer-js" class="headerlink" title="三、拆分 Reducer.js"></a>三、拆分 Reducer.js</h2><p>当 Reducer 中需要接收的 action 过多，且各个组件都有自己的 action、reducer、constants 时，可以将 reducer.js 分散到各个组件模块中。在总的 reducer 中使用 combineReducers ，将各个子 reducer 连接起来。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/09/读书笔记/《React》简书慕课/3.ReduxThunk/">ReduxThunk</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/React慕课/">React慕课</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React慕课/">React慕课</a></span><div class="content"><h1 id="ReduxThunk"><a href="#ReduxThunk" class="headerlink" title="ReduxThunk"></a>ReduxThunk</h1><p>Redux Thunk 可以使 Redux 的 Action 不只是返回对象，也可以是一个函数。该函数在 Component 执行 dispatch(atcion) 时会自动执行。<br>使用原因：使用 Redux Thunk 替换在组件生命周期函数中，使用异步函数的问题。<br>解决因生命周期函数所需执行的内容过多问题。</p>
<h2 id="Redux-Data-Flow"><a href="#Redux-Data-Flow" class="headerlink" title="Redux Data Flow"></a>Redux Data Flow</h2><p>Redux 的数据流程图：</p>
<p><img src="https://koral-home.oss-cn-beijing.aliyuncs.com/blog/ReduxDataFlow.jpg" alt="Redux Data Flow"></p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><blockquote>
<p>yarn add redux-thunk</p>
</blockquote>
<h2 id="Redux-使用-Redux-thunk-中间件"><a href="#Redux-使用-Redux-thunk-中间件" class="headerlink" title="Redux 使用 Redux-thunk 中间件"></a>Redux 使用 Redux-thunk 中间件</h2><p>在创建 Redux 的 Store 时，应用所需使用的中间件。<br><a href="https://github.com/reduxjs/redux-thunk#installation" target="_blank" rel="noopener">来源于 github:redux-thunk</a></p>
<pre><code class="js">import { createStore, applyMiddleware } from &quot;redux&quot;;
import thunk from &quot;redux-thunk&quot;;
import rootReducer from &quot;./reducers/index&quot;;

// Note: this API requires redux@&gt;=3.1.0
const store = createStore(rootReducer, applyMiddleware(thunk));</code></pre>
<p>如果需要使用多个中间件，这里使用 Redux-DevTools 和 Redux-Thunk 两个中间件做演示，请使用下面的方式：<br><a href="https://github.com/zalmoxisus/redux-devtools-extension#12-advanced-store-setup" target="_blank" rel="noopener">来源于 github:redux-devtools-extension</a></p>
<pre><code class="js">import { createStore, applyMiddleware, compose } from &quot;redux&quot;;
import reducer from &quot;./reducer&quot;;
import thunk from &quot;redux-thunk&quot;;

const composeEnhancers =
  typeof window === &quot;object&quot; &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({})
    : compose;

const enhancer = composeEnhancers(
  applyMiddleware(thunk) // 如果有其他中间件，可以在这里引入
);

const store = createStore(reducer, enhancer);

export default store;</code></pre>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>