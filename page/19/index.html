<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>罗凯的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
<meta name="keywords" content="帅">
<meta property="og:type" content="website">
<meta property="og:title" content="罗凯的博客">
<meta property="og:url" content="http://yoursite.com/page/19/index.html">
<meta property="og:site_name" content="罗凯的博客">
<meta property="og:description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="罗凯的博客">
<meta name="twitter:description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
  
    <link rel="alternate" href="/atom.xml" title="罗凯的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.loli.net/2019/07/04/5d1db2fb9593c58427.gif">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">罗凯的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个大帅哥</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架/" class="article-date">
  <time datetime="2019-06-08T16:00:01.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架/">Java并发容器和框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第六章-Java-并发容器和框架"><a href="#第六章-Java-并发容器和框架" class="headerlink" title="第六章 Java 并发容器和框架"></a>第六章 Java 并发容器和框架</h1><h2 id="6-1-ConcurrentHashMap"><a href="#6-1-ConcurrentHashMap" class="headerlink" title="6.1 ConcurrentHashMap"></a>6.1 ConcurrentHashMap</h2><p>ConcurrentHashMap 是线程安全且高效的 HashMap。</p>
<h3 id="6-1-1-为什么使用-ConcurrentHashMap"><a href="#6-1-1-为什么使用-ConcurrentHashMap" class="headerlink" title="6.1.1 为什么使用 ConcurrentHashMap"></a>6.1.1 为什么使用 ConcurrentHashMap</h3><h4 id="1-HashMap-线程不安全"><a href="#1-HashMap-线程不安全" class="headerlink" title="1. HashMap 线程不安全"></a>1. HashMap 线程不安全</h4><p>在多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以在并发情况下不能使用 HashMap。</p>
<p>HashMap 在并发执行 put 操作时会引起死循环，是因为多线程会导致 HashMap 的 Entry 链表形成环形数据结构，一旦形成环形数据结构，Entry 的 next 节点永不为空，就会产生死循环获取 Entry。</p>
<h4 id="2-HashTable-效率低下"><a href="#2-HashTable-效率低下" class="headerlink" title="2. HashTable 效率低下"></a>2. HashTable 效率低下</h4><p>HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 效率低下。</p>
<p>因为当一个线程访问 HashTable 的同步方法，其他线程再访问时，会进入阻塞或轮询状态。</p>
<h4 id="3-ConcurrentHashMap-的锁分段技术"><a href="#3-ConcurrentHashMap-的锁分段技术" class="headerlink" title="3. ConcurrentHashMap 的锁分段技术"></a>3. ConcurrentHashMap 的锁分段技术</h4><p>HashTable 在线程竞争激烈时的效率低下原因是所有访问 HashTable 的线程都必须竞争同一把锁。</p>
<p>而ConcurrentHashMap 的锁分段技术，将容器中的数据分段存储起来，为每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。</p>
<h3 id="6-1-2-ConcurrentHashMap-的结构"><a href="#6-1-2-ConcurrentHashMap-的结构" class="headerlink" title="6.1.2 ConcurrentHashMap 的结构"></a>6.1.2 ConcurrentHashMap 的结构</h3><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p>
<p>Segment 是一种可重入锁(ReentrantLock)，扮演锁的角色。Segment与HashMap 类似，是一种数组和链表结构。</p>
<p>HashEntry 则用于存储键值对数据。每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须先获得对应的 Segment 锁。</p>
<h3 id="6-1-3-ConcurrentHashMap-初始化"><a href="#6-1-3-ConcurrentHashMap-初始化" class="headerlink" title="6.1.3 ConcurrentHashMap 初始化"></a>6.1.3 ConcurrentHashMap 初始化</h3><p>通过 initalCapacity、loadFactor 和 concurrencyLevel 等几个参数来初始化 segment 数组、段偏移量 segmentShift、段掩码 segmentMask 和每个 segment 里的 HashEntry 数组，以此来初始化 ConcurrentHashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment"> * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;), table</span></span><br><span class="line"><span class="comment"> * density (&#123;<span class="doctag">@code</span> loadFactor&#125;), and number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads (&#123;<span class="doctag">@code</span> concurrencyLevel&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment"> * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment"> * given the specified load factor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment"> * establishing the initial table size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads. The implementation may use this value as</span></span><br><span class="line"><span class="comment"> * a sizing hint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment"> * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment"> * nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-初始化-Segments-数组"><a href="#1-初始化-Segments-数组" class="headerlink" title="1. 初始化 Segments 数组"></a>1. 初始化 Segments 数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTs)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ssize &lt; concurrencyLevel)&#123; <span class="comment">// 必须保证 segments 数组长度是 2的N次方，如 concurrencyLevel = 14，ssize = 16</span></span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<p>Segments 数组的程度是由 ssize 决定的，而ssize 是通过 concurrencyLevel 计算得出的 ，原因是必须保证 ssize 是 2的N次方。</p>
<h4 id="2-初始化-SegmentShift-和-SegmentMask"><a href="#2-初始化-SegmentShift-和-SegmentMask" class="headerlink" title="2. 初始化 SegmentShift 和 SegmentMask"></a>2. 初始化 SegmentShift 和 SegmentMask</h4><p>段偏移量 SegmentShift：segmentShift = 32 - sshift;</p>
<p>段掩码：segmentMask = ssize - 1; 是散列运算的掩码，等于 ssize - 1，因为 ssize 为2的N次方，因此 segmentMask 掩码的二进制各个位都是 1.</p>
<h4 id="3-初始化每个-segment"><a href="#3-初始化每个-segment" class="headerlink" title="3. 初始化每个 segment"></a>3. 初始化每个 segment</h4><p>initialCapacity 是 ConcurrentHashMap 的初始化容量，loadFactor 是每个 segment 的负载因子。</p>
<h4 id="4-定位-Segment"><a href="#4-定位-Segment" class="headerlink" title="4. 定位 Segment"></a>4. 定位 Segment</h4><p>ConcurrentHashMap 在插入和获取元素时，会通过散列算法定位 Segment，并会对元素的 hashCode 进行一次再散列。</p>
<p>在散列的目的是减少散列冲突，使元素能均匀地分布在不同的 Segment 上，从而提高容器的存取效率。</p>
<p>如果不进行再散列的话，无论散列值的高位是多少，只要低位相同，都会被存储到一个Segment 上。</p>
<h3 id="6-1-5-ConcurrentHashMap-操作"><a href="#6-1-5-ConcurrentHashMap-操作" class="headerlink" title="6.1.5 ConcurrentHashMap 操作"></a>6.1.5 ConcurrentHashMap 操作</h3><h4 id="1-get操作"><a href="#1-get操作" class="headerlink" title="1. get操作"></a>1. get操作</h4><p>先进行再散列，然后使用散列值进行散列运算，定位 Segment，再通过散列算法定位到元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hash);</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key,hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 get 操作不需要加锁，除非读到的值是空才会加锁重读。原因是 ConcurrentHashMap 将需要共享的变量都定义为 volatile 类型。</p>
<h4 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2. put操作"></a>2. put操作</h4><p>put操作会对共享变量进行写操作，所以必须加锁。</p>
<p>put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。在插入之前，先判断是否需要对 Segment 里的 HashEntry 进行扩容，然后定位添加元素的位置，将其放入 HashEntry 数组中。</p>
<h4 id="3-size-操作"><a href="#3-size-操作" class="headerlink" title="3. size 操作"></a>3. size 操作</h4><p>统计 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。 Segment 里的count 是一个 volatile 变量，但是多线程场景下，某个 segment 的 count 发生改变后，也可能会使结果不准确。</p>
<p>因此 size 操作的具体过程为：先尝试 2 次通过不锁住 Segment 的方式来统计各个 Segment 大小，如果统计过程中，容器的 count 发生了变化（容器 count 会在 put、remove、clean 时会使 modCount + 1），再采用加锁的方式（将所有 Segment 的 put、remove、clean 方法全部锁住）来统计 Segment 的大小。</p>
<h2 id="6-2-ConcurrentLinkedQueue"><a href="#6-2-ConcurrentLinkedQueue" class="headerlink" title="6.2 ConcurrentLinkedQueue"></a>6.2 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用 FIFO 的规则对节点进行排序。</p>
<h3 id="6-2-1-ConcurrentLinkedQueue-结构"><a href="#6-2-1-ConcurrentLinkedQueue-结构" class="headerlink" title="6.2.1 ConcurrentLinkedQueue 结构"></a>6.2.1 ConcurrentLinkedQueue 结构</h3><p>ConcurrentLinkedQueue 由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个 next 关联，组成一张链表结果的队列。</p>
<h3 id="6-2-2-入队列"><a href="#6-2-2-入队列" class="headerlink" title="6.2.2 入队列"></a>6.2.2 入队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 插入元素到当前队列的尾部，且因为队列是无界的，结果总是true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="comment">// 1. 将插入元素构建为 node</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">           Node&lt;E&gt; q = p.next;</span><br><span class="line">           <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (p != t)</span><br><span class="line">                       casTail(t, newNode);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">               p = (t != (t = tail)) ? t : head;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-入队列"><a href="#1-入队列" class="headerlink" title="1. 入队列"></a>1. 入队列</h4><p>入队列就是将入队节点添加到队列的尾部。在入队时，先将入队节点设置成当前队列尾节点的下一个节点，然后更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置为 tail 的 next 节点。</p>
<p>在设置入队节点为 tail 的 next 节点时，会使用  CAS 来保证多线程下的安全性。</p>
<h4 id="2-定位尾节点"><a href="#2-定位尾节点" class="headerlink" title="2. 定位尾节点"></a>2. 定位尾节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the successor of p, or the head node if p.next has been</span></span><br><span class="line"><span class="comment"> * linked to self, which will only be true if traversing with a</span></span><br><span class="line"><span class="comment"> * stale pointer that is now off the list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-设置入队节点为尾节点"><a href="#3-设置入队节点为尾节点" class="headerlink" title="3. 设置入队节点为尾节点"></a>3. 设置入队节点为尾节点</h4><p>p.casNext(null,n) 将入队节点设置为当前队列尾节点的 next 节点，如果 p 为null，表示 p 是当前队列的尾节点，不为空则表示其他线程更新了尾节点，需要重新获取当前队列的尾节点。</p>
<h3 id="6-2-3-出队列"><a href="#6-2-3-出队列" class="headerlink" title="6.2.3 出队列"></a>6.2.3 出队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1. 获取头节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 头节点不为空，则用 CAS 将头节点的引用置null；为空则表示头节点被另一线程的出队操作取出</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 3. CAS 操作成功，直接返回头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 如果取出失败，则继续进行循环取值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-阻塞队列"><a href="#6-3-阻塞队列" class="headerlink" title="6.3 阻塞队列"></a>6.3 阻塞队列</h2><h3 id="6-3-1-什么是阻塞队列"><a href="#6-3-1-什么是阻塞队列" class="headerlink" title="6.3.1 什么是阻塞队列"></a>6.3.1 什么是阻塞队列</h3><p>阻塞队列是一个支持阻塞插入和阻塞移除的方法。</p>
<p>插入和移除操作的4中处理方式：</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove(e)</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<h3 id="6-3-2-Java-阻塞队列"><a href="#6-3-2-Java-阻塞队列" class="headerlink" title="6.3.2 Java 阻塞队列"></a>6.3.2 Java 阻塞队列</h3><p>JDK 中提供了 7个阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列<ul>
<li>队列按照FOFO原则对元素进行排序</li>
<li>默认不保证线程访问队列时的公平性</li>
</ul>
</li>
<li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列<ul>
<li>FIFO原则对元素进行排序</li>
<li>队列默认和最大长度为 Integer.MAX_VALUE</li>
</ul>
</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列<ul>
<li>支持优先级、无界阻塞</li>
<li>元素采用自然顺序升序排列，也可以自定义 compareTo 来排序</li>
<li>不能保证同优先级元素的顺序</li>
</ul>
</li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列<ul>
<li>支持延迟获取元素</li>
<li>队列元素必须实现 Delayed 接口</li>
<li>队列使用 PriorityQueue 实现</li>
<li>创建元素时可指定多久后才能获取当前元素</li>
<li>DelayQueue常用于：<ul>
<li>缓存系统的设计：用 DelayQueue 保存缓存元素的有效期</li>
<li>定时任务调度：使用 DelayQueue 保存执行的任务和执行时间</li>
</ul>
</li>
</ul>
</li>
<li>SynchronousQueue：不存储元素的阻塞队列<ul>
<li>不存储元素，每个put操作必须等待一个 take 操作</li>
<li>支持公平访问队列，默认是非公平的</li>
<li>队列本身不存储任何元素，适合传递性场景</li>
<li>吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue</li>
</ul>
</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列<ul>
<li>提供 transfer 方法，立即将元素 transfer 给消费者，如果无消费者等待则将元素放在队列的 tail 节点，等待消费者消费</li>
<li>提供 tryTransfer 方法，试探生产者传入的元素能够直接传给消费者，如果无消费者等待接收，则返回false。</li>
</ul>
</li>
<li>LinkedBlockingQueue：由链表结构组成的双向阻塞队列<ul>
<li>双向队列，使多线程同时入队时，减少了一般竞争，因为多了一个入队口</li>
<li>增加了 addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast等方法</li>
<li>add 等同于 addLast，remove 等同于 removeFirst</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架/" data-id="cjxpj03d600dargtwnkvu4qwu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《Java并发编程的艺术》/5.Java中的锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/08/读书笔记/《Java并发编程的艺术》/5.Java中的锁/" class="article-date">
  <time datetime="2019-06-07T16:00:01.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/读书笔记/《Java并发编程的艺术》/5.Java中的锁/">Java中的锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第五章-Java中的锁"><a href="#第五章-Java中的锁" class="headerlink" title="第五章 Java中的锁"></a>第五章 Java中的锁</h1><p>锁的作用：用来控制多个线程访问共享资源的方式。一个锁能够防止多个线程同时访问共享资源(但有些锁可以允许多个线程并发的访问共享资源，比如读写锁)。</p>
<h2 id="5-1-Lock-接口"><a href="#5-1-Lock-接口" class="headerlink" title="5.1 Lock 接口"></a>5.1 Lock 接口</h2><p>Lock 接口提供了与 synchronized 关键字类似的同步功能，只是在使用时需要显示地获取和释放锁。虽然 Lock 接口缺少了 synchronized 方法隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。</p>
<p>Lock 接口的 API:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断的获取锁</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试非阻塞的获取锁</td>
</tr>
<tr>
<td>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>
<td>超时获取锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>获取等待通知组件</td>
</tr>
</tbody>
</table>
<h2 id="5-2-队列同步器"><a href="#5-2-队列同步器" class="headerlink" title="5.2 队列同步器"></a>5.2 队列同步器</h2><p>队列同步器(AbstractQueuedSynchronizer)，是用来构建锁或者其他同步组件的基础框架，通过内置 FIFO 队列来完成资源获取线程的排队工作。</p>
<p>同步器是实现锁的关键：  –  锁面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节； –  同步器面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</p>
<h3 id="5-2-1-同步器接口"><a href="#5-2-1-同步器接口" class="headerlink" title="5.2.1 同步器接口"></a>5.2.1 同步器接口</h3><p>队列同步器提供了三个抽象方法供实现类实现：</p>
<ol>
<li>getState()：获取当前同步状态</li>
<li>setState(int newState)：设置当前同步状态</li>
<li>compareAndSetState(int expect,int update)：使用CAS设置当前状态</li>
</ol>
<p>同时，同步器提供了多个可重写的方法：</p>
<ol>
<li>tryAcquire(int arg)：独占式获取同步状态</li>
<li>tryRelease(int arg)：独占式释放同步状态</li>
<li>tryAcquireShared(int arg)：共享式获取同步状态</li>
<li>tryReleaseShared(int arg)：共享式释放同步状态</li>
<li>isHeldExclusively()：当前同步器是否被线程独占</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Mutex 时并不会直接与内部同步器的实现打交道，而是调用 Mutex 提供的方法.</span></span><br><span class="line"><span class="comment"> * 如 获取锁的lock() 方法，只需要在方法实现中调用同步器的 acquire(int arg) 即可。</span></span><br><span class="line"><span class="comment"> * 当前线程后去同步状态失败后，会被加入到同步队列中等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0时获取锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过CAS设置state</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个 Condition ，每个Condition 都包含了一个 condition 队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-队列同步器的实现分析"><a href="#5-2-2-队列同步器的实现分析" class="headerlink" title="5.2.2 队列同步器的实现分析"></a>5.2.2 队列同步器的实现分析</h3><h4 id="1-同步队列"><a href="#1-同步队列" class="headerlink" title="1. 同步队列"></a>1. 同步队列</h4><p>同步器内部使用一个同步队列(FIFO)来完成同步状态的管理，当线程获取同步状态失败后，会将当前线程及其等待状态等信息构造成为一个节点（Node）并加入同步队列，同时阻塞当前线程。</p>
<p>当同步状态释放时，会将首节点唤醒，再次尝试获取同步状态。</p>
<p>节点（Node）的属性类型与名称描述</p>
<table>
<thead>
<tr>
<th>属性类型与名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int waitStatus</td>
<td>等待状态</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>等待队列中的后继节点</td>
</tr>
<tr>
<td>Thread</td>
<td>获取同步状态的线程</td>
</tr>
</tbody>
</table>
<p>类似于双向链表</p>
<h4 id="2-独占式同步状态获取与释放"><a href="#2-独占式同步状态获取与释放" class="headerlink" title="2. 独占式同步状态获取与释放"></a>2. 独占式同步状态获取与释放</h4><p>调用同步器的 acquire(int arg) 方法，可以获取同步状态，JDK 中acquire的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要逻辑为：1. tryAcquire 尝试获取同步状态，如果失败的话则构造同步节点，并通过addWirter方法将该节点加入到同步队列的尾部；2. 调用 acquireQueued 方法，使该节点以死循环的方式获取同步状态，如果获取不到则阻塞节点中的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1653183/m5il5f5c34.png?imageView2/2/w/1620" alt="独占式同步状态获取流程"></p>
<h4 id="3-共享式同步状态获取与释放"><a href="#3-共享式同步状态获取与释放" class="headerlink" title="3. 共享式同步状态获取与释放"></a>3. 共享式同步状态获取与释放</h4><p>共享式与独占式最主要的区别在于，同一时刻能否有多个线程同时获取到同步状态。</p>
<p>主要方法有：acquireShared(int arg)、tryAcquireShared(int arg)、releaseShared(int arg)</p>
<h4 id="4-独占式超时获取同步状态"><a href="#4-独占式超时获取同步状态" class="headerlink" title="4. 独占式超时获取同步状态"></a>4. 独占式超时获取同步状态</h4><p>同步器的 doAcquireNanos(int arg, long nanosTimeout) 方法可以超时获取同步状态，即在指定的时间段内获取同步状态，成功返回true。</p>
<p><img src="https://img-blog.csdn.net/20180830162607150?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjY3ODE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="独占式超时获取同步状态流程"></p>
<h2 id="5-3-重入锁-ReentrantLock"><a href="#5-3-重入锁-ReentrantLock" class="headerlink" title="5.3 重入锁 ReentrantLock"></a>5.3 重入锁 ReentrantLock</h2><p>重入锁，表示该锁能够支持一个线程对资源的重复加锁。即 ReentrantLock 在调用 lock() 方法时已经获取到锁的线程，再次调用 lock() 方法依旧能够获取锁而不被阻塞。</p>
<p>此外，重入锁还支持获取锁时的公平性与非公平性选择。</p>
<blockquote>
<p>synchronized 关键字隐式的支持重入</p>
<h3 id="1-实现重进入"><a href="#1-实现重进入" class="headerlink" title="1. 实现重进入"></a>1. 实现重进入</h3><p>重进入，指任意线程在获取锁之后能够再次获取该锁而不被阻塞，实现该特性需要解决两个问题：</p>
<ol>
<li>线程再次获取锁：即锁需要识别获取的锁是否为当前占据锁的线程。</li>
<li>锁的最终释放：通过计数自增的方式表示线程重复n次加锁，锁释放也是同理。</li>
</ol>
</blockquote>
<h3 id="2-公平与非公平获取锁的区别"><a href="#2-公平与非公平获取锁的区别" class="headerlink" title="2. 公平与非公平获取锁的区别"></a>2. 公平与非公平获取锁的区别</h3><p>如果一个锁是公平的，那么锁的获取顺序就应该符合FIFO原则。</p>
<p>一般情况下，非公平锁的效率是要高于公平锁的。但是非公平锁可能使线程“饥饿”，即先来的线程因优先级低一直处于等待状态。</p>
<h2 id="5-4-读写锁"><a href="#5-4-读写锁" class="headerlink" title="5.4 读写锁"></a>5.4 读写锁</h2><p>上面的锁基本都是排他锁，在同一时刻只允许一个线程进行访问。而读写锁能在同一时刻允许多个<strong>读线程</strong>访问，但在<strong>写线程</strong>访问时，所有<strong>读、写线程均被阻塞</strong>。</p>
<h3 id="5-4-1-ReentrantReadWriteLock-的特性与API"><a href="#5-4-1-ReentrantReadWriteLock-的特性与API" class="headerlink" title="5.4.1 ReentrantReadWriteLock 的特性与API"></a>5.4.1 ReentrantReadWriteLock 的特性与API</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平性选择</td>
<td>支持公平与非公平的锁获取方式</td>
</tr>
<tr>
<td>重进入</td>
<td>支持重进入，即写锁能支持一个线程多次获取，读锁也是</td>
</tr>
<tr>
<td>锁降级</td>
<td>写锁能够降级为读锁</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int getReadLockCount()</td>
<td>返回当前读锁被获取的次数</td>
</tr>
<tr>
<td>int getReadHoldCount()</td>
<td>返回当前线程获取读锁的次数</td>
</tr>
<tr>
<td>boolean isWriteLocked()</td>
<td>判断写锁是否被获取</td>
</tr>
<tr>
<td>int getWriteHoldCount()</td>
<td>返回当前写锁被获取的次数</td>
</tr>
</tbody>
</table>
<h3 id="5-4-2-读写锁的实现分析"><a href="#5-4-2-读写锁的实现分析" class="headerlink" title="5.4.2 读写锁的实现分析"></a>5.4.2 读写锁的实现分析</h3><h4 id="1-读写状态的设计"><a href="#1-读写状态的设计" class="headerlink" title="1. 读写状态的设计"></a>1. 读写状态的设计</h4><p>读写锁同样依赖于自定义同步器来实现同步功能，但是读写锁的同步器需要维护<strong>多个读线程和一个写线程</strong>。</p>
<h4 id="2-写锁的获取与释放"><a href="#2-写锁的获取与释放" class="headerlink" title="2. 写锁的获取与释放"></a>2. 写锁的获取与释放</h4><p>写锁是一个支持重入的排他锁，只能被一个线程获取及重入。</p>
<p>如果当前线程在获取写锁时，读锁已经被获取(state!=0)或者该线程不是获取写锁的线程，则进入等待状态。</p>
<p>写锁的释放与 ReentrantLock 类似，都是维护一个 <strong>写状态属性</strong>，为0时表示写锁被释放，同时写锁的修改对其后的读锁可见。</p>
<h4 id="3-读锁的获取与释放"><a href="#3-读锁的获取与释放" class="headerlink" title="3. 读锁的获取与释放"></a>3. 读锁的获取与释放</h4><p>读锁是一个支持重入的共享锁，能被多个线程同时获取。</p>
<p>如果当前没有其他写线程，则读锁总会被成功获取。</p>
<p>读锁的每次释放均减少读状态。</p>
<h4 id="4-锁降级"><a href="#4-锁降级" class="headerlink" title="4. 锁降级"></a>4. 锁降级</h4><p><strong>写锁降级为读锁</strong>，指当前拥有写锁的线程，再获取读锁，随后释放之前拥有的写锁的过程。</p>
<blockquote>
<p>ReentrantReadWriteLock 不支持锁升级。</p>
</blockquote>
<h2 id="5-5-LockSupport-工具"><a href="#5-5-LockSupport-工具" class="headerlink" title="5.5 LockSupport 工具"></a>5.5 LockSupport 工具</h2><p>当需要阻塞或唤醒一个线程的时候，会使用 LockSupport 工具类来完成相应的工作。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void park()</td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td>void parkNanos(long nanos)</td>
<td>阻塞当前线程nanos纳秒</td>
</tr>
<tr>
<td>void parkUntil(long deadline)</td>
<td>阻塞当前线程知道deadline</td>
</tr>
<tr>
<td>void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程</td>
</tr>
</tbody>
</table>
<h2 id="5-6-Condition-接口"><a href="#5-6-Condition-接口" class="headerlink" title="5.6 Condition 接口"></a>5.6 Condition 接口</h2><p>Object 对象拥有一组监视器方法，包含：wait()、wait(long timeout)、notify()及notifyAll() ，这些方法与 synchronized 关键字配合，实现 等待/通知模式。</p>
<p>Condition 也提供了类似的方法，与Lock 配合实现 等待/通知 模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/08/读书笔记/《Java并发编程的艺术》/5.Java中的锁/" data-id="cjxpj03d400d8rgtwogazlfia" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《Java并发编程的艺术》/4.Java并发编程基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/07/读书笔记/《Java并发编程的艺术》/4.Java并发编程基础/" class="article-date">
  <time datetime="2019-06-06T16:00:01.000Z" itemprop="datePublished">2019-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/07/读书笔记/《Java并发编程的艺术》/4.Java并发编程基础/">Java 并发编程基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四章-Java-并发编程基础"><a href="#第四章-Java-并发编程基础" class="headerlink" title="第四章 Java 并发编程基础"></a>第四章 Java 并发编程基础</h1><h2 id="4-1-线程"><a href="#4-1-线程" class="headerlink" title="4.1 线程"></a>4.1 线程</h2><h3 id="4-1-1-什么是线程"><a href="#4-1-1-什么是线程" class="headerlink" title="4.1.1 什么是线程"></a>4.1.1 什么是线程</h3><p>操作系统在运行一个程序时，会创建一个进程，如一个Java程序就对应一个 Java 进程。</p>
<p>一个进程可以创建多个线程，每个线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程间高速切换，让使用者感觉是在同时运行。</p>
<h3 id="4-1-2-多线程"><a href="#4-1-2-多线程" class="headerlink" title="4.1.2 多线程"></a>4.1.2 多线程</h3><p>使用多线程的优势如下：</p>
<ol>
<li>更好的利用多处理器核心</li>
<li>程序运行更快，以获得更快的响应时间</li>
<li>更好的编程模型</li>
</ol>
<h3 id="4-1-3-线程优先级"><a href="#4-1-3-线程优先级" class="headerlink" title="4.1.3 线程优先级"></a>4.1.3 线程优先级</h3><p>线程优先级决定了线程能够使用处理器的资源多少，默认优先级为5，优先级范围为 1~10.</p>
<p>针对频繁阻塞的(休眠或者 IO操作)线程需要设置较高优先级，而偏重计算(需要较多CPU时间或者偏运算)的线程则设置较低的优先级，确保处理器不会被独占。</p>
<h3 id="4-1-4-线程的状态"><a href="#4-1-4-线程的状态" class="headerlink" title="4.1.4 线程的状态"></a>4.1.4 线程的状态</h3><p>Java 线程的六种生命周期：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还未调用 start() 方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，即操作系统中的就绪和运行两种状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，表示可以在指定时间自动返回的等待状态</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示线程已执行完毕</td>
</tr>
</tbody>
</table>
<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="Java线程状态变迁"></p>
<h3 id="4-1-5-Daemon-线程"><a href="#4-1-5-Daemon-线程" class="headerlink" title="4.1.5 Daemon 线程"></a>4.1.5 Daemon 线程</h3><p>当Java 虚拟机中不存在 Daemon 线程时，虚拟机将会退出。</p>
<p>通过 Thread.setDaemon(true) 将线程设置为 Daemon 线程。</p>
<h2 id="4-2-启动、终止线程"><a href="#4-2-启动、终止线程" class="headerlink" title="4.2 启动、终止线程"></a>4.2 启动、终止线程</h2><p>通过调用线程的 start() 方法启动，随着 run() 方法的执行完毕，线程随之终止。</p>
<h3 id="4-2-1-中断"><a href="#4-2-1-中断" class="headerlink" title="4.2.1 中断"></a>4.2.1 中断</h3><p>中断表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<h3 id="4-2-2-安全地终止线程"><a href="#4-2-2-安全地终止线程" class="headerlink" title="4.2.2 安全地终止线程"></a>4.2.2 安全地终止线程</h3><p>通过标识位或者中断操作的方式，能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p>
<p>通过标识位和中断来停止线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        on = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-线程间通信"><a href="#4-3-线程间通信" class="headerlink" title="4.3 线程间通信"></a>4.3 线程间通信</h2><p>Java 支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝，所以程序在执行过程中，各线程看到的变量并不一定是最新的。</p>
<h3 id="4-3-1-volatile-和-synchronized-关键字"><a href="#4-3-1-volatile-和-synchronized-关键字" class="headerlink" title="4.3.1 volatile 和 synchronized 关键字"></a>4.3.1 volatile 和 synchronized 关键字</h3><p>volatile 关键字：用来修饰的变量，可以使访问该变量的线程均从共享内存中获取。且对共享变量的修改，必须同步刷新回共享内存中。但是过多地使用volatile 会降低程序执行的效率。</p>
<p>synchronized 关键字：用来修饰方法或者同步块，确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p>
<h3 id="4-3-2-等待-通知机制"><a href="#4-3-2-等待-通知机制" class="headerlink" title="4.3.2 等待/通知机制"></a>4.3.2 等待/通知机制</h3><p>等待/ 通知机制，是指一个线程A 调用了对象O 的wait() 方法而进入等待状态。线程B 调用了对象O 的notify()或notifyAll() 方法，线程A 收到通知后从对象O的wait() 方法返回，进而执行后续操作。</p>
<p>等待通知的经典范式：</p>
<p>等待方(消费方):</p>
<ol>
<li>获取对象的锁</li>
<li>如果条件不满足，则调用对象的wait()方法，被通知后仍要检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知方(生产者)：</p>
<ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-Thread-join"><a href="#4-3-3-Thread-join" class="headerlink" title="4.3.3 Thread.join()"></a>4.3.3 Thread.join()</h3><p>如果一个线程 A 执行了 thread.join() 语句，其含义是：当前线程 A 等待 thread 线程终止之后才从 thread.join() 返回。</p>
<h2 id="4-4-线程应用实例"><a href="#4-4-线程应用实例" class="headerlink" title="4.4 线程应用实例"></a>4.4 线程应用实例</h2><h3 id="4-4-1-等待超时模式"><a href="#4-4-1-等待超时模式" class="headerlink" title="4.4.1 等待超时模式"></a>4.4.1 等待超时模式</h3><p>调用一个方法后，如果在等待时间内得到结果则立即返回，否则返回默认结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMills() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-简单的数据库连接池"><a href="#4-4-2-简单的数据库连接池" class="headerlink" title="4.4.2 简单的数据库连接池"></a>4.4.2 简单的数据库连接池</h3><h3 id="4-4-3-基于数据库连接池的Web服务器"><a href="#4-4-3-基于数据库连接池的Web服务器" class="headerlink" title="4.4.3 基于数据库连接池的Web服务器"></a>4.4.3 基于数据库连接池的Web服务器</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/07/读书笔记/《Java并发编程的艺术》/4.Java并发编程基础/" data-id="cjxpj03ad00aqrgtwmmj5twik" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《Java并发编程的艺术》/3.Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/05/读书笔记/《Java并发编程的艺术》/3.Java内存模型/" class="article-date">
  <time datetime="2019-06-04T16:00:01.000Z" itemprop="datePublished">2019-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/05/读书笔记/《Java并发编程的艺术》/3.Java内存模型/">Java 内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-Java-内存模型"><a href="#第三章-Java-内存模型" class="headerlink" title="第三章 Java 内存模型"></a>第三章 Java 内存模型</h1><p>主要包含4个部分：</p>
<ol>
<li>Java 内存模型的基础</li>
<li>Java 内存模型中的顺序一致性，即重排序和顺序一致性内存模型</li>
<li>同步原语，3个同步原语的内存语义和重排序规则在处理器中的实现</li>
<li>Java 内存模型的设计</li>
</ol>
<h2 id="3-1-Java-内存模型的基础"><a href="#3-1-Java-内存模型的基础" class="headerlink" title="3.1 Java 内存模型的基础"></a>3.1 Java 内存模型的基础</h2><h3 id="3-1-1-并发编程模型的两个关键问题"><a href="#3-1-1-并发编程模型的两个关键问题" class="headerlink" title="3.1.1 并发编程模型的两个关键问题"></a>3.1.1 并发编程模型的两个关键问题</h3><p>在并发编程中，需要处理两个关键问题：1. 线程之间如何通信；2.线程之间如何同步。</p>
<p><strong>通信</strong>，是指线程间以何种机制交换信息，如 <code>共享内存</code> 和<code>消息传递</code>。</p>
<p>共享内存：在此模型中，线程之间共享程序的公共状态，通过写 - 读内存中的公共状态进行隐式通信。</p>
<p>消息传递：在此模型中，线程间没有公共状态，只能通过发送消息来显式进行通信。</p>
<p><strong>同步</strong>，指程序中用于控制不同线程间操作发生相对顺序的机制。</p>
<p>共享内存：在此模型中，同步是显式进行的，程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>
<p>消息传递：在此模型中，由于消息发送必须在消息接收之前，因此同步是隐式的。</p>
<h3 id="3-1-2-Java-内存模型的抽象结构"><a href="#3-1-2-Java-内存模型的抽象结构" class="headerlink" title="3.1.2 Java 内存模型的抽象结构"></a>3.1.2 Java 内存模型的抽象结构</h3><p>在 Java 中，所有实例域、静态域、数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数、异常处理参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型(JMM) 控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(抽象概念)，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>本地内存涵盖了缓存、写缓冲区、寄存器以及其他硬件和编译器优化。</p>
<p><img src="https://pic3.zhimg.com/80/v2-af520d543f0f4f205f822ec3b151ad46_hd.jpg" alt="Java 内存模型的抽象结构示意图"></p>
<p>线程A与B之间通信，需要经历如下两个步骤：</p>
<ol>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中</li>
<li>线程B到主内存中读取线程A之前已更新过的共享变量</li>
</ol>
<p>总体来看，这两步的实质是线程A向线程B通信，且这个通信过程必须要经过主内存。</p>
<h3 id="3-1-3-指令重排序"><a href="#3-1-3-指令重排序" class="headerlink" title="3.1.3 指令重排序"></a>3.1.3 指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p>
<p>指令重排的顺序：源代码 –&gt;  1.编译器优化重排序 –&gt; 2. 指令集并行重排序 –&gt; 3. 内存系统重排序  –&gt; 最终执行的指令序列</p>
<p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<h3 id="3-1-4-Happens-Before"><a href="#3-1-4-Happens-Before" class="headerlink" title="3.1.4 Happens-Before"></a>3.1.4 Happens-Before</h3><p>happens-before 用来阐述操作之间的内存可见性，在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这两个操作可以在不同的线程中。</p>
<h2 id="3-2-重排序"><a href="#3-2-重排序" class="headerlink" title="3.2 重排序"></a>3.2 重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="3-2-1-数据依赖性"><a href="#3-2-1-数据依赖性" class="headerlink" title="3.2.1 数据依赖性"></a>3.2.1 数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
<p>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖性关系的两个操作的执行顺序。</p>
<h3 id="3-2-2-as-if-serial"><a href="#3-2-2-as-if-serial" class="headerlink" title="3.2.2 as-if-serial"></a>3.2.2 as-if-serial</h3><p>as-if-serial：不管怎么重排序（提高并行度），程序的执行结果不能改变。</p>
<h3 id="3-2-3-结论"><a href="#3-2-3-结论" class="headerlink" title="3.2.3 结论"></a>3.2.3 结论</h3><p>在不改变程序结果的前提下，尽可能提高并行度。</p>
<h2 id="3-3-顺序一致性"><a href="#3-3-顺序一致性" class="headerlink" title="3.3 顺序一致性"></a>3.3 顺序一致性</h2><p>顺序一致性内存模型是一个理论参考模型，在设计时，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。</p>
<p>顺序一致性：即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p>
<h3 id="3-3-1-顺序一致性内存模型"><a href="#3-3-1-顺序一致性内存模型" class="headerlink" title="3.3.1 顺序一致性内存模型"></a>3.3.1 顺序一致性内存模型</h3><p>顺序一致性内存模型具有两大特性：</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<h2 id="3-4-volatile-的内存语义"><a href="#3-4-volatile-的内存语义" class="headerlink" title="3.4 volatile 的内存语义"></a>3.4 volatile 的内存语义</h2><p>当声明共享变量为 volatile 后，可以看成是使用同一个锁对这些单个读写操作做了同步。</p>
<p>volatile 具有以下特性：</p>
<ol>
<li>可见性。对一个volatile 变量的读，总是能看到对这个volatile 变量最后的写入。</li>
<li>原子性。对任意单个 volatile 变量的读写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ol>
<h3 id="3-4-1-volatile-的读写"><a href="#3-4-1-volatile-的读写" class="headerlink" title="3.4.1 volatile 的读写"></a>3.4.1 volatile 的读写</h3><blockquote>
<p>写：当写一个 volatile 变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存中。</p>
<blockquote>
<p>读：当读一个 volatile 变量时，JMM  会把该线程对应的本地内存置为无效，线程从主内存中读取共享变量。</p>
<h3 id="3-4-2-volatile-内存语义"><a href="#3-4-2-volatile-内存语义" class="headerlink" title="3.4.2 volatile 内存语义"></a>3.4.2 volatile 内存语义</h3><p>基于保守策略的 JMM 内存屏障插入策略：</p>
<ol>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障<ol>
<li><code>StoreStore</code> 屏障，将保障上面所有的普通写，在volatile 写之前刷新到主内存</li>
</ol>
</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障<ol>
<li><code>StoreLoad</code> 屏障，避免volatile写与后面可能有的 volatile 读写操作重排序</li>
</ol>
</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障<ol>
<li><code>LoadLoad</code> 屏障，用来禁止处理器把上面的 volatile 读与下面的普通读重排序</li>
</ol>
</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障<ol>
<li><code>LoadStore</code> 屏障，用来禁止处理器把上面的 volatile 读与下面的普通写重排序</li>
</ol>
</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>volatile 仅能保证对单个 volatile 变量的读写具有原子性，而锁的互斥执行能确保整个临界区代码的执行具有原子性。在功能上，锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。</p>
</blockquote>
<h2 id="3-5-锁的内存语义"><a href="#3-5-锁的内存语义" class="headerlink" title="3.5 锁的内存语义"></a>3.5 锁的内存语义</h2><p>锁是 Java 并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<h3 id="3-5-1-锁的获取与释放"><a href="#3-5-1-锁的获取与释放" class="headerlink" title="3.5.1 锁的获取与释放"></a>3.5.1 锁的获取与释放</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据程序次序规则，1 happens-before 2, 2 happens-before 3 ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;  <span class="comment">// 1</span></span><br><span class="line">        a++;							<span class="comment">// 2</span></span><br><span class="line">    &#125;									<span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据监视器锁规则，3 happens-before 4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;	<span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a;						<span class="comment">// 5  根据happens-before 的传递性，2 happens-before 5</span></span><br><span class="line">    &#125;									<span class="comment">// 6</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MonitorExample me = <span class="keyword">new</span> MonitorExample();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; &#123;</span><br><span class="line">            me.writer();</span><br><span class="line">        &#125;).run(); <span class="comment">// 当线程释放锁时，JMM 会把线程对应的本地内存中的共享变量刷新到主内存中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; &#123; <span class="comment">// 当线程获取锁时，JMM 会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</span></span><br><span class="line">            me.reader();</span><br><span class="line">        &#125;).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-锁的内存语义"><a href="#3-5-2-锁的内存语义" class="headerlink" title="3.5.2 锁的内存语义"></a>3.5.2 锁的内存语义</h3><p>以 ReentrantLock 为例，分为公平锁和非公平锁。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>加锁方法 lock() 调用轨迹：</p>
<ol>
<li>ReentrantLock：lock()</li>
<li>FairSync：lock()</li>
<li>AbstractQueuedSynchronizer：acquire(int arg)</li>
<li>ReentrantLock： tryAcquire(int acquires)</li>
</ol>
<blockquote>
<p> 在获取锁时，会首先读 volatile 变量 state。</p>
</blockquote>
<p>解锁方法 unlock（）调用轨迹：</p>
<ol>
<li>ReentrantLock：unlock（）</li>
<li>AbstractQueuedSynchronizer：release(int arg)</li>
<li>Sync: tryRelease(int releases)</li>
</ol>
<blockquote>
<p>在释放锁的最后，会写 volatile 变量 state</p>
</blockquote>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>加锁：</p>
<ol>
<li>ReentrantLock: lock()</li>
<li>NonfairSync: lock()</li>
<li>AbstractQueuedSynchronizer: compareAndSetState(int expect,int update)</li>
</ol>
<blockquote>
<p>第三步时，会以原子操作的方式更新 state 变量。而 <code>CAS 同时具有 volatile 读和 volatile 写的内存语义</code>。即编译器不会对 CAS 与 CAS 前面和后面的任意内存操作重排序。</p>
</blockquote>
<p>解锁同加锁，以CAS 操作 state。</p>
<h4 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a>公平锁与非公平锁的区别</h4><p>公平锁：加锁前先检查是否有排队等待的线程，优先排队等待的线程，FIFO(先入先出)</p>
<p>非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<h3 id="3-5-4-concurrent-包的实现"><a href="#3-5-4-concurrent-包的实现" class="headerlink" title="3.5.4 concurrent 包的实现"></a>3.5.4 concurrent 包的实现</h3><p>一个通用化的实现方式：</p>
<ol>
<li>首先，声明共享变量为 volatile</li>
<li>然后，使用 CAS 的原子条件更新来实现线程之间的同步</li>
<li>同时，配合以 volatile 的读写和 CAS 具有的 volatile 读写的内存语义来实现线程之间的通信。 </li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些类都是使用这种模式来实现的。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1505674051842&amp;di=c6a5159e65abf3795f1d61abf81c1be1&amp;imgtype=0&amp;src=http%3A%2F%2Fs8.sinaimg.cn%2Fmw690%2F004msBIGzy74jZFZxxZ87" alt="concurrent包的实现示意图"></p>
<h2 id="3-6-happens-before-的定义"><a href="#3-6-happens-before-的定义" class="headerlink" title="3.6 happens-before 的定义"></a>3.6 happens-before 的定义</h2><ol>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，且第一个操作的执行顺序在第二个操作之前</li>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须按照 happens-before 关系指定的顺序来执行。但是JMM 会保证执行的结果一致性</li>
</ol>
<h3 id="3-6-1-happens-before-规则"><a href="#3-6-1-happens-before-规则" class="headerlink" title="3.6.1 happens-before 规则"></a>3.6.1 happens-before 规则</h3><ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before 于任意后续对这个 volatile 域的读</li>
<li>volatile 变量规则，对一个 volatile域的写，happens-before 于任意后续对这个volatile 域的读</li>
<li>传递性：A happens-before B,B happens-before C =&gt; A happens-before C</li>
<li>start() 规则：如果线程A执行 ThreadB.start() ，那么A线程的 ThreadB.start() 操作 happens-before于线程B中的任意操作 </li>
<li>join() 规则：如果线程A执行ThreadB.join() 并成功返回，那么线程B中的任意操作 happens-before 于线程A 从ThreadB.join() 操作成功返回</li>
</ol>
<h2 id="3-7-双重检查锁定"><a href="#3-7-双重检查锁定" class="headerlink" title="3.7 双重检查锁定"></a>3.7 双重检查锁定</h2><p>第一种的同步实例化方法，当多个线程同时调用该方法时，会导致加锁和解锁的操作频发，带来性能的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInit</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于 getInstance() 方法做了同步处理，synchronized 将导致性能开销。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> Instance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种使用双重检查机制，在第一次检查通过后，再进行加锁。但是由于 JMM 的重排序存在，执行结果可能并不如预期一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双重锁机制，来降低同步的开销。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLocking</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果第一次检查instance 不为 null，那么就不需要执行下面的加锁和解锁操作，可以大幅降低synchronized 带来的性能开销</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance(); <span class="comment">// 但是，这里存在问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>instance = new Instance() 应该分为具体的三步：1. 分配内存空间 2. 初始化对象 3. 将 instance 指向该内存空间 ，第二步和第三步之间可能出现指令重排。即存在instance尚未初始化，但是分配了内存空间的多线程问题。</p>
</blockquote>
<p>第三种，基于 volatile 解决方案，将声明对象的引用设置为 volatile 后，代码中的指令重排在多线程环境中将被禁止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLocking</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/05/读书笔记/《Java并发编程的艺术》/3.Java内存模型/" data-id="cjxpj03d000d3rgtwjubfpvrn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《Java并发编程的艺术》/2.Java并发机制的底层实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/04/读书笔记/《Java并发编程的艺术》/2.Java并发机制的底层实现原理/" class="article-date">
  <time datetime="2019-06-03T16:00:01.000Z" itemprop="datePublished">2019-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/04/读书笔记/《Java并发编程的艺术》/2.Java并发机制的底层实现原理/">Java 并发机制的底层实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-Java-并发机制的底层实现原理"><a href="#第二章-Java-并发机制的底层实现原理" class="headerlink" title="第二章 Java 并发机制的底层实现原理"></a>第二章 Java 并发机制的底层实现原理</h1><p>Java 代码在编译之后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终转化为汇编指令在 CPU 上执行。</p>
<p>Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。</p>
<h2 id="2-1-volatile-的应用"><a href="#2-1-volatile-的应用" class="headerlink" title="2.1 volatile 的应用"></a>2.1 volatile 的应用</h2><p>volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。即当一个线程修改了一个共享变量时，另一个线程能够读到这个修改的值。</p>
<p>volatile 的官方定义：Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。</p>
<p>volatile 实现相关的 CPU 术语：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>英文</th>
<th style="text-align:left">术语描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存屏障</td>
<td>memory barriers</td>
<td style="text-align:left">是一组处理器指令，用于实现对内存操作的顺序限制</td>
</tr>
<tr>
<td>缓冲行</td>
<td>cache line</td>
<td style="text-align:left">CPU 高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令</td>
</tr>
<tr>
<td>原子操作</td>
<td>atomic operations</td>
<td style="text-align:left">不可中断的一个或一系列操作</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td style="text-align:left">如果进行高速缓存行中操作的内存位置仍然是下次处理器访问的地址时，处理器将从缓存中读取操作数，而不是从内存中读取</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td style="text-align:left">当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td style="text-align:left">一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody>
</table>
<p>volatile 修改的变量，在进行修改时，会引发两件事：</p>
<ol>
<li>通过 Lock 前缀指令，将当前处理缓存行的数据写回到系统内存</li>
<li>写回内存的操作会使其他 CPU 里缓存了该内存地址的数据无效，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存中。</li>
</ol>
<h2 id="2-2-synchronized-的实现原理与应用"><a href="#2-2-synchronized-的实现原理与应用" class="headerlink" title="2.2 synchronized 的实现原理与应用"></a>2.2 synchronized 的实现原理与应用</h2><p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的 Class 对象</li>
<li>对于同步方法块，锁是 Synchronized 括号里配置的对象</li>
</ul>
<p>Synchronized 在 JVM 里的实现原理：JVM基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但是两者的实现细节不一样。代码块同步是使用 monitorenter 和 monitorexit 指令实现的。</p>
<p>monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处，JVM保证每个 monitorenter 必须对应 monitorexit。线程执行到 monitorenter 指令时，会尝试获取monitor的所有权，即尝试获得对象的锁。</p>
<h3 id="2-2-1-锁的升级与对比"><a href="#2-2-1-锁的升级与对比" class="headerlink" title="2.2.1 锁的升级与对比"></a>2.2.1 锁的升级与对比</h3><p>Java1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>在1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p>锁可以升级但是不能降级，这种策略的目的是为了提高获得锁和释放锁的效率。</p>
<h4 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1. 偏向锁"></a>1. 偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让获得锁的代价更低而引入了偏向锁。</p>
<p>当一个线程访问同步块并获得锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要检查MarkWord 里是否存储着指向当前线程的偏向锁。</p>
<p>即线程获取资源之后，会在资源上记录当前线程地址，并不会释放，当出现竞争时才会释放锁。</p>
<blockquote>
<p>-XX:-UseBiasedLocking=false 关闭偏向锁    </p>
<blockquote>
<p>-XX:BiasedLockingStartupDelay=0 关闭延迟(默认情况下，偏向锁在程序启动几秒后才会激活)</p>
</blockquote>
</blockquote>
<h4 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h4><p>加锁：线程在执行同步块之前，JVM会将对象头中的MarkWord 复制到当前线程的锁记录中。然后线程尝试使用 CAS 将对象头中的 MarkWord 替换为指向锁记录的指针。如果成功，线程获得锁；失败，表示其他线程竞争锁，当前线程尝试使用 自旋(即当前线程不停地尝试请求资源，直到成功) 来获取锁。</p>
<p>解锁：解锁时，使用 CAS 操作将 MarkWord 替换回对象头。成功，则表示没有竞争发生；失败，则表示锁存在竞争，此时锁会膨胀成重量级锁。</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/201812081005.png" alt="争夺锁导致的锁膨胀"></p>
<p>图中可以看出，自旋会消耗CPU，为了避免无用的自旋，一旦锁升级为重量级锁，就不会再降级为轻量级锁。重量级锁的所有线程在请求锁资源时，都会进入阻塞状态，只有当锁释放时，才会进行新一轮的夺锁之争。</p>
<p>锁的优缺点对比：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁解锁不需要额外消耗，和执行非同步方法相比，仅纳秒级差距</td>
<td>如果线程间存在锁竞争，会带来锁撤销的消耗</td>
<td>只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争，会使用自旋消耗CPU</td>
<td>追求响应时间  同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量   同步块执行速度较长</td>
</tr>
</tbody>
</table>
<h2 id="2-3-原子操作的实现原理"><a href="#2-3-原子操作的实现原理" class="headerlink" title="2.3 原子操作的实现原理"></a>2.3 原子操作的实现原理</h2><p>原子（atomic）：“不能被进一步分隔的最小粒子”。</p>
<p>原子操作（atomic operation）：“不可被中断的一个或一系列操作”。</p>
<h3 id="原子操作的相关术语："><a href="#原子操作的相关术语：" class="headerlink" title="原子操作的相关术语："></a>原子操作的相关术语：</h3><table>
<thead>
<tr>
<th>术语</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存行</td>
<td>cache line</td>
<td>缓存的最小操作单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS，比较旧值与新值。当旧值发生改变之后才进行替换</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>在CPU内由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令分为5~6步后再由这些电路单元分别执行，这样就能在一个CPU时钟周期完成一条指令，从而提高CPU的运算速度</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>Memory order violation</td>
<td>内存顺序冲突一般由假共享引起，即多个CPU同时修改一个缓存行的不同部分，引起其中一个CPU操作无效，当出现该冲突时，CPU必须清空流水线</td>
</tr>
</tbody>
</table>
<h3 id="处理器如何实现原子操作："><a href="#处理器如何实现原子操作：" class="headerlink" title="处理器如何实现原子操作："></a>处理器如何实现原子操作：</h3><ol>
<li>通过总线锁保证原子性：<ol>
<li>即使用处理器提供 LOCK # 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，该处理器则独占内存。</li>
<li>缺点：总线锁是把CPU和内存之间的通信锁住了，这使得锁定期内，其他处理器不能操作其他内存地址的数据，因此开销很大。</li>
</ol>
</li>
<li>通过缓存锁定来保证原子性：<ol>
<li>指内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，处理器直接修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。</li>
<li>缓存一致性：该机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</li>
<li>不能使用缓存锁定的场景：a. 操作的数据跨缓存行时，b. 处理器不支持缓存锁定。这两种情况都被调用总线锁定。</li>
</ol>
</li>
</ol>
<h3 id="Java-如何实现原子操作："><a href="#Java-如何实现原子操作：" class="headerlink" title="Java 如何实现原子操作："></a>Java 如何实现原子操作：</h3><p>在 Java 中可以通过 <code>锁</code> 和 <code>循环CAS</code> 的方式来实现原子操作。</p>
<p>从 Java 1.5 开始，JDK提供了一些原子包装类来支持原子操作。</p>
<h3 id="CAS-实现原子操作的三大问题"><a href="#CAS-实现原子操作的三大问题" class="headerlink" title="CAS 实现原子操作的三大问题"></a>CAS 实现原子操作的三大问题</h3><ol>
<li><code>ABA 问题</code>。<ol>
<li>原因：因为CAS 在操作值时，先比较旧值是否发生了变化，如果发生变化，再去修改该值。问题则出现在，如果A = 1；A=2；A=1；此时CAS检查时，并未发现A的变化，但是实际上却变化了。</li>
<li>解决思路：加上版本号即A1=1,A2=2,A3=1</li>
<li>JDK 中提供了一个类 AtomicStampedReference，通过检查值和预期标记的方法来判断是否需要更新</li>
</ol>
</li>
<li><code>循环时间长开销大</code> 。<ol>
<li>原因：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>解决方法：如果JVM能支持处理器提供的pause指令，则效率会有一定提升。pause指令能延迟流水线执行指令，避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，从而提升CPU执行效率。</li>
</ol>
</li>
<li>只能保证一个共享变量的原子操作。<ol>
<li>原因：当对一个共享变量执行操作时，可以使用循环 CAS，但是对多个共享变量时，就无法保证操作的原子性，此时可以用锁。</li>
<li>解决方法：将多个共享变量合为一个共享变量来操作，如 i=2,j=a =&gt; ij=2a</li>
<li>JDK解决方法，提供了AtomicReference类来保证引用对象之间的原子性，即可以把多个变量放在一个对象中进行CAS操作。</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/04/读书笔记/《Java并发编程的艺术》/2.Java并发机制的底层实现原理/" data-id="cjxpj03d200d5rgtw9p43yeyh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/20/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git命令学习/">Git命令学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-核心知识点整理/">JAVA 核心知识点整理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发编程与高并发解决方案/">Java并发编程与高并发解决方案</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发编程的艺术/">Java并发编程的艺术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/">Java成神之路</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/Study社区/">Study社区</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux学习之路/">Linux学习之路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown语法/">MarkDown语法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React学习/">React学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-参考指南/">SpringBoot 参考指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具函数/">工具函数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高性能MySQL/">高性能MySQL</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git-Bash/">Git Bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POI/">POI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Data/">Spring Data</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poi/">poi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Git/" style="font-size: 13.75px;">Git</a> <a href="/tags/Git-Bash/" style="font-size: 11.25px;">Git Bash</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/POI/" style="font-size: 16.25px;">POI</a> <a href="/tags/Spring-Cloud/" style="font-size: 10px;">Spring Cloud</a> <a href="/tags/Spring-Data/" style="font-size: 12.5px;">Spring Data</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/gradle/" style="font-size: 11.25px;">gradle</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/poi/" style="font-size: 10px;">poi</a> <a href="/tags/并发编程/" style="font-size: 12.5px;">并发编程</a> <a href="/tags/数据库/" style="font-size: 17.5px;">数据库</a> <a href="/tags/读书笔记/" style="font-size: 18.75px;">读书笔记</a> <a href="/tags/高并发/" style="font-size: 12.5px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/30/blog/2019/">2019年目标</a>
          </li>
        
          <li>
            <a href="/2019/12/01/读书笔记/《Java并发编程的艺术》/0.0_目录/">《Java并发编程的艺术》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/12/01/读书笔记/《Java核心知识点整理》/0.目录/">《JAVA 核心知识点整理》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/11/30/读书笔记/《高性能MySQL》/0.目录/">《高性能MySQL》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/07/05/读书笔记/《JavaDesignPatterns》/8.建造者模式/">《Java Design Patterns》第六章 建造者模式 - 复杂对象的组装与创建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 koral<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>