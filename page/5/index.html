<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="罗凯的博客主页"><meta name="keywords" content="博客,全栈工程师,前端工程师,后端工程师,运维工程师,罗凯的博客,罗凯,DevOps,技术博客"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>现在的我可以做点什么，让未来的我可以受益匪浅？ | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">罗凯的博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">270</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">48</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">现在的我可以做点什么，让未来的我可以受益匪浅？</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/State/useSet/">《Umi Hooks》官网笔记-useSet</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useSet"><a href="#useSet" class="headerlink" title="useSet"></a>useSet</h1><p>一个可以管理 Set 类型状态的 Hook。</p>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">const [
    // Set 对象
    set,
    {
        // 添加元素
        add,
        // 判断是否存在元素
        has,
        // 移除元素
        remove,
        // 重置为默认值
        reset
    }
] = useSet(
    // 默认值
    initialValue?: Iterable&lt;K&gt;
);</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/State/useToggle/">《Umi Hooks》官网笔记-useToggle</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useToggle"><a href="#useToggle" class="headerlink" title="useToggle"></a>useToggle</h1><p>用于在两个状态值间切换的 Hook。</p>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">const {
    // 状态值
    state,
    // 触发状态更改的函数
    toggle,
    setLeft,
    setRight
} = useToggle(
    // 默认状态值
    defaultValue?: boolean,
    // 取反的状态值
    reverseValue?: any
);</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/UI/useDynamicList/">《Umi Hooks》官网笔记-useDynamicList</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useDynamicList"><a href="#useDynamicList" class="headerlink" title="useDynamicList"></a>useDynamicList</h1><p>一个帮助你管理列表状态，并能生成唯一 key 的 Hook。</p>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">const {
    // 当前的列表：T[]
    list,
    // 重新设置 list 的值：(list: T[]) =&gt; void
    resetList,
    // 在指定位置插入元素：(index: number, obj: T) =&gt; void
    insert,
    // 在指定位置插入多个元素：(index: number, obj: T) =&gt; void
    merge,
    // 替换指定元素：(index: number, obj: T) =&gt; void
    replace,
    // 删除指定元素：(index: number) =&gt; void
    remove,
    // 移动元素：(oldIndex: number, newIndex: number) =&gt; void
    move,
    // 获得某个元素的 UUID：(index: number) =&gt; number
    getKey,
    // 获得某个 key 的 index：(key: number) =&gt; number
    getIndex,
    // 根据表单结果自动排序：(list: unKnown[]) =&gt; unKnown[]
    sortForm,
    // 在列表末尾添加元素：(obj: T) =&gt; void
    push,
    // 移除末尾元素：() =&gt; void
    pop,
    // 在列表起始位置添加元素：(obj: T) =&gt; void
    unshift,
    // 移除起始位置元素：() =&gt; void
    shift
} = useDynamicList(
    // 列表的初始值：T[]
    initialValue: T[]
);</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/UI/useDrag&amp;useDrop/">《Umi Hooks》官网笔记-useDrop &amp; useDrag</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useDrop-amp-useDrag"><a href="#useDrop-amp-useDrag" class="headerlink" title="useDrop &amp; useDrag"></a>useDrop &amp; useDrag</h1><p>一对能帮助处理拖拽中 进行数据转移 的 hooks。</p>
<blockquote>
<p>useDrop 可能单独使用来接收文件、文字和网址的拖拽。</p>
<p>useDrag 允许一个 dom 节点被拖拽，需要配合 useDrop 使用。</p>
<p>向节点内触发粘贴时也会被视为拖拽的内容。</p>
</blockquote>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">// getDragProps：一个接收拖拽的值，并返回需要透传给被拖拽节点 props 的方法
const getDragProps = useDrag();

&lt;div {...getDragProps(id)}&gt;draggable&lt;/div&gt;

/**
 * props: 需要透传给接受拖拽区域 dom 节点的 props
 * isHovering：是否拖拽中，且光标处于释放区域内
 */
const [ props, { isHovering } ] = useDrop({
    // 拖拽文字的回调
    onText: (text: string, e: Event) =&gt; void,
    // 拖拽文件的回调
    onFiles: (files: File[], e: Event) =&gt; void,
    // 拖拽链接的回调
    onUri: (uri: string, e: Event) =&gt; void,
    // 拖拽自定义 dom 节点的回调
    onDom: (content: any, e: Event) =&gt; void
})</code></pre>
<h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>拖拽区域可以接受文件、链接、文字和下方的box节点。</p>
<pre><code class="tsx">import React, { useState } from &#39;react&#39;;
import { message } from &#39;antd&#39;;
import { useDrop, useDrag } from &#39;@umijs/hooks&#39;;

export default () =&gt; {
  const getDragProps = useDrag();
  const [props, { isHovering }] = useDrop({
    onText: (text) =&gt; {
      message.success(`text:${text}`);
    },
    onFiles: (files) =&gt; {
      message.success(`files: ${files.length}`);
    },
    onUri: (uri) =&gt; {
      message.success(`uri: ${uri}`);
    },
    onDom: (content) =&gt; {
      message.success(`content: ${content}`);
    },
  });
  return (
    &lt;div&gt;
      &lt;div style={{ border: '1px dashed #e8e8e8', padding: 16, textAlign: 'center' }} {...props}&gt;
        {isHovering ? &#39;放这儿&#39; : &#39;拖到这儿&#39;}
      &lt;/div&gt;
      &lt;div style={{ display: 'flex', marginTop: 8 }}&gt;
        {Array.from(Array(5)).map((e, i) =&gt; (
          &lt;div
            {...getDragProps(`box${i}`)}
            style={{
              border: '1px solid #e8e8e8',
              padding: 16,
              width: 80,
              textAlign: 'center',
              marginRight: 16,
            }}
          &gt;
            box[i]
          &lt;/div&gt;
        ))}
       &lt;a href=&quot;www.baidu.com&quot;&gt;baidu&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/UI/useVirtualList/">《Umi Hooks》官网笔记-useVirtualList</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useVirtualList"><a href="#useVirtualList" class="headerlink" title="useVirtualList"></a>useVirtualList</h1><p>提供虚拟化列表能力的 Hook，用于解决展示海量数据渲染时首屏渲染缓慢和滚动卡顿问题。</p>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">const {
    // 当前需要展示的列表内容
    list,
    // 滚动容器的 props
    containerProps,
    // children 外层包裹器 props
    wrapperProps,
    // 快速滚动到指定 index
    scrollTo
} = useVirtualList(
    // 包含大量数据的列表
    originalList: any[],
    options: {
        // 行高度，静态高度可以直接写入像素值，动态高度可传入函数
        itemHeight,
        // 视区上、下额外展示的 dom 节点数量
        overscan
    }
)</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/UI/useSelections/">《Umi Hooks》官网笔记-useSelections</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h1 id="useSelections"><a href="#useSelections" class="headerlink" title="useSelections"></a>useSelections</h1><p>常见联动的 checkbox 逻辑封装，支持多选、单选、全选逻辑，还提供了是否选择、是否全选、是否半选的状态。</p>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><pre><code class="js">const {
    // 已经选择的元素，array
    selected,
    // 是否被选择，func
    isSelected,
    // 选择元素，func
    select,
    // 取消选择元素，func
    unSelect,
    // 反选元素，func
    toggle,
    // 选择全部元素，func
    selectAll,
    // 取消选择全部元素，func
    unSelectAll,
    // 反选全部元素，func
    toggleAll,
    // 是否全选，boolean
    allSelected,
    // 是否一个都没有选择，boolean
    noneSelected,
    // 是否半选
    partiallySelected,
    // 设置选择的元素
    setSelected
} = useSelections&lt;T&gt;(items: T[], defaultSelected?: T[]);</code></pre>
<h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>常见的checkbox联动</p>
<pre><code class="tsx">import React, { useMemo, useState } from &#39;react&#39;;
import { Checkbox, Row, Col } from &#39;antd&#39;;
import { useSelections } from &#39;@umijs/hooks&#39;;

export default () =&gt; {
  const [hideOdd, setHideOdd] = useState(false);

  const list = useMemo(() =&gt; {
    if (hideOdd) {
      return [2, 4, 6, 8];
    }
    return [1, 2, 3, 4, 5, 6, 7, 8];
  }, [hideOdd]);

  const {
    selected,
    allSelected,
    isSelected,
    toggle,
    toggleAll,
    partiallySelected,
  } = useSelections(list, [1]);

  return (
    &lt;div&gt;
      &lt;div&gt;Selected: {selected.join(&#39;,&#39;)}&lt;/div&gt;
      &lt;div style={{ borderBottom: '1px solid #e8e8e8', padding: '10px 0' }}&gt;
        &lt;Checkbox checked={allSelected} onClick={toggleAll} indeterminate={partiallySelected}&gt;
          全选
        &lt;/Checkbox&gt;
        &lt;Checkbox checked={hideOdd} onClick={() =&gt; setHideOdd((v) =&gt; !v)}&gt;
          隐藏部分
        &lt;/Checkbox&gt;
      &lt;/div&gt;
      &lt;Row style={{ padding: '10px 0' }}&gt;
        {list.map((o) =&gt; (
          &lt;Col span={12} key={o}&gt;
            &lt;Checkbox checked={isSelected(o)} onClick={() =&gt; toggle(o)}&gt;
              {o}
            &lt;/Checkbox&gt;
          &lt;/Col&gt;
        ))}
      &lt;/Row&gt;
    &lt;/div&gt;
  );
};</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/前端/UmiHooks/Async/useRequest/">《Umi Hooks》官网笔记-useRequest</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/">前端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/前端/Umi-Hooks/">Umi/Hooks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umi-Hooks/">Umi/Hooks</a></span><div class="content"><h2 id="useRequest"><a href="#useRequest" class="headerlink" title="useRequest"></a>useRequest</h2><p>强大的管理异步数据请求的Hook.</p>
<p><strong>核心特性</strong></p>
<ul>
<li>自动请求/手动请求</li>
<li>SWR(state-while-revalidate)</li>
<li>缓存/预加载</li>
<li>屏幕聚焦重新请求</li>
<li>轮询</li>
<li>防抖</li>
<li>节流</li>
<li>并行请求</li>
<li>loading delay</li>
<li>分页</li>
<li>加载更多，数据恢复 + 滚动位置恢复</li>
<li>错误重试</li>
<li>请求超时管理</li>
<li>suspense</li>
<li>……</li>
</ul>
<h3 id="默认请求"><a href="#默认请求" class="headerlink" title="默认请求"></a>默认请求</h3><pre><code class="tsx">/**
 * title: 默认请求
 * desc: useRequest接收一个异步函数 getUsername，在组件初次加载时，自动触发该函数执行。同时 useRequest 会自动管理异步请求的 loading、data、error 等状态。
 */
import React from &quot;react&quot;;
import { useRequest } from &quot;@umijs/hooks&quot;;

function getUsername() {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        name: &#39;张大三&#39;
      })
    }, 1000);
  })
}

export default () =&gt; {
  const {data,loading,error} = useRequest(getUsername)

  if(error) {
    return &lt;div&gt; fail load data &lt;/div&gt;
  }
  if(loading) {
    return &lt;div&gt;loading...&lt;/div&gt;
  }
  return (
    &lt;div&gt;
      Username: {data.name}
    &lt;/div&gt;
  );
};</code></pre>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><pre><code class="tsx">/**
 * title: 手动触发
 * desc: 通过 options.manual=true 时，需要手动调用 run 时才会触发执行异步函数。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Button, Input, message } from &#39;antd&#39;;
import React, { useState } from &#39;react&#39;;

function changeValue(Username: string):Promise&lt;{success: boolean}&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({success: true})
    }, 1000);
  })
}

export default () =&gt; {
 const [data,setData] = useState(&#39;&#39;);
 const {loading,run} = useRequest(changeValue,{
   manual: true,
   onSuccess: (result, params) =&gt; {
     if(result.success) {
       setData(&#39;&#39;);
       message.success(`The username was changed to ${params[0]}`);
     }
   }
 })

  return (
    &lt;div&gt;
      &lt;Input value={data} onChange={e =&gt; setData(e.target.value)} style={{width:240}}/&gt;
      &lt;Button loading={loading} onClick={() =&gt; run(data)}&gt;修改&lt;/Button&gt;
    &lt;/div&gt;
  )
};</code></pre>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><pre><code class="tsx">/**
 * title: 轮询
 * desc: 通过设置 options.pollingInterval，进入轮询模式，定时触发函数执行。
 * - 通过设置 options.pollingWhenHidden=false，在屏幕不可见时，暂时暂停定时任务。
 * - 通过 run / cancel 来开始或停止轮询。
 * - 在 options.manual=true 时，需要第一次执行 run 后，才开始轮询。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Button, Spin } from &#39;antd&#39;;
import React from &#39;react&#39;;

function changeValue():Promise&lt;string&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(&quot;张大三&quot;)
    }, 1000);
  })
}

export default () =&gt; {
 const { data, loading, run, cancel } = useRequest(changeValue,{
   pollingInterval: 1000,
   pollingWhenHidden: false
 })

  return (
    &lt;div&gt;
      &lt;Spin spinning={loading}&gt;Username: {data}&lt;/Spin&gt;
      &lt;Button.Group&gt;
        &lt;Button onClick={run}&gt;开始&lt;/Button&gt;
        &lt;Button onClick={cancel}&gt;暂停&lt;/Button&gt;
      &lt;/Button.Group&gt;
    &lt;/div&gt;
  )
};</code></pre>
<h3 id="并行请求"><a href="#并行请求" class="headerlink" title="并行请求"></a>并行请求</h3><pre><code class="tsx">/**
 * title: 轮询
 * desc: 通过 options.fetchKey，将请求分类，每一类请求都有独立的状态，可以在 fetches 中找到所有请求。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Button, message } from &#39;antd&#39;;
import React from &#39;react&#39;;

function deleteUser(userId: string): Promise&lt;{success: boolean}&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({success: true})
    }, 1000);
  })
}

export default () =&gt; {
  const { run, fetches } = useRequest(deleteUser, {
    manual: true,
    fetchKey: id =&gt; id,
    onSuccess: (result, params) =&gt; {
      if(result.success) {
        message.success(`禁用用户[${params[0]}]`);
      }
    }
  });

  const users = [{id:&#39;1&#39;,username:&#39;A&#39;},{id:&#39;2&#39;,username:&#39;B&#39;},{id:&#39;3&#39;,username:&#39;C&#39;}];

  return (
    &lt;div&gt;
      &lt;ul&gt;
        {users.map((user) =&gt; (
          &lt;li key={user.id} style={{marginTop:8}}&gt;
            &lt;Button loading={fetches[user.id]?.loading} onClick={() =&gt; run(user.id)}&gt;delete {user.username}&lt;/Button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><pre><code class="tsx">/**
 * title: 防抖
 * descirption: 通过设置 options.debounceInterval，进入防抖模式。此时如果频繁触发 run，则会以防抖策略进行请求。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Select } from &#39;antd&#39;;
import React from &#39;react&#39;;

async function getEmail(search: string): Promise&lt;string[]&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([&#39;188&#39;,&#39;173&#39;,&#39;187&#39;,&#39;159&#39;,&#39;156&#39;]);
    }, 300);
  })
}

export default () =&gt; {
  const { data, loading, run ,cancel } = useRequest(getEmail, {
    debounceInterval: 500,
    manual: true
  })
  return (
    &lt;div&gt;
      &lt;Select
        showSearch
        placeholder=&quot;select emails&quot;
        filterOption={false}
        onSearch={run}
        onBlur={cancel}
        loading={loading}
        style={{width: 300}}
      &gt;
        {data &amp;&amp; data.map(i=&gt; &lt;Select.Option key={i}&gt;{i}&lt;/Select.Option&gt;)}
      &lt;/Select&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><pre><code class="tsx">/**
 * title: 节流
 * descirption: 通过设置 options.throttleInterval，进入节流模式。此时如果频繁触发 run，则会以节流策略进行请求。例如： options.throttleInterval=2000，则频繁点击时，仍会以2s每次请求。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Select } from &#39;antd&#39;;
import React from &#39;react&#39;;

async function getEmail(search: string): Promise&lt;string[]&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([String(Math.random())]);
    }, 300);
  })
}

export default () =&gt; {
  const { data, loading, run ,cancel } = useRequest(getEmail, {
    throttleInterval: 2000,
    manual: true
  })
  return (
    &lt;div&gt;
      &lt;Select
        showSearch
        placeholder=&quot;select emails&quot;
        filterOption={false}
        onSearch={run}
        onBlur={cancel}
        loading={loading}
        style={{width: 300}}
      &gt;
        {data &amp;&amp; data.map(i=&gt; &lt;Select.Option key={i}&gt;{i}&lt;/Select.Option&gt;)}
      &lt;/Select&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="缓存-amp-SWR"><a href="#缓存-amp-SWR" class="headerlink" title="缓存 &amp; SWR"></a>缓存 &amp; SWR</h3><pre><code class="tsx">/**
 * title: 缓存 &amp; SWR
 * descirption: 通过设置 options.cacheKey，useRequest 会将当前请求结束数据缓存起来。下次组件初始化时，如果有缓存数据，则优先返回缓存数据，然后在背后发送新请求，也就是 SWR 的能力。
 */
import { useRequest, useBoolean } from &#39;@umijs/hooks&#39;;
import { Button, Spin } from &#39;antd&#39;;
import React from &#39;react&#39;;

async function getArticle(type?: string): Promise&lt;{data:string,time:number}&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        data: &#39;这里是数据显示部分这里是数据显示部分这里是数据显示部分这里是数据显示部分这里是数据显示部分&#39;,
        time: new Date().getTime()
      })
    }, 1000);
  })
}

export default () =&gt; {
  const { state, toggle } = useBoolean();
  return (
    &lt;div&gt;
      &lt;p&gt;
        &lt;Button onClick={() =&gt; toggle()}&gt;show/hidden&lt;/Button&gt;
      &lt;/p&gt;
      {state &amp;&amp; &lt;Article /&gt;}
    &lt;/div&gt;
  )
}

const Article = () =&gt; {
  const { data, loading } = useRequest(getArticle, {
    cacheKey: `article`
  })
  return (
    &lt;Spin spinning={!data &amp;&amp; loading}&gt;
      &lt;p&gt;最后一次请求时间：{data?.time}&lt;/p&gt;
      &lt;p&gt;{data?.data}&lt;/p&gt;
    &lt;/Spin&gt;
  )
}</code></pre>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><pre><code class="tsx">/**
 * title: 预加载
 * descirption: 同一个 cacheKey 的请求，是全局共享的。利用该特性，可以很方便的实现预加载。
 */
import { useRequest, useBoolean } from &#39;@umijs/hooks&#39;;
import { Button, Spin } from &#39;antd&#39;;
import React from &#39;react&#39;;

async function getArticle(type?: string): Promise&lt;{data:string,time:number}&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        data: &#39;这里是数据显示部分这里是数据显示部分这里是数据显示部分这里是数据显示部分这里是数据显示部分&#39;,
        time: new Date().getTime()
      })
    }, 1000);
  })
}

export default () =&gt; {
  const { state, toggle } = useBoolean();
  const {run} = useRequest(getArticle, {
    cacheKey: &#39;article&#39;,
    manual: true
  })
  return (
    &lt;div&gt;
      &lt;p&gt;
        &lt;Button onMouseEnter={() =&gt; run()} onClick={() =&gt; toggle()}&gt;show/hidden&lt;/Button&gt;
      &lt;/p&gt;
      {state &amp;&amp; &lt;Article /&gt;}
    &lt;/div&gt;
  )
}

const Article = () =&gt; {
  const { data, loading } = useRequest(getArticle, {
    cacheKey: `article`
  })
  return (
    &lt;Spin spinning={!data &amp;&amp; loading}&gt;
      &lt;p&gt;最后一次请求时间：{data?.time}&lt;/p&gt;
      &lt;p&gt;{data?.data}&lt;/p&gt;
    &lt;/Spin&gt;
  )
}</code></pre>
<h3 id="屏幕聚焦重新请求"><a href="#屏幕聚焦重新请求" class="headerlink" title="屏幕聚焦重新请求"></a>屏幕聚焦重新请求</h3><pre><code class="tsx">/**
 * title: 屏幕聚焦重新请求
 * descirption: 设置 options.refreshOnWindowFocus=true，则在浏览器窗口 refocus 和 revisible 时，会重新发起请求。可以通过设置 options.focusTimespan 来设置请求间隔，默认为5000ms。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Spin } from &#39;antd&#39;;
import React from &#39;react&#39;;

function getUsername(): Promise&lt;Number&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(Math.random());
    }, 1000);
  })
}

export default () =&gt; {
  const { data, loading } = useRequest(getUsername,{
    refreshOnWindowFocus: true,
    focusTimespan: 5000
  })
  return (
    &lt;div&gt;
     &lt;Spin spinning={loading}&gt;
      Random: {data}
     &lt;/Spin&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="突变"><a href="#突变" class="headerlink" title="突变"></a>突变</h3><pre><code class="tsx">/**
 * title: 突变
 * descirption: 你可以通过 mutate，直接修改 data。mutate 函数参数可以为 newData 或 (oldData) =&gt; newData。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Button, Input, message  } from &#39;antd&#39;;
import React,{ useState } from &#39;react&#39;;

function getUsername(): Promise&lt;string&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(String(Math.random()));
    }, 1000);
  })
}

function changeUsername(username: string): Promise&lt;{success: boolean}&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({success: true})
    }, 1000);
  })
}

export default () =&gt; {
  const [state, setState] = useState(&#39;&#39;)
  const { data, mutate } = useRequest(getUsername, {
    onSuccess: result =&gt; {
      setState(result)
    }
  });

  const { loading, run } = useRequest(changeUsername, {
    manual: true,
    onSuccess: (result, params) =&gt; {
      if(result.success) {
        mutate(params[0]);
        message.success(`changed to ${params[0]}`)
      }
    }
  })
  return (
    &lt;div&gt;
     &lt;p&gt;Username: {data}&lt;/p&gt;
     &lt;Input 
      onChange={e =&gt; setState(e.target.value)}
      value={state}
      placeholder=&#39;please enter username&#39;
      style={{width:240}}
     /&gt;
     &lt;Button onClick={() =&gt; run(state)} loading={loading}&gt;
       Edit
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="Loading-Delay"><a href="#Loading-Delay" class="headerlink" title="Loading Delay"></a>Loading Delay</h3><pre><code class="tsx">/**
 * title: Loading Delay
 * descirption: 通过设置 options.loadingDelay，可以延迟 loading 变为 true 的时间，有效防止闪烁。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Button, Spin  } from &#39;antd&#39;;
import React,{  } from &#39;react&#39;;

async function getCurrentTime(): Promise&lt;number&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(new Date().getTime());
    }, 1000);
  })
}

export default () =&gt; {
  const getTimeAction = useRequest(getCurrentTime);

  const withLoadingDelayAction = useRequest(getCurrentTime, {
    loadingDelay: 200
  })

  const trigger = () =&gt; {
    getTimeAction.run();
    withLoadingDelayAction.run();
  }

  return (
    &lt;div&gt;
      &lt;Button onClick={trigger}&gt;获取数据&lt;/Button&gt;
      &lt;div&gt;
        &lt;Spin spinning={getTimeAction.loading}&gt;
          无延迟请求结果：{getTimeAction.data}
        &lt;/Spin&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;Spin spinning={withLoadingDelayAction.loading}&gt;
          有延迟请求结果：{withLoadingDelayAction.data}
        &lt;/Spin&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="refreshDeps"><a href="#refreshDeps" class="headerlink" title="refreshDeps"></a>refreshDeps</h3><pre><code class="tsx">/**
 * title: refreshDeps
 * descirption: 当某些 state 变化时，我们需要重新执行异步请求。refreshDeps是一个语法糖，当 refreshDeps 变化时，会使用之前的 params 重新执行 service。
 */
import { useRequest } from &#39;@umijs/hooks&#39;;
import { Select, Spin  } from &#39;antd&#39;;
import React,{ useState } from &#39;react&#39;;

const userSchool = (id: string) =&gt; {
  switch(id) {
    case &#39;1&#39;:
      return &#39;Tsinghua&#39;;
    case &#39;2&#39;:
      return &#39;Beijing&#39;;
    case &#39;3&#39;:
      return &#39;Zhejiang&#39;;
    default: 
      return &#39;&#39;;
  }
}

async function getUserSchool(userId: string): Promise&lt;string&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(userSchool(userId));
    }, 1000);
  })
}

export default () =&gt; {
  const [userId, setUserId] = useState(&#39;1&#39;);
  const { data, loading } = useRequest(() =&gt; getUserSchool(userId), {
    refreshDeps: [userId]
  })

  return (
    &lt;div&gt;
      &lt;Select onChange={setUserId} value={userId}&gt;
        &lt;Select.Option value=&quot;1&quot;&gt;User 1&lt;/Select.Option&gt;
        &lt;Select.Option value=&quot;2&quot;&gt;User 2&lt;/Select.Option&gt;
        &lt;Select.Option value=&quot;3&quot;&gt;User 3&lt;/Select.Option&gt;
      &lt;/Select&gt;
      &lt;Spin spinning={loading}&gt;
        School: {data}
      &lt;/Spin&gt;
    &lt;/div&gt;
  )
}</code></pre>
<h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><pre><code class="js">const {
    // service返回的数据，默认为undefined
    // 如果有 formatResult，则数据为格式化后的数据
    data,
    // service 抛出的异常，默认为 undefined
    error,
    // 加载状态，service 是否正在执行
    loading,
    // 手动触发service执行，参数会传递给service
    // debounce与throttle模式，返回值为 Promise&lt;null&gt;
    run,
    // 当次执行的 service 参数数组。如 run(1,2,3)，则params=[1,2,3]
    params,
    // 取消当前请求
    // 如果有轮询，停止
    cancel,
    // 使用上一次的 params，重新执行service
    refresh,
    // 直接修改state
    mutate,
    // 默认情况下，新请求会覆盖旧请求。如果设置了 fetchKey，则可以实现多请求并行，由fetches存储每个fetchKey对应的状态
    // 外层的状态为最新触发的 fetches 数据
    fetches
} = useRequest(service, {
    // false：初始化时自动执行service；true：需要手动调用run触发执行。
    manual,
    // 默认的data
    initialData,
    // 在 manual=false 时，refreshDeps变化，会触发service重新执行
    refreshDeps,
    // service resolve 触发，参数为data和params；如果有 formatResult，则data为格式化后的数据
    onSuccess,
    // service 报错是触发，参数为 error 和 params
    onError,
    // 格式化请求结果
    formatResult,
    // 请求唯一标识，如果设置了，会启用缓存机制
    // 会缓存每次请求的 data、error、params、loading
    // 在缓存机制下，同样的请求会先返回缓存中的数据，同时在背后发送新的请求，待新数据返回后，重新触发数据更新
    cacheKey,
    // 设置显示 loading 的延迟时间，避免闪烁
    loadingDelay,
    // 如果 manual=false，自动执行 run 时，默认带上的参数
    defaultParams,
    // 轮询间隔，单位毫秒
    pollingInterval,
    // 页面隐藏时，是否继续轮询。默认为true
    // false：在页面隐藏时停止轮询，页面重新显示时继续上次轮询
    pollingWhenHidden,
    // 根据params获取当前请求的key，在 fetches 中同时维护不同的key值的请求状态
    fetchKey,
    // 屏幕重新获取焦点或重新显示时，是否重新发起请求
    // false：默认，不会发起请求
    refreshOnWindowFocus,
    // 指定时间间隔内，屏幕重新聚焦，不会重新发起请求
    // 需要配合 refreshOnWindowFocus 一起使用
    focusTimespan,
    // 防抖间隔，毫秒
    debounceInterval,
    // 节流间隔，毫秒
    throttleInterval
})</code></pre>
<h2 id="扩展用法"><a href="#扩展用法" class="headerlink" title="扩展用法"></a>扩展用法</h2><p>基于基础的 useRequest，进一步封装，实现更高级的定制需求。当前 useRequest 内置了 <code>集成请求库</code>、<code>分页</code>、<code>加载更多</code> 三个场景。</p>
<p>可参考 useRequest、usePaginated、useLoadMore 的实现。</p>
<h3 id="集成请求库"><a href="#集成请求库" class="headerlink" title="集成请求库"></a>集成请求库</h3><p>如果service是 <code>string</code>、<code>object</code>、<code>(...args) =&gt; string|object</code>，会自动使用 umi-request 来发送网络请求。umi-request 是类似 axios、fetch 的请求库。</p>
<pre><code class="js">// 用法1
const { data, error, loading } = useRequest(&#39;/api/currentUser&#39;);

// 用法2
const { data, error, loading } = useRequest({
    url: &#39;/api/currentUser&#39;,
    method: &#39;GET&#39;
})

// 用法3
const { data, error, loading } = useRequest((userId) =&gt; `/api/user/${userId}`)

// 用法4
const { data, error, loading } = useRequest((username) =&gt; ({
    url: &#39;/api/changeUsername&#39;,
    method: &#39;PUT&#39;,
    data: {username}
}), {
    manual: true
})</code></pre>
<p>使用默认的 umi-request：</p>
<pre><code class="tsx">import { useRequest } from &#39;@umijs/hooks&#39;;
import React from &#39;react&#39;;


export default () =&gt; {
  const {data,error,loading} = useRequest(&#39;https://helloacm.com/api/random/?n=8&amp;x=4&#39;)

  if(error) {
    return &lt;div&gt;error&lt;/div&gt;
  }

  if(loading) {
    return &lt;div&gt;loading&lt;/div&gt;
  }

  return (
    &lt;div&gt;
      {data}
    &lt;/div&gt;
  )
}</code></pre>
<p>使用 axios：</p>
<pre><code class="tsx">import { useRequest } from &#39;@umijs/hooks&#39;;
import React from &#39;react&#39;;
import axios from &#39;axios&#39;;


export default () =&gt; {
  const {data,error,loading} = useRequest(&#39;https://helloacm.com/api/random/?n=8&amp;x=4&#39;,{
    requestMethod: (params: any) =&gt; axios(params)
  })

  if(error) {
    return &lt;div&gt;error&lt;/div&gt;
  }

  if(loading) {
    return &lt;div&gt;loading&lt;/div&gt;
  }

  return (
    &lt;div&gt;
      {data}
    &lt;/div&gt;
  )
}</code></pre>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>通过设置 options.paginated = true，useRequest 将以分页模式运行，此时会有以下特性：</p>
<ul>
<li>useRequest 会自动管理分页 <code>current</code>、<code>pageSize</code>。service 第一个参数为 <code>{current, pageSize}</code>。</li>
<li>service 返回的数据结构必须为 <code>{list: Item[], total: number}</code>，如果不满足，可通过 <code>options.formatResult</code> 进行转换</li>
<li>会额外返回 <code>pagination</code> 字段，包含所有分页信息，及操作分页的函数</li>
<li><code>refreshDeps</code> 变化，会重置 <code>current</code> 到第一页，并重新发起请求，一般可以把 pagination 依赖的条件放这里。</li>
</ul>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><pre><code class="js">const {
    ...,
    // 分页数据及操作分页的方法
    pagination: {
        current: number;
        pageSize: number;
        total: number;
        totalPage: number;
        onChange: (curent: number, pageSize: number) =&gt; void;
        changeCurrent: (current: number) =&gt; void;
        changePageSize: (pageSize: number) =&gt; void
    };
    // 适配 antd table 组件的数据结构，可直接用在 AntD Table 组件上
    tableProps: {
        dataSource: Item[];
        loading: boolean;
        onChange: (
            pagination: any,
            filters?: any,
            sorter?: any,
        ) =&gt; void;
        pagination: {
            current: number;
            pageSize: number;
            total: number;
        }
    }
} = useRequest(service, {
    ...,
    // 是否开启分页模式，开启后service第一个参数为 {current,pageSize,sorter,filters}
    // service 响应结果必须为 {list: Item[], total: number}
    pagnizated,
    // 默认每页的数量，10
    defaultPageSize,
    // 分页模式下，refreshDeps 变化，会重置 current 到第一页，并重新发起请求。一般把依赖条件放这里
    refreshDeps
})</code></pre>
<p><strong>普通分页场景：自动管理 current、pageSize</strong></p>
<pre><code class="tsx">import { useRequest } from &#39;@umijs/hooks&#39;;
import React from &#39;react&#39;;
import { List, Pagination } from &#39;antd&#39;;
import Mock from &#39;mockjs&#39;;

interface UserListItem {
  id: string,
  name: string,
  gender: &#39;male&#39; | &#39;female&#39;,
  email: string,
  disabled: boolean
}

const userList = (current, pageSize) =&gt; (
  Mock.mock({
    total: 55,
    [`list|${pageSize}`]: [{
      id: &#39;@guid&#39;,
      name: &#39;@cname&#39;,
      &#39;gender|1&#39;: [&#39;male&#39;, &#39;female&#39;],
      email: &#39;@email&#39;,
      disabled: false
    }],
  })
)

async function getUserList(params: { current: number, pageSize: number, gender?: string }): Promise&lt;{ total: number, list: UserListItem[] }&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(userList(params.current, params.pageSize))
    }, 1000)
  });
}

export default () =&gt; {
  const { data, loading, pagination } = useRequest(
    ({ current, pageSize }) =&gt; getUserList({ current, pageSize }),
    {
      paginated: true,
    }
  );
  return (
    &lt;div&gt;
      &lt;List
        dataSource={data?.list}
        loading={loading}
        renderItem={(item: any) =&gt; (
          &lt;List.Item&gt;
            {item.name} - {item.email}
          &lt;/List.Item&gt;
        )}
      /&gt;
      &lt;Pagination
        {...(pagination as any)}
        showQuickJumper
        showSizeChanger
        onShowSizeChange={pagination.onChange}
        style={{ marginTop: 16, textAlign: 'right' }}
      /&gt;
    &lt;/div&gt;
  );
};</code></pre>
<p><strong>AntD Table</strong></p>
<p>特别支持了 antd table 所需的分页格式，及 <code>sorter</code>、<code>filters</code> 等。可以通过 <code>result.tableProps</code>、<code>result.params[0]?.filters</code>，<code>result.params[0]?.sorter</code> 访问到这些属性。</p>
<pre><code class="tsx">import { useRequest } from &#39;@umijs/hooks&#39;;
import React from &#39;react&#39;;
import { Table, Button } from &#39;antd&#39;;
import Mock from &#39;mockjs&#39;;

interface UserListItem {
  id: string,
  name: string,
  gender: &#39;male&#39; | &#39;female&#39;,
  email: string,
  disabled: boolean
}

const userList = (current, pageSize) =&gt; (
  Mock.mock({
    total: 55,
    [`list|${pageSize}`]: [{
      id: &#39;@guid&#39;,
      name: &#39;@cname&#39;,
      &#39;gender|1&#39;: [&#39;male&#39;, &#39;female&#39;],
      email: &#39;@email&#39;,
      disabled: false
    }],
  })
)

async function getUserList(params: { current: number, pageSize: number, gender?: string }): Promise&lt;{ total: number, list: UserListItem[] }&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(userList(params.current, params.pageSize))
    }, 1000)
  });
}

export default () =&gt; {
  const { tableProps, params, refresh } = useRequest(({ current, pageSize, sorter: s, filters: f }) =&gt; {
    const p: any = { current, pageSize };
    if (s?.field &amp;&amp; s?.order) {
      p[s.field] = s.order;
    }
    if (f) {
      Object.entries(f).forEach(([filed, value]) =&gt; {
        p[filed] = value;
      });
    }
    console.log(p);
    return getUserList(p);
  }, {
    paginated: true,
    defaultPageSize: 5
  });

  // you can read sorter and filters from params[0]
  const { sorter = {}, filters = {} } = params[0] || ({} as any);

  const columns = [
    {
      title: &#39;name&#39;,
      dataIndex: &#39;name&#39;,
    },
    {
      title: &#39;email&#39;,
      dataIndex: &#39;email&#39;,
    },
    {
      title: &#39;id&#39;,
      dataIndex: &#39;id&#39;,
      sorter: true,
      sortOrder: sorter.field === &#39;id&#39; ? sorter.order : false,
    },
    {
      title: &#39;gender&#39;,
      dataIndex: &#39;gender&#39;,
      filters: [{ text: &#39;male&#39;, value: &#39;male&#39; }, { text: &#39;female&#39;, value: &#39;female&#39; }],
      filteredValue: filters.gender,
    },
  ];

  return (
    &lt;div&gt;
      &lt;Button onClick={refresh} style={{ marginBottom: 16 }}&gt;刷新&lt;/Button&gt;
      &lt;Table columns={columns} rowKey=&quot;id&quot; {...tableProps} /&gt;
    &lt;/div&gt;
  );
};</code></pre>
<p><strong>带缓存的Pagination</strong></p>
<p>在 cacheKey 场景下，run 的参数 params 是可以缓存的，利用这个特点，我们可以实现pagnization 相关条件的缓存。</p>
<pre><code class="tsx">import { useBoolean, useRequest, useUpdateEffect } from &#39;@umijs/hooks&#39;;
import { Button, List, Pagination, Select } from &#39;antd&#39;;
import React, { useState } from &#39;react&#39;;
import Mock from &#39;mockjs&#39;;

interface UserListItem {
  id: string,
  name: string,
  gender: &#39;male&#39; | &#39;female&#39;,
  email: string,
  disabled: boolean
}

const userList = (current, pageSize) =&gt; (
  Mock.mock({
    total: 55,
    [`list|${pageSize}`]: [{
      id: &#39;@guid&#39;,
      name: &#39;@cname&#39;,
      &#39;gender|1&#39;: [&#39;male&#39;, &#39;female&#39;],
      email: &#39;@email&#39;,
      disabled: false
    }],
  })
)

async function getUserList(params: { current: number, pageSize: number, gender?: string }): Promise&lt;{ total: number, list: UserListItem[] }&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve(userList(params.current, params.pageSize))
    }, 1000)
  });
}

export default () =&gt; {
  const { state, toggle } = useBoolean();
  return (
    &lt;div&gt;
      &lt;p&gt;You can click the button multiple times, the conditions of pagination will be cached.&lt;/p&gt;
      &lt;p&gt;
        &lt;Button onClick={() =&gt; toggle()}&gt;show/hidden&lt;/Button&gt;
      &lt;/p&gt;
      {state &amp;&amp; &lt;PaginationComponent /&gt;}
    &lt;/div&gt;
  )
};

const PaginationComponent = () =&gt; {
  const { params, run, data, loading, pagination } = useRequest(
    (p, gender?: string) =&gt; getUserList({ ...p, gender }),
    {
      cacheKey: &#39;paginationDemo&#39;,
      paginated: true
    }
  );

  const [gender, setGender] = useState&lt;string&gt;(params[1]);

  useUpdateEffect(() =&gt; {
      // reload when gender change
      run({
        current: 1,
        pageSize: 10
      }, gender);
  }, [gender])


  return (
    &lt;div&gt;
      &lt;Select
        value={gender}
        style={{ width: 180, marginBottom: 24 }}
        onChange={(g: string) =&gt; setGender(g)}
        placeholder=&quot;select gender&quot;
        allowClear
      &gt;
        &lt;Select.Option value=&quot;male&quot;&gt;male&lt;/Select.Option&gt;
        &lt;Select.Option value=&quot;female&quot;&gt;female&lt;/Select.Option&gt;
      &lt;/Select&gt;
      &lt;List
        dataSource={data &amp;&amp; data.list}
        loading={loading}
        renderItem={item =&gt; (
          &lt;List.Item&gt;
            {item.name} - {item.email}
          &lt;/List.Item&gt;
        )}
      /&gt;
      &lt;Pagination
        {...(pagination as any)}
        showQuickJumper
        showSizeChanger
        onShowSizeChange={pagination.onChange}
        style={{ marginTop: 16, textAlign: 'right' }}
      /&gt;
    &lt;/div&gt;
  );
};</code></pre>
<h3 id="加载更多"><a href="#加载更多" class="headerlink" title="加载更多"></a>加载更多</h3><p>通过设置 <code>options.loadMore=true</code>，useRequest 将以loadMore模式运行，此时会有以下特性：</p>
<ul>
<li>useRequest 会自动管理列表数据，返回的 <code>data.list</code> 为所有请求数据的 list 合并数组。service 的参数为 <code>result.data | undefined</code>。</li>
<li>service 返回的数据结构必须包含 <code>{list: Item[]}</code>，如果不满足，可以通过 <code>options.formatResult</code> 转换一次</li>
<li>useRequest 会额外返回 <code>result.loadingMore</code> 和 <code>result.loadMore</code>。</li>
<li>通过设置 <code>options.ref</code>、<code>options.isNoMore</code>，可以实现上拉加载更多功能。</li>
<li><code>refreshDeps</code>变化，会清空当前数据，并重新发起请求，一般可以把 loadMore 依赖的条件放这里。</li>
</ul>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><pre><code class="js">const {
    ...,
    // 触发加载更多的方法
    loadMore,
    // 是否正在加载更多
    loadingMore,
    // 是否有更多数据，需要配合 options.isNoMore 使用
    noMore,
    // 触发重新加载
    reload
} = useRequest(service, {
    ...,
    // 是否开启加载更多模式
    loadMore,
    // 容器的ref，如果存在，则滚动至底时，自动触发 loadMore
    ref,
    // 判断是否还有更多数据的函数
    isNoMore,
    // 下拉自动加载，距离底部距离阈值
    threshold,
    // refreshDeps变化，会清空当前数据，重新请求
    refreshDeps
})</code></pre>
<p><strong>加载更多-基本用法</strong></p>
<pre><code class="tsx">import { useBoolean, useRequest } from &#39;@umijs/hooks&#39;;
import { Button, Spin, List, Typography } from &#39;antd&#39;;
import React from &#39;react&#39;;


interface Item {
  id?: string,
  name: string
}

interface Result {
  list: Item[],
  nextId: string | undefined
}

const resultData = [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;];

export async function getLoadMoreList(nextId: any, limit: any): Promise&lt;Result&gt; {
  let start = 0;
  if (nextId) {
    start = resultData.findIndex(i =&gt; i === nextId);
  }
  const end = start + limit;
  const list = resultData.slice(start, end).map(id =&gt; ({
    id,
    name: `project ${id} (server time: ${Date.now()})`
  }));
  const nId = resultData.length &gt;= end ? resultData[end] : undefined;
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        list,
        nextId: nId
      });
    }, 1000);
  });
}


export default () =&gt; {
  const { state, toggle } = useBoolean(true);
  return (
    &lt;div&gt;
      &lt;p&gt;You can click the button multiple times, the loadmore will be cached.&lt;/p&gt;
      &lt;p&gt;
        &lt;Button onClick={() =&gt; toggle()}&gt;show/hidden&lt;/Button&gt;
      &lt;/p&gt;
      {state &amp;&amp; &lt;LoadMoreComponent /&gt;}
    &lt;/div&gt;
  )
};

const LoadMoreComponent = () =&gt; {
  const { data, loading, loadMore, loadingMore } = useRequest((d: Result | undefined) =&gt; getLoadMoreList(d?.nextId, 3), {
    loadMore: true,
    cacheKey: &#39;loadMoreDemoCacheId&#39;,
  });

  return (
    &lt;div&gt;
      &lt;Spin spinning={loading}&gt;
        &lt;List
          dataSource={data?.list}
          renderItem={item =&gt; (
            &lt;List.Item key={item.id}&gt;
              &lt;Typography.Text mark&gt;[{item.id}]&lt;/Typography.Text&gt; {item.name}
            &lt;/List.Item&gt;
          )}
        /&gt;
      &lt;/Spin&gt;
      &lt;Button
        onClick={loadMore}
        loading={loadingMore}
        disabled={!data?.nextId}
      &gt;
        click to load more
      &lt;/Button&gt;
    &lt;/div&gt;
  );
};</code></pre>
<p><strong>加载更多-上拉加载</strong></p>
<p>如果options 中存在 ref，则在滚动到底部时，自动触发 loadMore。当然此时必须设置 isNoMore，以便让 useRequest 知道何时停止。</p>
<pre><code class="tsx">import { useRequest } from &#39;@umijs/hooks&#39;;
import { Avatar, Button, List } from &#39;antd&#39;;
import React, { useRef } from &#39;react&#39;;

interface Item {
  id: number;
  title: string;
}

interface Result {
  total: number;
  list: Item[];
}

const dataSource = [
  {
    id: 1,
    title: &#39;Ant Design Title 1&#39;,
  },
  {
    id: 2,
    title: &#39;Ant Design Title 2&#39;,
  },
  {
    id: 3,
    title: &#39;Ant Design Title 3&#39;,
  },
  {
    id: 4,
    title: &#39;Ant Design Title 4&#39;,
  },
  {
    id: 5,
    title: &#39;Ant Design Title 5&#39;,
  },
  {
    id: 6,
    title: &#39;Ant Design Title 6&#39;,
  },
  {
    id: 7,
    title: &#39;Ant Design Title 7&#39;,
  },
  {
    id: 8,
    title: &#39;Ant Design Title 8&#39;,
  },
  {
    id: 9,
    title: &#39;Ant Design Title 9&#39;,
  },
  {
    id: 10,
    title: &#39;Ant Design Title 10&#39;,
  },
];

const asyncFn = ({ pageSize, offset }: any): Promise&lt;Result&gt; =&gt;
  new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        total: dataSource.length,
        list: dataSource.slice(offset, offset + pageSize),
      });
    }, 1000);
  });

export default () =&gt; {
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const { data, loading, loadingMore, reload, loadMore, noMore } = useRequest((d: Result | undefined) =&gt; asyncFn({
    offset: d?.list?.length || 0,
    pageSize: 3,
  }), {
    loadMore: true,
    ref: containerRef,
    isNoMore: d =&gt; (d ? d.list.length &gt;= d.total : false)
  });

  const { list = [] } = data || {};

  const renderFooter = () =&gt; (
    &lt;&gt;
      {!noMore &amp;&amp; (
        &lt;Button onClick={loadMore} loading={loadingMore}&gt;
          {loadingMore ? &#39;Loading more&#39; : &#39;Click to load more&#39;}
        &lt;/Button&gt;
      )}

      {noMore &amp;&amp; &lt;span&gt;No more data&lt;/span&gt;}

      &lt;span style={{ float: 'right', fontSize: 12 }}&gt;total: {data?.total}&lt;/span&gt;
    &lt;/&gt;
  );

  return (
    &lt;div ref={containerRef} style={{ height: 300, overflowY: 'auto' }}&gt;
      &lt;List
        header={
          &lt;Button onClick={reload} loading={loading}&gt;
            Reload
          &lt;/Button&gt;
        }
        footer={!loading &amp;&amp; renderFooter()}
        loading={loading}
        bordered
        dataSource={list}
        renderItem={item =&gt; (
          &lt;List.Item&gt;
            &lt;List.Item.Meta
              avatar={
                &lt;Avatar src=&quot;https://zos.alipayobjects.com/rmsportal/ODTLcjxAfvqbxHnVXCYX.png&quot; /&gt;
              }
              title={&lt;a&gt;{item.title}&lt;/a&gt;}
              desc=&quot;umijs/hooks is a react hooks library&quot;
            /&gt;
          &lt;/List.Item&gt;
        )}
      /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="UseApiProvider"><a href="#UseApiProvider" class="headerlink" title="UseApiProvider"></a>UseApiProvider</h3><p>通过 <code>UseApiProvider</code> 在项目最外层设置全局 options。</p>
<pre><code class="js">import { useApiProvider } from &#39;@umijs/use-request&#39;;

export function ({children}) =&gt; {
    return (
        &lt;UseAPIProvider value={{
              refreshOnWindowFocus: true,
              requestMethod: (params) => axios(params),
              ...
		}}&gt;
          {children}
        &lt;/UseApiProvider&gt;
    )
}</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/07/读书笔记/《Umijs》官方文档/0.目录/">《Umijs》官方文档</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Umijs/">Umijs</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umijs/">Umijs</a></span><div class="content"><ul>
<li>第一部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/1.目录结构与路由/index.html">目录结构与路由</a></li>
<li>第二部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/2.约定式路由/index.html">约定式路由</a></li>
<li>第三部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/3.页面跳转与HTML模板/index.html">页面跳转与 HTML 模板</a></li>
<li>第四部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/4.Mock数据/index.html">Mock 数据</a></li>
<li>第五部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/5.环境变量/index.html">环境变量</a></li>
<li>第六部分 <a href="/2020/04/07/读书笔记/《Umijs》官方文档/6.样式与图片/index.html">样式与图片的引入</a></li>
</ul></div><a class="more" href="/2020/04/07/读书笔记/《Umijs》官方文档/0.目录/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/07/读书笔记/《Umijs》官方文档/1.目录结构与路由/">《Umijs》一、目录结构与路由</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Umijs/">Umijs</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umijs/">Umijs</a></span><div class="content"><h2 id="一、目录结构"><a href="#一、目录结构" class="headerlink" title="一、目录结构"></a>一、目录结构</h2><h3 id="1-env-环境变量"><a href="#1-env-环境变量" class="headerlink" title="1. .env 环境变量"></a>1. <code>.env</code> 环境变量</h3><pre><code class="properties">PORT=8888
COMPRESS=none</code></pre>
<h3 id="2-src-umi-临时目录"><a href="#2-src-umi-临时目录" class="headerlink" title="2. /src/.umi 临时目录"></a>2. <code>/src/.umi</code> 临时目录</h3><p>如入口文件、路由等会临时生成到此。在 dev 和 build 时会被删除并重新生成。</p>
<h3 id="3-src-layouts"><a href="#3-src-layouts" class="headerlink" title="3. /src/layouts"></a>3. <code>/src/layouts</code></h3><p>约定式路由时的全局布局文件。</p>
<h3 id="4-src-app-ts"><a href="#4-src-app-ts" class="headerlink" title="4. /src/app.ts"></a>4. <code>/src/app.ts</code></h3><p>运行时配置文件，可扩展运行时能力，如修改路由、修改 render 方法等。</p>
<h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><p>Umi 属于单页应用，仅加载一次 html，其余所有跳转由浏览器端完成。</p>
<h3 id="1-exact-严格匹配"><a href="#1-exact-严格匹配" class="headerlink" title="1. exact 严格匹配"></a>1. exact 严格匹配</h3><p>type：boolean，default：false</p>
<pre><code class="ts">export default defineConfig({
  routes: [
    { path: &quot;/&quot;, component: &quot;@/pages/index&quot; },
    // 需要完全匹配
    { exact: true, path: &quot;/layout&quot;, component: &quot;@/layout/index&quot; },
  ],
});</code></pre>
<h3 id="2-配置子路由"><a href="#2-配置子路由" class="headerlink" title="2. 配置子路由"></a>2. 配置子路由</h3><pre><code class="ts">export default {
  routes: [
    {
      path: &quot;/&quot;,
      component: &quot;@/layout/index&quot;,
      routes: [
        { path: &quot;/admin&quot;, component: &quot;@/pages/admin&quot; },
        { path: &quot;/user&quot;, component: &quot;@/pages/user&quot; },
      ],
    },
  ],
};</code></pre>
<p>然后在 <code>/src/layout/index</code> 中通过 <code>props.children</code> 渲染子路由</p>
<pre><code class="ts">export default (props) =&gt; {
  return &lt;div&gt;{props.children}&lt;/div&gt;;
};</code></pre>
<p>这样，访问 <code>/admin</code> 和 <code>/user</code> 就会带上 layout 组件。</p>
<h3 id="3-redirect-跳转"><a href="#3-redirect-跳转" class="headerlink" title="3. redirect 跳转"></a>3. redirect 跳转</h3><pre><code class="ts">export default {
  routes: [
    { path: &quot;/&quot;, redirect: &quot;/user&quot; },
    { path: &quot;/user&quot;, component: &quot;@/pages/user&quot; },
  ],
};</code></pre>
<h3 id="4-wrappers"><a href="#4-wrappers" class="headerlink" title="4. wrappers"></a>4. wrappers</h3><p>配置路由的高阶组件封装，如路由级别的权限校验。 type: string[]</p>
<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><pre><code class="ts">export default {
  routes: [
    { path: &quot;/&quot;, component: &quot;@/pages/index&quot;, wrappers: [&quot;@/wrappers/auth&quot;] },
    { path: &quot;/login&quot;, component: &quot;@/pages/login&quot; },
  ],
};</code></pre>
<h4 id="权限校验组件"><a href="#权限校验组件" class="headerlink" title="权限校验组件"></a>权限校验组件</h4><pre><code class="tsx">import React from &quot;react&quot;;
import { history } from &quot;umi&quot;;

const auth = (props: any) =&gt; {
  const random = Math.random();
  if (random &gt; 0.5) {
    history.push(&quot;/login&quot;);
  }

  return &lt;div&gt;{props.children}&lt;/div&gt;;
};

export default auth;</code></pre>
<blockquote>
<p>这样，访问 <code>/</code> 时，就会通过 <code>auth</code> 组件的权限校验，如果通过则渲染 <code>src/pages/index</code>，否则跳转至登录页。</p>
</blockquote>
<h3 id="5-路由组件参数"><a href="#5-路由组件参数" class="headerlink" title="5. 路由组件参数"></a>5. 路由组件参数</h3><p>路由组件可通过 <code>props</code> 获取到以下属性：</p>
<ul>
<li>match，当前路由和 url match 后的对象，包含 <code>params</code>、<code>path</code>、<code>url</code>和 <code>isExact</code></li>
<li>location，应用当前处于哪个位置，包含 <code>pathname</code>、<code>search</code>、<code>query</code>等属性</li>
<li>history</li>
<li>route，路由配置，包含<code>path</code>、<code>exact</code>、<code>component</code>、<code>routes</code>等</li>
</ul>
<h3 id="6-传递参数给子路由-cloneElement"><a href="#6-传递参数给子路由-cloneElement" class="headerlink" title="6. 传递参数给子路由 cloneElement"></a>6. 传递参数给子路由 cloneElement</h3><pre><code class="tsx">import React from &quot;react&quot;;

export default (props: any) =&gt; {
  return React.Children.map(props.children, (child) =&gt; {
    return React.cloneElement(child, { foo: &quot;bar&quot; });
  });
};</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/07/读书笔记/《Umijs》官方文档/2.约定式路由/">《Umijs》二、约定式路由</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Umijs/">Umijs</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Umijs/">Umijs</a></span><div class="content"><h2 id="一、约定式路由"><a href="#一、约定式路由" class="headerlink" title="一、约定式路由"></a>一、约定式路由</h2><p>约定式路由也叫文件路由，即不需要配置，文件系统即路由。通过目录和文件及其命名分析出路由配置。</p>
<h3 id="1-文件路由"><a href="#1-文件路由" class="headerlink" title="1. 文件路由"></a>1. 文件路由</h3><p><strong>如果没有 routes 配置，Umi 会进入约定式路由模式。</strong>，然后分析 <code>src/page</code> 目录拿到路由配置。</p>
<blockquote>
<p>注意：以下规则文件，不会被注册为路由</p>
<ol>
<li>以 <code>.</code> 或 <code>_</code> 开头的文件</li>
<li>以 <code>d.ts</code> 结尾的类型定义文件</li>
<li>以 <code>test.ts</code>、<code>spec.ts</code>、<code>e2e.ts</code> 结尾的测试文件(适用于 <code>.js</code>、<code>.jsx</code>、<code>.tsx</code>)</li>
<li><code>components</code> 目录和 <code>component</code> 目录</li>
<li><code>utils</code> 和 <code>util</code> 目录</li>
<li>非 <code>.js</code>、<code>.jsx</code>、<code>.ts</code>、<code>.tsx</code> 文件</li>
<li>文件内容不包含 JSX 元素</li>
</ol>
</blockquote>
<h3 id="2-动态文件路由"><a href="#2-动态文件路由" class="headerlink" title="2. 动态文件路由"></a>2. 动态文件路由</h3><p>约定 <code>[]</code> 包裹的文件或文件夹为动态路由。</p>
<h3 id="3-全局-layout"><a href="#3-全局-layout" class="headerlink" title="3. 全局 layout"></a>3. 全局 layout</h3><p>约定 <code>src/layouts/index.tsx</code> 为全局路由。返回一个 React 组件，并通过 <code>props.children</code> 渲染子组件。</p>
<h3 id="4-不同的全局-layout"><a href="#4-不同的全局-layout" class="headerlink" title="4. 不同的全局 layout"></a>4. 不同的全局 layout</h3><p>如果需要针对不同路由输出不同的全局 layout，您可以在 <code>src/layout/index.tsx</code> 中对 <code>location.path</code> 做区分，来渲染不同的 layout。</p>
<h3 id="5-404-路由"><a href="#5-404-路由" class="headerlink" title="5. 404 路由"></a>5. 404 路由</h3><p>约定 <code>src/pages/404.tsx</code> 为 404 页面，需返回 React 组件。</p>
<h3 id="6-扩展路由属性"><a href="#6-扩展路由属性" class="headerlink" title="6. 扩展路由属性"></a>6. 扩展路由属性</h3><p>支持在代码层通过导出静态属性的方式扩展路由。</p>
<pre><code class="tsx">function HomePage() {
  return &lt;h1&gt;Hello World!&lt;/h1&gt;;
}

HomePage.title = &#39;首ye&#39;;

export default HomePage;</code></pre>
<p>其中 <code>title</code> 会附加到路由配置中。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>