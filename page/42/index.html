<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives/index.html"><span class="pull-left">文章</span><span class="pull-right">239</span></a><a class="author-info-articles__tags article-meta" href="/tags/index.html"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories/index.html"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives/index.html">归档</a><a class="site-page" href="/tags/index.html">标签</a><a class="site-page" href="/categories/index.html">分类</a><a class="site-page" href="/about/index.html">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/30/分布式/SpringBoot/SpringBoot/index.html">SpringBoot QA</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/index.html">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/index.html">SpringBoot</a></span><div class="content"><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1-RestController-和-Controller"><a href="#1-RestController-和-Controller" class="headerlink" title="1. @RestController 和 @Controller"></a>1. @RestController 和 @Controller</h2><pre><code class="java">@RestController : 将所有返回的结果以字符串形式返回
@Controller ：返回结果由视图解析器返回视图</code></pre>
<h2 id="2-SpringBootApplication"><a href="#2-SpringBootApplication" class="headerlink" title="2. @SpringBootApplication"></a>2. @SpringBootApplication</h2><blockquote>
<p>是SpringBoot的核心注解，目的是开启自动配置。</p>
</blockquote>
<p>关闭自动配置：@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})</p>
<p>运行原理：相当于是以下注解的集合：</p>
<pre><code class="java">@Target(Element.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documentd
@Inherited
@Import({EnableAutoConfigurationImportSelector.class,AutoConfigurationPackages.Register.class})</code></pre>
<h2 id="3-Thymeleaf模板引擎-同Freemarker"><a href="#3-Thymeleaf模板引擎-同Freemarker" class="headerlink" title="3. Thymeleaf模板引擎(同Freemarker)"></a>3. Thymeleaf模板引擎(同Freemarker)</h2><ol>
<li>通过 <code>xmlns:th=http://www.thymeleaf.org</code> 命名空间，转换位动态视图；</li>
<li>使用 <code>“@{}”</code> 方式引用web静态资源</li>
<li>通过“${}”访问model中的属性，如：<span th:text="${singlePerson.name}"></span><br>注：需要处理的动态内容需要加上“th：”前缀</li>
<li>迭代：使用“th：each”，如：th:each=”person:${person}”  其中person作为迭代元素使用</li>
<li>数据判断： <code>th:if=&quot;${not #lists.isEmpty(people)}&quot;</code></li>
<li>js中访问model  </li>
</ol>
<pre><code class="javascript">&lt;script th:inline=&quot;javascript&quot;&gt; 
    var singlePerson=[[${singlePerson}]]
&lt;script&gt;</code></pre>
<blockquote>
<p>使用 <code>th:inline=&quot;javascript&quot;</code> 使js能够访问model<br>通过[[${}]]获取实际的值</p>
</blockquote>
<h2 id="4-注册Servlet、Filter、Listener"><a href="#4-注册Servlet、Filter、Listener" class="headerlink" title="4. 注册Servlet、Filter、Listener"></a>4. 注册Servlet、Filter、Listener</h2><p>Servlet:ServletRegistrationBean</p>
<pre><code class="java">@Bean
public ServletRegistrationBean serbletRegistrationBean(){
    //直接注册servlet及其请求路径
    return new ServletRegistrationBean(new XXServlet(),&quot;/xx/*&quot;);
}</code></pre>
<p>Filter:FilterRegisterationBean</p>
<pre><code class="java">@Bean
public FilterRegisterationBean filterRegisterationBean(){
    //设置过滤器
    FilterRegisterationBean filterRegisterationBean = new filterRegisterationBean.setFilter(new YYFilter());
    //执行顺序  
    filterRegisterationBean.setOrder(2);
    filterRegisterationBean.setName(&quot;MyFilter&quot;);//设置名称
    filterRegisterationBean.setUrlPatterns(&quot;/*&quot;);//设置过滤路径
    return filterRegisterationBean;
}</code></pre>
<p>Listener:ServletListenerRegisterationBean</p>
<pre><code class="java">@Bean
public ServletListenerRegisterationBean&lt;ZZListener&gt; servletListenerRegisterationBean(){
    return new ServletListenerRegisterationBean&lt;ZZListener&gt;(new ZZListener);
}</code></pre>
<h2 id="5-修改tomcat、jetty、undertow"><a href="#5-修改tomcat、jetty、undertow" class="headerlink" title="5.修改tomcat、jetty、undertow"></a>5.修改tomcat、jetty、undertow</h2><p>直接在pom文件中，修改依赖</p>
<pre><code class="java">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; //将web对应的服务器修改为其它
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
  &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
  &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="6-WebSocket"><a href="#6-WebSocket" class="headerlink" title="6. WebSocket"></a>6. WebSocket</h2><h3 id="1-websocket的配置"><a href="#1-websocket的配置" class="headerlink" title="1. websocket的配置"></a>1. websocket的配置</h3><ol>
<li>使用@Configuration及@EnableWebSocketMessageBroker  来开启WebSocket支持</li>
<li>继承AbstratWebSocketMessageBrokerConfigurer类<ol>
<li>重写 <code>registerStomEndpoint(StomEndpointRegister)</code> 与 <code>configureMessageBroker(essageBrokerRegistry)</code> 方法</li>
<li><code>Sregistry.addEndpoint(&quot;/endpointWisely&quot;).withSockJS()</code>;  即通过endpointWisely连接SockJs</li>
<li>Mregistry.enableSimpleBroker(“/topic”);  配置一个topic消息代理</li>
</ol>
</li>
</ol>
<h3 id="2-wscontroller"><a href="#2-wscontroller" class="headerlink" title="2. wscontroller"></a>2. wscontroller</h3><p>@MessageMapping(“/welcome”) 同RequestMapping,映射地址</p>
<p>@SendTo(“/topic/getResponse”) 当服务端有消息时，会对订阅了”/topic/getResponse”的客户端发送消息</p>
<pre><code class="java">public WiselyResponse say(WiselyMessage message) throws Exception{
    return new WiselyResponse(&quot;Welcome &quot; +message.getName()+&quot; ! &quot;);  返回发送的消息
}</code></pre>
<h3 id="3-ws-html"><a href="#3-ws-html" class="headerlink" title="3. ws.html"></a>3. ws.html</h3><pre><code class="javascript">//连接并订阅
var socket = new SockJS(&#39;/endpointWisely&#39;);  //连接名称为“。。。”的endpoint
var stompClient = Stomp.over(socket);     //使用stomp子协议
    stompClient.connect({},function(name){
        stompClient.subscribe(&#39;topic/getResponse&#39;,function(response){//订阅
        show();//自定义的展示方法
    })
})
stompClient.send(&quot;/welcome&quot;,{},JSON.stringify({&#39;name&#39;:name}));//发送消息</code></pre>
<h2 id="7-Spring-Data-JPA"><a href="#7-Spring-Data-JPA" class="headerlink" title="7.Spring Data JPA"></a>7.Spring Data JPA</h2><h3 id="1-EnableJpaRepositories"><a href="#1-EnableJpaRepositories" class="headerlink" title="1. @EnableJpaRepositories"></a>1. @EnableJpaRepositories</h3><pre><code>使用@EnableJpaRepositories(&quot;com.wisely.repos&quot;)来开启Spring Data JPA支持 其中的value参数用来扫描数据访问层所在包下的数据访问的接口定义</code></pre><h3 id="2-定义查询方法"><a href="#2-定义查询方法" class="headerlink" title="2. 定义查询方法"></a>2. 定义查询方法</h3><blockquote>
<p><code>常规查询</code> ：find、read、readBy、query、queryBy、get、getBy<br><code>查询关键字</code> ：And(和)、Or(或)、Is = Equals(等)、Between(位于之间)、LessThan(小于)、LessThanEqual(小于等于)<br>GreaterThan(大于)、GreaterThanEqual(大于等于)、After(日期大于)、Before(日期之前)<br>IsNull、IsNotNull = NotNull、Like、Not Like、Starting With(前面加%)<br>EndingWith(后面加%)、Containing(前后都加%)、OrderBy(排序)、Not、In<br>NotIn、True、False、IgnoreCase<br><code>限制查询结果</code> ：Top、First<br><code>@NamedQuery</code> : 一个名称映射一个查询语句<br>    eg:    @NamedQuery(name = “Person.findByName”,query = “select p from Person p where p.name=?1”)<br>        写在实体类名上<br>@Query查询<br>    直接在@Query的value中书写sql语句，参数可以使用索引(“?1”)或者命名(“:name”)<br>更新查询：使用@Modifying 和 @Query 来组合更新查询</p>
</blockquote>
<h3 id="3-排序与分页"><a href="#3-排序与分页" class="headerlink" title="3. 排序与分页"></a>3. 排序与分页</h3><pre><code>Sort排序对象：     List&lt;Person&gt; findByName(String name,Sort sort);
Pageable对象：    List&lt;Person&gt; findByName(String name,Pageable pageable);
使用：    List&lt;Person&gt; persons = personRepository.findByName(&quot;xx&quot;,new Sort(Direction.ASC,&quot;age&quot;));
        List&lt;Person&gt; persons = personRepository.findByName(&quot;xx&quot;,new Pageable(0,10));</code></pre><h3 id="4-repository默认的方法："><a href="#4-repository默认的方法：" class="headerlink" title="4. repository默认的方法："></a>4. repository默认的方法：</h3><pre><code>save()    保存；        
findAll()    查询所有；        
findAll(new Sort(Sort.Direction.ASC,&quot;age&quot;))        排序查询所有；
findAll(new PageRequest(0,10))        分页查询；
findAll(new PageRequest(1,2,new Sort(Sort.Direction.DESC,&quot;age&quot;)))    分页排序</code></pre><h2 id="8-SpringBoot的注解式事务-Transactional"><a href="#8-SpringBoot的注解式事务-Transactional" class="headerlink" title="8.SpringBoot的注解式事务  @Transactional"></a>8.SpringBoot的注解式事务  @Transactional</h2><pre><code>属性：
    1.propagation 定义事务的生命周期
        REQUIRED             如果没有事务则新建
        REQUIRED_NEW        始终开启新事务
        SUPPORTS            有就用，没有就不用
        NESTED                类似于REQUIRED_NEW，但是不支持jps与hibernate
        NOT_SUPPORTS        不在事务中执行
        NEVER                强制不在事务中执行，有事务则抛出异常
        MANDATORY            强制在事务中执行，没有则抛出异常
    2.isolation  事务的隔离机制，决定了事务的完整性
        READ_UNCOMMITED      读不提交(脏读、幻读、不可重复读)
        READ_COMMITED        读提交(不可重复读和幻读)，解决脏读
        REPEATABLE_READ        A读取某条数据时，B不许修改(幻读)
        SERIALIZABLE        序列化
    3.timeout    事务过期时间
    4.readOnly    指当前事务是否是只读事务
    5.rollbackFor    指定哪个异常会回滚
    6.noRollBackFor    指定哪个异常不会回滚</code></pre><p>1.@GetMapping注解：相当于 @RequestMapping(Method=RequestMethod.GET)<br>    该注解将HTTP GET映射到特定的方法上<br>2.@RequestParam注解：将Request参数绑定到处理函数的参数中<br>    如：public String getUserId(@RequestParam(“id”) int id); 这样就可以将localhost:8080/?id=123中的id参数赋给方法中的id<br>3.@JsonIgnoreProperties(ignoreUnknown = true)<br>    将这个注解卸载类上之后，就会忽略类中不存在的字段<br>    使用@JsonIgnoreProperties({“internalId”,”secretKey”})指定的字段不会被序列化和反序列化<br>4.数据校验<br>    1.在实体类的属性前添加如：@NotEmpty、@Min(value=18,message=”未成年禁止入内”)等<br>    2.在Controller层的方法，要校验的参数上添加@Valid注解<br>        如果需要返回错误信息，则需要传入BindingResult对象，用于获取校验失败情况下的反馈信息<br>5.ModelMapper对象<br>    一个从对象到对象的框架，能将javaBean对象从一种表现形式转化为另一种表现形式，采用“约定”来配置<br>    eg:        Person person = modelMapper.map(personDTO,Person.class);            //将PersonDTO的对象，转换成Person对象<br>            Person personInDB = personService.getById(userId,PersonDTO.getId())    //在service层对userid和person.id做了处理，从数据库取出person.id对应的Person，userid则是权限判断<br>            return modelMapper.map(personService.save(userId,person),PersonDTO.class);    //再将保存返回的person转为personDTO<br>6.@PathVariable注解<br>    可以绑定占位符传过来的值到方法的参数上<br>7.@RequestMapping的变形<br>    @GetMapping、@PostMapping、@PutMapping、@DeleteMapping<br>8.@RequestParam和@PathVariable的区别<br>    1.@RequestParam和@PathVariable都是从request中接收请求的，都可以接收参数<br>    2.@RequestParam  支持defaultValue（默认值）、name、value、required参数<br>    3.@PathVariable  能够识别URL里面的一个模板 eg:@RequestMapping(“/hello/{id}”)<br>    4.@PathParam     同@PathVariable，但是属于JBoss的<br>    5.@QueryParam     同@RequestParam,属于JAX-RS<br>    6.@ResponseBody  服务器返回的时候以一种什么样的方式进行返回<br>    7.@RequestBody<br>9.@Documentd注解<br>    映射实体类与MongoDB文件<br>10.http状态码<br>    1XX 临时响应，并需要请求者继续执行操作的状态代码<br>    2XX 请求成功<br>    3XX 重定向代码<br>    4XX 表示请求出错<br>    5XX 服务器内部错误<br>11.自定义注解<br>    @Retention注解<br>        定义被它所注解的注解保留多久，一共有三种策略：<br>            public enum RetentionPolicy{<br>                SOURCE,CLASS,RUNTIME<br>            }<br>        1.SOURCE  被编译器忽略<br>        2.CLASS  注解会被保留在Class文件中，但在运行时并不会被vm保留(默认)<br>        3.RUNTIME  保留至运行时，可以通过反射去获取注解信息。<br>    @Target注解<br>        说明该注解可以被声明在哪些元素之前<br>            public enum ElementType{<br>                TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,<br>                ANNOTATION_TYPE,PACKAGE,TYPE_PARAMETER,TYPE_USE<br>            }<br>        1.TYPE  类之前<br>        2.FIELD  类的字段前<br>        3.METHOD  类的方法前<br>        4.PARAMETER  方法参数前<br>        5.CONSTRUCTOR  构造方法前<br>        6.LOCAL_VARIABLE  局部变量之前<br>        7.ANNOTATION_TYPE  注解类型之前<br>        8.PACKAGE  包名前<br>12.Spring框架下的AOP Annotation<br>    1.切入点语法：<br>        execution(public * * (..))<br>        execution(* set* (..))<br>        execution(* com.xyz.servie.AccountService.* (..))<br>        execution(* com.xyz.service.<em>.</em> (..))<br>        within(com.xyz.service.<em>)    //service包中<br>        within(com.xyz.service..</em>)    //service或其子包<br>    2.声明通知<br>        1.@Before 前置通知<br>        2.@AfterReturning  后置通知<br>        3.AfterThrowing  异常通知，在一个方法抛出异常后执行<br>        4.@After  最终通知，必会执行的<br>        5.@Around  环绕通知，在方法执行前及执行后，常用于线程安全的情况下，共享数据<br>13.Spring Security<br>    1.安全处理方法：<br>        1.access(String)                Spring EL表达式结果为true时可访问<br>        2.anonymouns()                    匿名可访问<br>        3.denyAll()                        用户不能访问<br>        4.fullyAuthenticated()            用户完全认证可访问(非remeber me)<br>        5.hasAnyAuthority(String..)        如果用户有参数，则其中任一权限可访问<br>        6.hasAnyRole(String..)                    如果用户有参数，则其中任一角色可访问<br>        7.hasAuthority(String)            如果用户有参数，则其权限可访问<br>        8.hasRole(String)                若用户由参数中的角色可访问<br>        9.permitAll()                    用户可任意访问<br>        10.rememberMe()                    允许通过remember-me登陆的用户访问<br>        11.authenticated()                用户登陆后可访问<br>14.JMS<br>    1.安装ActiveMQ<br>    2.在application.properties中配置ActiveMQ的消息代理地址<br>        spring.activemq.broker-url=tcp://localhost:61616<br>    3.定义发送端<br>        需要实现MessageCreator接口，并重写其createMessage方法<br>        eg:     class Msg implements MessageCreator{<br>                    @override<br>                    public Message createMessage() throws JMSException{<br>                        return session.createTextMessage(“发送了消息”);<br>                    }<br>                }<br>    4.定义发送及目的地<br>        1.使用CommandLineRunner接口，用于程序启动后执行的代码，通过重写其run方法执行<br>        2.注入Springboot提供的JmsTemplate的Bean<br>        3.通过JmsTemplate的send方法向 “my-destination” 目的地发送Msg 的消息<br>        eg:        class Ch934Application implements CommandLineRunner{<br>                    @AutoWired<br>                    JmsTemplate jmsTemplate;</p>
<pre><code>                @Override
                public void run(String... args) throws Exception{
                    jmsTemplate.send(&quot;my-destination”,new Msg());
                }
            }
    4.定义消息监听
        使用@JmsListener注解，来简化JMS开发。只需要在这个注解的属性destination指定要监听的目的地，即可接收该目的地发送的消息。
    eg:        class Receiver{
                @JmsListener(destination = &quot;my-destination”)
                public void receiveMessage(String message){
                    sout(&quot;收到：&quot;+message+&quot;，消息&quot;)
                }
            }














    #SpringBoot的配置文件.properties</code></pre><h1 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h1><pre><code>logging.config=classpath:logback-spring.xml</code></pre><h1 id="Mysql-Configuration"><a href="#Mysql-Configuration" class="headerlink" title="Mysql Configuration"></a>Mysql Configuration</h1><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/pgc                          #数据库地址
spring.datasource.username=root                                                #账号
spring.datasource.password=password                                            #密码</code></pre><h1 id="Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production"><a href="#Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production" class="headerlink" title="Keep the connection alive if idle for a long time (needed in production)"></a>Keep the connection alive if idle for a long time (needed in production)</h1><pre><code>spring.datasource.testWhileIdle=true                                        #指定连接是否被空闲来连接回收器检验
spring.datasource.validationQuery=SELECT 1                                    #验证从连接池取出的连接</code></pre><h1 id="Show-or-not-log-for-each-sql-query"><a href="#Show-or-not-log-for-each-sql-query" class="headerlink" title="Show or not log for each sql query"></a>Show or not log for each sql query</h1><pre><code>spring.jpa.show-sql=true                                                    #运行时输出sql语句</code></pre><h1 id="Hibernate-ddl-auto-save-save-drop-update"><a href="#Hibernate-ddl-auto-save-save-drop-update" class="headerlink" title="Hibernate ddl auto (save, save-drop, update)"></a>Hibernate ddl auto (save, save-drop, update)</h1><pre><code>spring.jpa.hibernate.ddl-auto=update                                        #hibernate数据定义的规则，更新</code></pre><h1 id="Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’"><a href="#Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’" class="headerlink" title="Set to true if we need to populate the database using ‘data.sql’."></a>Set to true if we need to populate the database using ‘data.sql’.</h1><pre><code>spring.datasource.initialize=false                                            #指定初始化数据源，是否用data.sql来初始化，默认: true</code></pre><h1 id="Naming-strategy"><a href="#Naming-strategy" class="headerlink" title="Naming strategy"></a>Naming strategy</h1><pre><code>spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy    #指定命名策略</code></pre><h1 id="The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database"><a href="#The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database" class="headerlink" title="The SQL dialect makes Hibernate generate better SQL for the chosen database"></a>The SQL dialect makes Hibernate generate better SQL for the chosen database</h1><pre><code>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect    #hibernate方言</code></pre><h1 id="Mongodb-Configuration"><a href="#Mongodb-Configuration" class="headerlink" title="Mongodb Configuration"></a>Mongodb Configuration</h1><pre><code>spring.data.mongodb.uri=mongodb://localhost:27000/pgc                        #mongodb的uri</code></pre><h1 id="OSS-Configuration"><a href="#OSS-Configuration" class="headerlink" title="OSS Configuration"></a>OSS Configuration</h1><pre><code>oss.endpoint=oss-cn-shanghai.aliyuncs.com                                    #oss阿里云的相关配置
oss.access.key.id=LTAIxYKpaBqbAIK3
oss.access.key.secret=WuTDXWS8PBqSdqMuMxrPfT5ryYmmd0
oss.bucket.name=new-pgc
spring.http.multipart.maxFileSize=100MB
spring.http.multipart.maxRequestSize=100MB</code></pre><h1 id="SSO-Configuration"><a href="#SSO-Configuration" class="headerlink" title="SSO Configuration"></a>SSO Configuration</h1><pre><code>security.enabled=true</code></pre><p>#默认callback<br>    security.defaultCallback=/</p>
<p>#sso验证token地址<br>    security.ssoServerValidate=<a href="http://106.15.179.107:7127/api/c/sso/validate-token" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/validate-token</a></p>
<p>#如果本地应用没有登陆就去验证<br>    security.ssoServerAuth=<a href="http://106.15.179.107:7127/api/c/sso/auth" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/auth</a></p>
<p>#本地应用密码<br>    security.ssoKey=574163310</p>
<p>#本地应用地址, should be defined by the same field under each app</p>
<h1 id="security-appHost-http-localhost-8000"><a href="#security-appHost-http-localhost-8000" class="headerlink" title="security.appHost=http://localhost:8000"></a>security.appHost=<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a></h1><p>#gizp<br>    spring.resources.chain.gzipped=true</p>
<p>注：<br>1.Java Web获取IP，及ip所在地址<br>    在请求头getHeader()中，”x-forwarded-for”、”Proxy-Client-IP”、”WL-Proxy-Client-IP”<br>    请求地址:getRemoteAddr();<br>2.请求参数与路径变量<br>    1.请求参数<br>        采用key = value形式，并用 “&amp;” 分隔<br>            eg:localhost:8080/user?name=spring&amp;pwd=123<br>        在传统的servlet中，可以通过HttpServletRequest的getParameter()方法取值<br>        在SpringMVC中则提供了一个注解”@RequestParam”来注释方法参数<br>    2.路径参数<br>        类似请求参数，但是没有key部分，只是一个值<br>            eg:localhost:8080/user/spring<br>        为了使用路径变量，首先需要在@RequestMapping注解的值属性中添加一个变量，该变量必须放在花括号之间<br>            eg:@RequestMapping(value=”/user/{pwd}”)<br>        使用时，在方法签名中加上@PathVariable注解<br>            eg:public String test(@PathVariable(name=”pwd”) string password)<br>3.lambda表达式<br>    1.用lambda实现Runnable<br>        new Thread( () -&gt; sout(“Lambda expression rocks！！”) ).start();<br>        等价于：<br>        new Thread(<br>            new Runnable(){<br>                @Override<br>                public void run(){<br>                    sout(“Lambda expression rocks！！”) ;<br>                }<br>            }<br>        ).start();<br>    2.对列表进行迭代<br>        list.forEach( n -&gt; sout(n) );<br>        如果输出和参数相同，则可以省略参数<br>        list.forEach( System.out::println() );<br>    3.函数式接口Predicate<br>        可以向API添加逻辑，用更少的代码支持更多的动态行为。<br>        eg:    public void filter(String name,Predicate condition){<br>                if(condition.test(name)){<br>                    sout(name+” “);<br>                }<br>            }<br>        那么在调用时，我们就可以通过predicate来进行判断<br>        eg:<br>            List languages = Arrays.asList(“Java”, “Scala”, “C++”, “Haskell”, “Lisp”);<br>            filter(langugages,str -&gt; str.startWith(“J”));<br>    4.Map和Reduce(是Stream的方法)<br>        1.map允许你将对象进行转换，将列表中的每个元素转换为修改之后的值。<br>        eg:    List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>            costBeforeTax.stream().map( (cost)-&gt;cost+.12<em>cost )<br>                                        .forEach(System.out::println);<br>        2.reduce可以对所有值进行合并，比较类似SQL中的sum()、avg()、count()等<br>        eg:对修改后的数据进行计算，接收多个值，返回一个值<br>            costBeforeTax.stream().map( (cost)-&gt;cost+.12</em>cost )<br>                                        .reduce( (sum,cost)-&gt; sum+cost).get();<br>    5.filter过滤<br>        使用lambda表达式和流API过滤大规模数据集合，流提供了一个filter()方法，接受一个Predicate对象，即可以传入一个lambda表达式作为过滤逻辑<br>        eg:    List<string> filtered = strList.stream().filter( x-&gt; x.length()&gt;10).collect(Collectors.toList);<br>            得到的结果为：过滤后的strList，长度都是大于10的<br>    6.distinct()去重<br>        numbers.stream().distinct().collect(Collectors.toList);<br>    7.集合的最大值、最小值、总和及平均值<br>        IntStream、LongStream和DoubleStream等流的类中，有个方法叫做summaryStatistics()，可以返回IntSummaryStatistics、LongSummaryStatistics或者DoubleSummaryStatistic<br>        eg:    IntSumnumberList stats = numberList.stream().mapToInt((x)-&gt;x).summaryStatistics()<br>            stats存在    getMax、getMin、getSum、getAverage、getCount方法<br>    8.Lambda表达式与匿名类<br>        this关键字：<br>            匿名类的this关键字指向匿名类<br>            lambda表达式的this关键字指向包围lambda表达式的类<br>        编译方式：<br>            java编译器将lambda表达式编译成类的私有方法，使用java7的invokedynamic字节码指令来动态绑定这个方法。<br>    9.限制：<br>        1.lambda表达式只能引用final或final局部变量，即在lambda内部不能修改定义在域外的变量。<br>    10.避免Null<br>        当出现多层嵌套时，调用其中的方法可能会抛出NullPointException异常,所以我们可以通过Optional类型来预防null检查<br>        eg:new Outer().getNested().getInner().getFoo()中可能会出现Null异常<br>            修改过后：<br>            Optional.of(new Outer())<br>                    .map(Outer::getNested)<br>                    .map(Nested::getInner)<br>                    .map(Inner::getFoo)<br>                    .ifPresent(System.out::println);<br>    11.Optional类<br>        是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象。<br>        Optional是个容器，它可以保存类型T的值，或者仅仅保存null。<br>        Optional类的引入很好的解决空指针异常。<br>4.Git使用规范流程<br>    1.新建分支<br>        每次开发新功能，都应该新建一个单独的分支<br>        #获取主分支最新代码<br>            git checkout master<br>            git pull<br>        #新建一个开发分支<br>            git checkout -b myfeature<br>    2.提交分支commit<br>        分支修改后，就可以提交commit了<br>            git add -all            #all表示保存所有变化，也是默认的<br>            git status                #查看发生变动的文件<br>            git commit –verbose    #verbose参数，会列出diff的结果<br>    3.撰写提交信息<br>        提交commit时，必须给出完整的提交信息<br>         eg：第一行是不超过50字的提要<br>             空一行<br>             *罗列出改动原因、主要变动、需要注意的问题（可多行）<br>             空一行<br>             提供对应的网址<br>    4.与主干同步<br>        git fetch master<br>    5.合并commit<br>        分支开发完成后，可能有一堆commit，但是合并到主干时，最好只有一个commit，清晰易管理<br>            git rebase -i origin/master        #i参数表示互动，此时会打开一个互动界面<br>        可用的命令：<br>            1.pick        #正常选中<br>            2.reword    #选中，并且修改提交信息<br>            3.edit        #钻中，rebase时会暂停，允许你修改这个commit<br>            4.squash    #选张，会将当前commit与上一个commit合并<br>            5.fixup        #与squash相同，但不会保存当前commit的提交信息<br>            6.exec        #执行其他shell命令<br>        其中，squash和fixup可以用来合并commit<br>        另外，PonyFoo提出另一种合并commit的简洁方法，就是先撤销过去5个commit，再建一个新的<br>            git reset HEAD~5<br>            git add<br>            git commit -am “Here’s the bug fix that closes #28”<br>            git push –force<br>    6.推送到远程仓库<br>        合并commit之后，就可以推送当前分支到远程仓库了<br>            git push –force origin myfeature<br>        “–force”表示强行推送，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，可能需要强行推送<br>    7.发出Pull Request<br>        提交到远程仓库以后，就可以发出Pull Request到master分支，然后请求别人进行代码review，确认可以合并到master</string></p>
<p>4.2    Git分支管理策略<br>    Vincent Driessen提出了一个分支管理的策略，使得版本库的演进保持简洁，主干清晰。<br>    1.主分支Master<br>        代码库有且仅有的一个主分支，提供给用户使用的正式版本，都在此分支上发布<br>    2.开发分支Develop<br>        这个分支可以用来生成代码的最新隔夜版本(nightly)，如果想正式对外发布，就在Master分支上，对Develop分支进行合并(merge)<br>        git merge –no-ff develop<br>    3.临时性分支<br>        1.feature     功能分支<br>        2.release    预发布分支<br>        3.fixbug    修补bug分支<br>        这三种分支都属于临时性需要，使用完以后，应该删除，代码库的常设分支只有Master和Develop</p>
<ol start="5">
<li>组合(Composition)与聚合(Aggregation)的区别<br>1.Composition 表示的是’Part-od’的关系<br>  比如：引擎Engine是汽车Car的一部分，脱离了汽车的引擎毫无作用，没有实在的意义<br>2.而Aggregation表示的是’Has-a’的关系<br>  比如：Person有一个Address，但是Address的存在不依赖于Person，即地址本身就有其独立存在的意义，不受人的约束。<br>3.就强弱关系而言：<br>  Composition应该更强一些</li>
<li>交并补<br>  1.List集合的交并补<pre><code>  list1.addAll(list2);    //并集
  list1.retainAll(list2);    //交集,返回Boolean
  list1.removeAll(list2);    //差集
  list2.removeAll(list1);
  list1.addAll(list2);    //无重复并集</code></pre></li>
<li>SpringMVC迁移至SpringBoot</li>
</ol>
<p>8.lucene和solr<br>    1.lucene<br>        lucene是一个开放源代码的 全文检索 引擎工具包,并不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本引擎。目的在于为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以此为基础建立起完整的全文检索引擎。</p>
<pre><code>2.solr
    是一个高性能，给予lucene的全文搜索服务器。同时对其进行了拓展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可拓展并对查询性能进行了优化，并且提供了一个完整的功能管理界面，是一款非常优秀的全文搜索引擎。它对外提供类似于WebService的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Solr Get操作提出查找请求，并得到XML格式的返回结果、

3.Solr和Lucene的区别
    1.搜索服务器：
        lucene本质上是搜索库，不是独立的应用程序
    2.企业级
        lucene专注于搜索底层的建设，而Solr专注于企业应用。
    3.管理
        lucene不负责支撑搜索服务所必须的管理
    一句话总结：Solr是Lucene面向企业搜索应用的扩展</code></pre><p>9.Gradle<br>    1.简介：<br>        是一个基于JVM的构建工具</p>
<p>10.Nginx<br>    1.反向代理-解决前端跨域问题<br>        跨域-浏览器为了安全问题而限制了跨域访问，如果a，b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的。<br>        由配置来完成：<br>            1.让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。<br>            2.配置一个特殊的’/api’目录的访问，并且对url执行了重写<br>                rewrite ^/api/(.*)$/$1 break;<br>            代表重写拦截进来的请求，并且只能对域名后边以’/api’开头的起作用，break表示匹配一个之后停止匹配</p>
<p>11.详解SpringData<br>    1.概念<br>        Spring Data的目的是为了简化构建基于Spring框架应用的数据访问技术，包括非关系型数据库、Map-Reduce框架、云数据服务等等；另外也包含对关系数据库的访问支持。<br>    2.Spring Data的子项目：<br>        1.Commons    提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化<br>        2.Hadoop    基于Spring的Hadoop作业配置和一个POJO编程模型的MapReduce作业<br>            MapReduce是一种编程模型，用于大规模数据集(大于1TB)的并行运算<br>        3.Key-value 集成了Redis和Riak，提供多个常用场景下的简单封装<br>        4.Document  集成文档数据库，CouchDB和MongoDB并提供基本的配置映射和资料库的支持<br>        5.Graph        集成Neo4j提供强大的基于POJO的编程模型<br>        6.Graph Roo AddOn - Rooney support for Neo4j<br>        7.JDBC Extensions    支持Oracle RAD、高级队列和高级数据类型<br>        8.JPA         简化创建JPA数据访问层和跨存储的持久层功能<br>        9.Mapping     基于Grails的提供对象映射框架，支持不同的数据库<br>        10.Examples    示例程序、文档和图数据库<br>        11.Guidance 高级文档<br>    3.Repository<br>        1.如果dao接口继承了Repository，则该接口会被IOC容器识别为一个Repository Bean注入到IOC容器中，进而可以再该接口中定义满足一定规则的接口<br>            或者通过一个朱姐@RepositoryDefination注解来替代Repository接口<br>        2.在Repository接口中声明方法<br>            1.查询方法以 find|read|get开头<br>            2.设计条件查询，条件的属性需要定义关键字连接<br>            3.条件的属性以字母大写<br>            4.支持属性的级联查询，若当前类由符合条件的属性，则优先使用，则不使用级联属性<br>        3.通过自定义的JPQL完成update和delete操作<br>            注意：JPQL不支持Insert操作<br>            在@Query注解中编写JPQL语句，单必须使用@Modify进行修饰，以通知SpringData，这是一个Update或者delete<br>            因为update和delete需要使用事务，而默认情况下springdata的每个方法上都有一个只读事务，不能完成修改操作<br>            因此需要使用@Modify修饰</p>
<p>23种设计模式:<br>    1.装饰者模式<br>        允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰者可以在所委托被装饰者的行为之前或者之后加上自己的行为，以达到特定的目的。<br>        参考：<a href="https://blog.csdn.net/wwh578867817/article/details/51480441" target="_blank" rel="noopener">https://blog.csdn.net/wwh578867817/article/details/51480441</a><br>        eg：<br>            假设我们去咖啡店点了一杯咖啡，可以加奶加糖，咖啡、奶、糖各有不同的价格。<br>                此时咖啡就是我们的组件，奶和糖就是我们的装饰者<br>        实现细节：<br>            Component 抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互<br>            ConcreteComponent具体构件角色（真实对象）：io流中的FileInputStream、　　　　FileOutputStream<br>            Decorator 装饰对象：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。<br>            ConcreteDecorator具体装饰角色：负责给构件对象增加新的责任。</p>
<p>OAuth 2.0 关于授权的开放网络标准<br>    1.几个专用名词<br>        Third-party application:    第三方应用程序，又称“客户端”(client)<br>        HTTP service:                HTTP服务提供商<br>        Resource Owner：            资源所有者，即“用户”(user)<br>        User Agent:                    用户代理，即浏览器<br>        Authorization server：        认证服务器，即服务提供商专门用来处理认证的服务器<br>        Resource server:            资源服务器，即服务提供商存放用户生成的资源的服务器。与认证服务器可以是同一台，也可以不是<br>    2.OAuth的思路<br>        OAuth在客户端与服务提供商之间，设置了一个授权层，客户端不能直接登录“服务提供商”，只能登录授权层，以此将用户与客户端区分开来。“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>        “客户端”登录授权层以后，“服务提供商”根据令牌的权限范围和有效期，向“客户端”开放用户存储的资料</p>
<pre><code>                ----    (A)Authorization Request---&gt;       |Resource|
                &lt;---    (B)Authorization Grant    ----    | Owner  |

      +------+    ----    (c)Authorization Grant    ---&gt;    |Authorization|
      |Client|  &lt;---    (D)Access Token            ----    |    Server    |
      +------+                
                ----    (E)Access Token            ---&gt;    |Resource  |
                &lt;---    (F)Protected Resrouce    ----    |    Server |
    解析：
        （A）用户打开客户端以后，客户端要求用户给予授权
        （B）用户同意给予客户端授权
        （C）客户端使用上一步获得的授权，向认证服务器申请令牌
        （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌
        （E）客户端使用令牌，向资源服务器申请获取资源
        （F）资源服务器确认令牌无误，同意向客户端开发资源
3.其中B步骤的客户端授权模式
    1.授权码模式（authorization code）

    2.简化模式（implicit）

    3.密码模式（resource owner password credentials）

    4.客户端模式（client credentials）

    具体参数查看：http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html
4.更新令牌
    如果用户访问的时候，客户端的“访问令牌”已经过期，则需要使用“更新令牌”申请一个新的访问令牌。
    客户端发出更新令牌的HTTP请求，包含以下参数：
        granttype：表示使用的授权模式，此处的值固定为&quot;refreshtoken&quot;，必选项。
        refresh_token：表示早前收到的更新令牌，必选项。
        scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。
    eg： 
        POST /token HTTP/1.1
         Host: server.example.com
         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
         Content-Type: application/x-www-form-urlencoded
         grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</code></pre><p>Swagger<br>    1.概念：<br>        Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步<br>    2.SpringBoot集成Swagger<br>        1.添加maven依赖，在pom文件中添加：<br>            springfox-swagger2<br>        2.添加swagger配置文件，如下：<br>            @Configuration<br>            @EnableSwagger2<br>            public class SwaggerConfiguration {<br>                @Bean<br>                public Docket api() {<br>                    return new Docket(DocumentationType.SWAGGER_2)<br>                            .ignoredParameterTypes(HttpSession.class)<br>                            .apiInfo(apiInfo())<br>                            .select()            //选择那些路径和api会生成document<br>                            .apis(RequestHandlerSelectors.any())    //对所有api进行监控<br>                            .paths(PathSelectors.any())        //对所有路径进行监控<br>                            .build();<br>                }</p>
<pre><code>            private ApiInfo apiInfo() {
                return new ApiInfoBuilder()
                        .title(&quot;pgc接口调用说明&quot;)
                        .description(&quot;该文档仅供内部人员使用.&quot;)
                        .termsOfServiceUrl(&quot;http://xxxx&quot;)
                        .version(&quot;1.0&quot;)
                        .build();
            }
        }
    3.此时访问项目下的api-docs，能返回json形式的界面
3.添加SwaggerUI
    springfox-swagger-ui
    生成一个可读性良好的API页面。
    此时可以访问项目下的swagger-ui.html
4.Swagger对RESTful风格的api支持的比较好。</code></pre><p>SpringBoot拦截器之WebMvcConfigurerAdapter</p>
<pre><code>1.几个比较常见的：
    /* 这里配置视图解析器 */
    void configureViewResolvers(ViewResolverRegistry registry);

    /* 配置内容裁决的一些选项*/
    void configureContentNegotiation(ContentNegotiationConfigurer configurer);

    /* 视图跳转控制器 */
    void addViewControllers(ViewControllerRegistry registry);

    /* 静态资源处理 */
    void addResourceHandlers(ResourceHandlerRegistry registry);

    /* 默认静态资源处理器 */
    void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);
具体方法查看：https://blog.csdn.net/wujiaqi0921/article/details/78324722</code></pre><p>SpringBoot 序列化器注解使用方法<br>    1.@JsonIgnoreProperties<br>        类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响<br>    2.@JsonIgnore<br>        属性或方法注解（最好在属性上），作用同JsonIgnoreProperties<br>    3.@JsonFormat<br>        属性或方法注解（最好在属性上），可以方便的把Date类型直接转化为我们想要的模式，例如@JsonFormat(pattern=”yyyy-MM-dd HH-mm-ss”)<br>    4.@JsonSerialize<br>        用于属性或getter方法上，用于在序列化时嵌入我们自定义的代码<br>    5.@JsonDeserialize<br>        用于属性或getter方法上，用于在反序列化时可以嵌入我们自定义的代码</p>
<p>SpringBoot 使用 JavaMailSender发送邮件<br>—–.SpringBoot<br>        添加依赖<br>        <dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-mail</artifactid><br>        </dependency><br>    2.配置属性<br>        spring.mail.host=smtp.qq.com<br>        spring.mail.username=用户名<br>        spring.mail.password=密码<br>        spring.mail.properties.mail.smtp.auth=true<br>        spring.mail.properties.mail.smtp.starttls.enable=true<br>        spring.mail.properties.mail.smtp.starttls.required=true<br>    3.测试<br>        @Autowired<br>        private JavaMailSender mailSender;</p>
<pre><code>    SimpleMailMessage message = new SimpleMailMessage();
    message.setFrom(&quot;1153693791@qq.com&quot;);
    message.setTo(&quot;1153693791@qq.com&quot;);
    message.setSubject(&quot;主题：&quot;+title);
    message.setText(content);
    mailSender.send(message);</code></pre><p>Spring JPA 开启审计功能：<br>    JPA Audit:<br>        在Spring jpa中，支持在字段或者方法上进行注解@CreateDate,@CreatedBy,@LastModifiedDate,@LastModifiedBy<br>    使用：<br>        1.申明实体类，需要在类上添加注解@EntityListeners(AuditingEntityListener.class)，<br>            @Entity<br>            @Table(name = “store_source_bind”)<br>            @EntityListeners(AuditingEntityListener.class)<br>            public class StoreSourceBind {</p>
<pre><code>    2.在需要的字段上加上@CreateDate,@CreatedBy,@LastModifiedDate,@LastModifiedBy
    @Column(name = &quot;create_time&quot;)
    @CreatedDate
    private Date createTime;

    3.继承AuditorAware&lt;T&gt;来指定返回的创建信息:
        @Component(&quot;auditorAware&quot;)
        public class SpringSecurityAuditorAware implements AuditorAware&lt;String&gt; {

            private HttpSession session;

            @Override
            public String getCurrentAuditor() {
                return Utils.getUserIdFromSession(session);
            }
        }
    4.在application启动类中加上注解EnableJpaAuditing或者EnableMongoAuditing（MongoDB的审计），

    @EnableJpaAuditing
    @EnableMongoAuditing(auditorAwareRef = &quot;auditorAware&quot;)//开启审计功能
    public class WalletApplication {
        public static void main(String[] args) {
            new SpringApplicationBuilder(WalletApplication.class).web(true).run(args);
        }
    }</code></pre><p>SpringBoot 定时任务：</p>
<pre><code>1.开启定时任务的配置
  在启动文件上，添加注解 @EnableScheduling
2.创建定时任务
  在需要定时执行的文件上方添加注解：
      @Scheduled(fixedRate = 5000)
3. @Scheduled 详解：
    1.fixedRate = 5000 ：上次开始执行时间点之后5秒执行
    2.initialDelay = 1000 , fixedRate = 5000 
        第一次延迟 1 秒后执行，之后按照 5 秒的规则执行
    3.cron = &quot;*/5 ***&quot;) :
        通过 cron 表达式定义规则</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/regex/index.html">正则表达式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a></span><div class="content"><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p>
</blockquote>
<p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.<br>“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p>
<p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br>我们使用以下正则表达式来验证一个用户名:</p>
<p>以上的正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>.<br>但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#1-基本匹配">1. 基本匹配</a></li>
<li><a href="#2-元字符">2. 元字符</a><ul>
<li><a href="#21-点运算符-">2.1 点运算符 .</a></li>
<li><a href="#22-字符集">2.2 字符集</a><ul>
<li><a href="#221-否定字符集">2.2.1 否定字符集</a><ul>
<li><a href="#23-重复次数">2.3 重复次数</a></li>
</ul>
</li>
<li><a href="#231--号">2.3.1 * 号</a></li>
<li><a href="#232--号">2.3.2   号</a></li>
<li><a href="#233--号">2.3.3 ? 号</a><ul>
<li><a href="#24--号">2.4 {} 号</a></li>
<li><a href="#25--特征标群">2.5 (…) 特征标群</a></li>
<li><a href="#26--或运算符">2.6 | 或运算符</a></li>
<li><a href="#27-转码特殊字符">2.7 转码特殊字符</a></li>
<li><a href="#28-锚点">2.8 锚点</a></li>
</ul>
</li>
<li><a href="#281--号">2.8.1 ^ 号</a></li>
<li><a href="#282--号">2.8.2 $ 号</a><ul>
<li><a href="#3-简写字符集">3. 简写字符集</a></li>
<li><a href="#4-前后关联约束前后预查">4. 前后关联约束(前后预查)</a></li>
<li><a href="#41--前置约束存在">4.1 ?=… 前置约束(存在)</a></li>
<li><a href="#42--前置约束-排除">4.2 ?!… 前置约束-排除</a></li>
<li><a href="#43---后置约束-存在">4.3 ?&lt;= … 后置约束-存在</a></li>
<li><a href="#44--后置约束-排除">4.4 ?&lt;!… 后置约束-排除</a></li>
<li><a href="#5-标志">5. 标志</a></li>
<li><a href="#51-忽略大小写-case-insensitive">5.1 忽略大小写 (Case Insensitive)</a></li>
<li><a href="#52-全局搜索-global-search">5.2 全局搜索 (Global search)</a></li>
<li><a href="#53-多行修饰符-multiline">5.3 多行修饰符 (Multiline)</a></li>
<li><a href="#额外补充">额外补充</a></li>
<li><a href="#贡献">贡献</a></li>
<li><a href="#许可证">许可证</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.<br>例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p>
<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较.</p>
<p>正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>正则表达式主要依赖于元字符.<br>元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>句号匹配任意单个字符除了换行符.</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td>字符种类. 匹配方括号内的任意字符.</td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td>否定的字符种类. 匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td align="center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符.</td>
</tr>
<tr>
<td align="center">+</td>
<td>匹配&gt;=1个重复的+号前的字符.</td>
</tr>
<tr>
<td align="center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td align="center">(xyz)</td>
<td>字符集, 匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td align="center">&#124;</td>
<td>或运算符,匹配符号前或后的字符.</td>
</tr>
<tr>
<td align="center">&#92;</td>
<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td align="center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td align="center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody></table>
<h2 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h2><p><code>.</code>是元字符中最简单的例子.<br><code>.</code>匹配任意单个字符, 但不匹配换行符.<br>例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.<br>例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener">在线练习</a></p>
<p>方括号的句号就表示句号.<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h2><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p>
<h3 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h3><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h3><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.<br>例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h2><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.<br>例如,  表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener">在线练习</a></p>
<p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>
<p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h2><p>或运算符就表示或, 用作判断条件.</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h2><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>
<h3 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>
<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>
<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h3><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p>
<p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配所有非空格字符: <code>[^\s]</code></td>
</tr>
<tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\p</td>
<td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<h2 id="4-前后关联约束-前后预查"><a href="#4-前后关联约束-前后预查" class="headerlink" title="4. 前后关联约束(前后预查)"></a>4. 前后关联约束(前后预查)</h2><p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br>前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p>
<p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\$)[0-9\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>
<p>前后关联约束如下:</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?=</td>
<td>前置约束-存在</td>
</tr>
<tr>
<td align="center">?!</td>
<td>前置约束-排除</td>
</tr>
<tr>
<td align="center">?&lt;=</td>
<td>后置约束-存在</td>
</tr>
<tr>
<td align="center">?&lt;!</td>
<td>后置约束-排除</td>
</tr>
</tbody></table>
<h3 id="4-1-前置约束-存在"><a href="#4-1-前置约束-存在" class="headerlink" title="4.1 ?=... 前置约束(存在)"></a>4.1 <code>?=...</code> 前置约束(存在)</h3><p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p>
<p>返回结果只满足第一部分表达式.<br>定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p>
<p>前置约束的内容写在括号中的等号后面.<br>例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-2-前置约束-排除"><a href="#4-2-前置约束-排除" class="headerlink" title="4.2 ?!... 前置约束-排除"></a>4.2 <code>?!...</code> 前置约束-排除</h3><p>前置约束-排除 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式<br><code>前置约束-排除</code>  定义和 <code>前置约束(存在)</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-3-lt-后置约束-存在"><a href="#4-3-lt-后置约束-存在" class="headerlink" title="4.3 ?&lt;= ... 后置约束-存在"></a>4.3 <code>?&lt;= ...</code> 后置约束-存在</h3><p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br>例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?<=(t|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</=(t|t)he\s)(fat|mat)"></pre>

<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-4-lt-后置约束-排除"><a href="#4-4-lt-后置约束-排除" class="headerlink" title="4.4 ?&lt;!... 后置约束-排除"></a>4.4 <code>?&lt;!...</code> 后置约束-排除</h3><p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h2><p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>忽略大小写.</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索.</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>
</tr>
</tbody></table>
<h3 id="5-1-忽略大小写-Case-Insensitive"><a href="#5-1-忽略大小写-Case-Insensitive" class="headerlink" title="5.1 忽略大小写 (Case Insensitive)"></a>5.1 忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="5-2-全局搜索-Global-search"><a href="#5-2-全局搜索-Global-search" class="headerlink" title="5.2 全局搜索 (Global search)"></a>5.2 全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>
<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="5-3-多行修饰符-Multiline"><a href="#5-3-多行修饰符-Multiline" class="headerlink" title="5.3 多行修饰符 (Multiline)"></a>5.3 多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用语执行一个多行匹配.</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>
<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> , 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾.</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>


<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com" target="_blank" rel="noopener">ziishaned@gmail.com</a> 或 <a href="https://twitter.com/ziishaned" target="_blank" rel="noopener"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&label=Follow%20%40ziishaned" alt="Twitter URL"></a></li>
</ul>
<h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p>MIT © <a href="mailto:ziishaned@gmail.com" target="_blank" rel="noopener">Zeeshan Ahmed</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/模拟Ping获取IP响应时间/index.html">模拟Ping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/工具函数/index.html">工具函数</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a></span><div class="content"><pre><code class="java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class IpContimeUtil {

    private static float ping(String ipAddress) {

        boolean isWindows = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;);
        String command = String.format(&quot;ping -%s 1 %s&quot;, isWindows ? &quot;n&quot; : &quot;c&quot;, ipAddress);
        try {
            Process process = Runtime.getRuntime().exec(command);
            InputStream inputStream = process.getInputStream();
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;GBK&quot;);
            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
            String line;
            Pattern pattern = Pattern.compile(&quot;.*?([\\d.]+)\\s?ms.*&quot;);

            while ((line = bufferedReader.readLine()) != null) {
                System.out.println(line);
                Matcher matcher = pattern.matcher(line);
                if (matcher.matches()) {
                    return Float.parseFloat(matcher.group(1));
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(&quot;响应超时&quot;);
        }
        throw new RuntimeException(&quot;响应异常&quot;);
    }

    private static List&lt;Float&gt; print(List&lt;String&gt; newList) throws Exception {
        return newList.stream().map(IpContimeUtil::ping).collect(Collectors.toList());
    }

    public static void main(String[] args) throws Exception {
        System.out.println(&quot;响应时间：&quot; + IpContimeUtil.print(Collections.singletonList(&quot;101.132.162.159&quot;)));
    }
}
</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/钩子函数/index.html">钩子函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/index.html">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a></span><div class="content"><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><blockquote>
<p>钩子(hook)，是一种具有 <code>既定生命周期</code> 的框架工具，在生命周期的各个阶段预留给用户执行一些特定操作的口子，其实是一种 <code>面向切面</code> 编程。</p>
<p>例如当 JVM 程序即将退出时，会执行我们注入的 钩子线程。</p>
<pre><code class="java"> public static void main(String[] args) {
     Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
         @Override
         public void run() {
             System.out.println(&quot;The hook thread 1 is running.&quot;);
             try {
                 TimeUnit.SECONDS.sleep(2);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             System.out.println(&quot;The hook thread 1 is exit.&quot;);
         }
     }));

     Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
         @Override
         public void run() {
             System.out.println(&quot;The hook thread 2 is running.&quot;);
             try {
                 TimeUnit.SECONDS.sleep(2);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             System.out.println(&quot;The hook thread 2 is exit.&quot;);
         }
     }));
 }</code></pre>
<p>当该方法运行结束时，会调用这两个 hook 线程。</p>
<h2 id="应用场景：防止应用程序重复启动"><a href="#应用场景：防止应用程序重复启动" class="headerlink" title="应用场景：防止应用程序重复启动"></a>应用场景：防止应用程序重复启动</h2><pre><code class="java">public static void main(String[] args) {
    File file = new File(&quot;./.lock&quot;);
    if(file.exists()){
        throw new RuntimeException(&quot;The program already running.&quot;);
    }
    try {
        file.createNewFile();
    } catch (IOException e) {
        e.printStackTrace();
    }

    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;The program received kill signal.&quot;);
            file.delete();
        }
    }));

    while(true){
        try {
            TimeUnit.SECONDS.sleep(1);
            System.out.println(&quot;The program is running.&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/DB-MySQL常用命令/index.html">模拟Ping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/工具函数/index.html">工具函数</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/index.html">java</a></span><div class="content"><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code class="mysql">/* Windows服务 */
-- 启动 MySQL
    net start mysql
-- 创建Windows 服务
    sc create mysql binPath= mysqld_bin_path(等号与值之间有空格)
/* 连接与断开服务器 */
    mysql -h 地址 -P 端口 -u 用户名 -p 密码
-- 显示哪些线程正在运行
    SHOW PROCESSLIST
-- 显示系统变量信息
    SHOW VARIABLES</code></pre>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><pre><code class="mysql">/* 数据库操作 */
-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES [ LIKE &#39;PATTERN&#39; ]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 数据库名 选项信息
-- 删除库
    DROP DATABASE [ IF EXISTS ] 数据库名
        同时删除数据库相关的目录及目录内容</code></pre>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><pre><code class="mysql">-- 创建表
    CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [数据库名.]表名 (
        表的结构定义
    ) [表选项]
        - 每个字段必须有数据类型
        - 最后一个字段后不能有都好
        - TEMPORARY 临时表，会话结束时表自动消失
        - 对于字段的定义：
            字段名 数据类型 [NOT NULL|NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | PRIMARY [KEY]] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        - 如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        - 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        - 常见的引擎：InnoDB、MyISAM、Memory/Heap、BDB、Merge、Example、CSV、MaxDB、Archive
        - 不同的引擎在保存表的结构和数据时采用不同的方式
            - MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
            - InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        - 显示存储引擎的状态信息
            SHOW ENGINES；
        - 显示存储引擎的日志或状态信息
            SHOW ENGINE 引擎名 {LOGS|STATUS}
    -- 自增起始数
        AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ...
-- 查看所有表
    SHOW TABLES [LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 库名
-- 查看表结构
    SHOW CREATE TABLE 表名
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;pattern&#39;]
    SHOW TABLE STATUS [FROM db_name] [like &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        - eg: ALTER TABLE db_name ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名
        - RENAME 可以交换两个表名
    -- 修改表的字段结构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD [COLUMN] 字段定义               -- 增加字段
            ADD [COLUMN] AFTER 字段名            -- 增加在该字段名后面
            ADD [COLUMN] FIRST                   -- 增加在第一个
            ADD PRIMARY KEY(字段名)            -- 创建主键
            ADD UNIQUE [索引名] (字段名)          -- 创建唯一索引
            ADD INDEX [索引名] (字段名)          -- 创建普通索引
            DROP [COLUMN] 字段名                 -- 删除字段
            MODIFY [COLUMN] 字段名 字段属性     -- 支持对字段属性修改，不支持修改字段名
            CHANGE [COLUMN] 原字段名 新字段名 属性 -- 支持对字段名修改
            DROP PRIMARY KEY                  -- 删除主键(删除主键前，需要删除其 AUTO_INCREMENT 属性)
            DROP INDEX 索引名                    -- 删除索引
            DROP FOREIGN KEY 外键                 -- 删除外键
-- 删除表
    DROP TABLE [IF EXISTS] 表名...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 复制名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tb_name [,tb_name2] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name]...</code></pre>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><pre><code class="mysql">-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[,(值列表),...]
        - 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表
        - 可同时插入多条数据记录
        - REPLACE 与 INSERT 完全一样，可互换
    INSERT [INTO] 表名 SET 字段名=值[,字段名=值,...]
-- 删
    DELETE FROM 表名 [删除条件子句]
        - 没有条件子句，会删除全部
-- 改
    UPDATE 表名 SET 字段名=值[,字段名=值,...] [更新条件]
-- 查
    SELECT 字段列表 FROM 表名 [其他子句]
        - 可来自多个表的多个字段
        - 其他子句可以不使用
        - 字段列表可以用*代替，表示所有字段</code></pre>
<h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><pre><code class="mysql">-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码无需一致
-- 查看所有字符集编码项
SHOW VARIABLES LIKE &#39;character_set_%&#39;
    character_set_client    -- 客户端向服务器发送数据时使用的编码
    character_set_results    -- 服务器端将结果返回给客户端所使用的编码
    character_set_connection-- 连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES gbk;     -- 以上三个配置
-- 校对集
    校对集用以排序
    -- 查看所有字符集
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;] / SHOW CHARSET [LIKE &#39;pattern&#39;]
    -- 查看所欲校对集
    SHOW COLLATION [LIKE &#39;pattern&#39;]
    -- 设置字符集编码
    CHARSET 字符集编码
    -- 设置校对集编码
    COLLATE 校对集编码</code></pre>
<h2 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h2><pre><code class="mysql">1. 数值类型
-- a.整型
    类型            字节        范围
    tinyint       1字节     -128~127 无符号位：0~255
    smallint      2字节      -32768~32767
    mediumint      3字节     -8388608~8388607
    int          4字节    
    bigint         8字节
    int(M)         M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例如：int(5) 插入&#39;123&#39;,补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好
    - 1表示bool真，0表示bool假。常用 tinyint(1) 表示布尔型
-- b.浮点型
    类型            字节        范围
    float         4字节
    double         8字节
    - 浮点型既支持符号位 unsigned，也支持显示宽度 zerofill
        - 不同于整型，前后均会补填0
    - 定义浮点型时，需指定总位数和小数位数
        - float(M,D)    double(M,D)
        - M表示总位数，D表示小数位数
        - M和D的大小会决定浮点数的范围，不同于整型的固定范围
        - M既表示总位数(不包括小数点和正负号)，也表示显示宽度(所有显示符号均包括)
        - 支持科学计数法表示
        - 浮点数表示近似值
-- c.定点数
    decimal  -- 可变长度
    decimal(M,D)  -- M表示总位数，D表示小数位数
    - 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入
    - 将浮点数转换为字符串来保存，每9位数字保存为4个字节
2. 字符串类型
-- a.char，varchar
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    - M表示能存储的最大长度，此长度为字符数，非字节数
    - 不同的编码，所占用的空间不同
    - char，最多255个字符，与编码无关
    - varchar，最多65535个字符，与编码有关
    - 一条有效记录最大不能超过 65535 个字节
     - utf8 最大为21844个字符，gbk 最大为 32766个字符，latin 最大为65532个字符
    - varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存
    - varchar 的最大有效长度由最大行大小和使用的字符集确定。
    - 最大有效长度是 65532 字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是 64432-1-2=65532字节
     - 例如：表 定义为 CREATE TABLE tb(c1 int,c2 char(30),c3 varchar(N)) charset=utf8；问N的最大值是多少？答：(65535-1-2-4-30*3)/3
-- b.blob,text
    blob    二进制字符串（字节字符串）
        tinyblob,blob,mediumblob,longblob
    text    非二进制字符串（字符字符串）
        tinytext,text,mediumtext,longtext
    - text 在定义时，不需要定义长度，也不会计算总长度
    - text 类型在定义时，不可给default值
-- c,binary,varbinary
    类似于 char 和 varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串
    char、varchar、text 对应 binary、varbinary、blob
3. 日期时间类型
    一般用整型保存时间戳
    datetime        8字节    日期及时间
        YYYY-MM-DD hh:mm:ss
    date            3字节 日期
        YYYY-MM-DD
        YY-MM-DD
        YYYYMMDD
        YYMMDD
    timestamp        4字节 时间戳
        YY-MM-DD hh:mm:ss
        YYYYMMDDhhmmss
        YYMMDDhhmmss
    time            3字节 时间
        hh:mm:ss
        hhmmss
    year            1字节 年份
        YYYY
        YY
4. 枚举和集合
-- 枚举
    enum(val1,val2,val3...)
        - 在已知的值中进行单选，最大数量为65535
        - 枚举值在保存时，以2字节的整型保存，每个枚举值，按保存的位置顺序，从1开始逐一递增
        - 表现为字符串类型，存储却是整型
        - NULL值的索引是NULL
        - 空字符串错误值的索引值是0
-- 集合
    set(val1,val2,val3....)
        - CREATE TABLE tb(gener set(&#39;男&#39;,&#39;女&#39;,&#39;无&#39;))
        - INSERT INTO tb values (&#39;男，女&#39;)
        - 最多可以有64个不同成员，以bigint存储，共8字节，采取位运算的形式
        - 当创建表时，SET 成员值的尾部空格将自动删除</code></pre>
<p>文章摘抄自 <a href="https://juejin.im/post/5d6faf8f6fb9a06b0b1c9535?utm_source=gold_browser_extension" target="_blank" rel="noopener">掘金 - 一千行MySQL命令</a> 。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/41/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/43/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>