<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">239</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/30/分布式/SpringBoot/OSS-阿里云文件上传/">基于阿里云OSS的文件上传服务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/">Java成神之路</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/SpringBoot/">SpringBoot</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SpringBoot/">SpringBoot</a></span><div class="content"><h1 id="基于阿里云OSS的文件上传服务"><a href="#基于阿里云OSS的文件上传服务" class="headerlink" title="基于阿里云OSS的文件上传服务"></a>基于阿里云OSS的文件上传服务</h1><h2 id="1-阿里云-OSS-服务介绍"><a href="#1-阿里云-OSS-服务介绍" class="headerlink" title="1.阿里云 OSS 服务介绍"></a>1.阿里云 OSS 服务介绍</h2><pre><code>OSS(Object Storage Service) 即对象存储服务，在 OSS 中每个文件都有一个 Key，通过这个 Key 来指向不同的文件对象。      

如果你提交的key为&quot;/attachment/2016/123.txt&quot;，那么在web管理平台上你可以看到上述以&quot;/&quot;分开的文件夹形式，即 OSS 中的 Key 就是&quot;/attachement/2016/123.txt&quot;</code></pre><h2 id="2-Java-SDK"><a href="#2-Java-SDK" class="headerlink" title="2.Java SDK"></a>2.Java SDK</h2><blockquote>
<p>aliyun-sdk-oss</p>
</blockquote>
<h2 id="3-如何使用-OSS"><a href="#3-如何使用-OSS" class="headerlink" title="3.如何使用 OSS"></a>3.如何使用 OSS</h2><pre><code>阿里云OSS方服务，通过自身提供的Client来实现上传和下载。所以在使用OSS服务上传文件时，需要创建三个类： Client类 、 Config类 和 上传类。</code></pre><h2 id="4-构建-OSS-Client-类"><a href="#4-构建-OSS-Client-类" class="headerlink" title="4.构建 OSS Client 类"></a>4.构建 OSS Client 类</h2><blockquote>
<p>获得 OSS 连接的工具类</p>
</blockquote>
<pre><code>@Component
public class DefaultOssClient{

    @Value(&quot;${oss.endpoint})
    String ENDPOINT;

    @Value(&quot;${oss.access.key.id}&quot;)
    String ACCESS_KEY_ID;

    @Value(&quot;${oss.access.key.secret}&quot;)
    String ACCESS_KEY_SECRET;

    @Value(&quot;${oss.bucket.name}&quot;)
    String BUCKET_NAME;

    private static OSSClient client = new OSSClient(ENDPOINT,ACCESS_KEY_ID,ACCESS_KEY_SECRETT,DefaultConfig.getDefaultConfig());

    static OSSClient getConnection(){
        if(client == null){
            client = new OSSClient(ENDPOINT,ACCESS_KEY_ID,ACCESS_KEY_SECRET,DefaultConfig.getDefaultConfig());
        }
        return client;
    }

    static void shutdownOSSClient(){
        client.shutdown();
        client = null;
    }
}</code></pre><blockquote>
<p>创建一个保存 OSS 地址的文件类，这个文件用户返回给界面</p>
</blockquote>
<pre><code>public class OSSFile{
    String fileId;
    String ossUrl;
    String fielname;
    double sizeKb;

    /* getter and setter*/
}</code></pre><blockquote>
<p>构建 OSS Config 类，用于指定文件上传的配置</p>
</blockquote>
<pre><code>static final ClientConfiguration conf = new ClientCOnfiguration();

public class DefaultConfig{
    private DefaultConfig(){
        conf.setMaxConnections(100);
        conf.setConnectionTimeout(5000);
        conf.setMaxErrorRetry(3);
        conf.setSocketTimeout(2000);
    }

    static ClientConfiguration getDefaultConfig(){
        return conf;
    }
}</code></pre><blockquote>
<p>构建 OSS 文件上传类</p>
</blockquote>
<pre><code>public class OSSUpload{

    static String put1(File file){
        String return_key = null;
        try{
            OSSClient client = DefaultOssClient.getConnection();
            if(file !=null){
                String fileName = file.getName();
                String timeStamp = Date2Str.getCurrentTimeStamp();
                String timeDate = Date2Str.getCurrentDate5();
                String key = Constant.bashFilePath + timeDate + timeStamp +&quot;/&quot; +fileName;

                client.putObject(new PutObjectRequest(Constant.bucketName,key,file));

                return_key = key;
            }
            DefaultOssClient.shutdownOSSClient();
        }catch(ClientException e){
            return null;
        }
        return return_key;
    }

    static String put2(InputStream in,String filename){
        String return_key = null;
        try{
            OSSClient client = DefaultOssClient.getConnection();
            if(in != null){
                String fileName = filename;
                try{
                    fileName = new String(filename.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);
                }catch(UnsupportedEncodingException e){
                    e.printStackTrace();
                }
                String timeStamp = System.getCurrentTimeStamp();
                String timeDate = Date2Str.getCurrentDate5();
                String key = Constant.bashFilePath + timeDate + timeStamp + &quot;/&quot; + fileName;

                client.put(new PutObjectRequest(Constant.bucketName,key,in));

                return_key = key;
            }

            DefaultOssClient.shutdownOSSClient();
        }catch(ClientException e){
            return null;
        }

        return return_key;
    }
}</code></pre><blockquote>
<p>上传测试</p>
</blockquote>
<pre><code>public class FileUpload{
    public static void main(String[] args){
        try{
            uploadOSS();
        }catch(IOException e){
            e.printStackTrace();
        }
    }

    public static void uploadOSS() throws ClientProtocolExcetion{
        HttpPost httpPost = new HttpPost(&quot;http://127.0.0.1:7001/test/autonavi/shanghai/api/attachment/oss/);
        httpPost.addHeader(&quot;key&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;user&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;method&quot;,&quot;123&quot;);
        httpPost.addHeader(&quot;filename&quot;,new String(&quot;黄山［哈哈］.jpg&quot;.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;));
        httpPost.addHeader(&quot;type&quot;,&quot;01&quot;);

        FileEntity reqEntity = new FileEntity(new File(&quot;/Users/123/Pictures/Huangshan.jpg&quot;));

        httpPost.setEntity(reqEntity);

        HttpClient client = new DefaultHttpClient();
        HttpResponse response = client.execute(httpPost);

        System.out.println(response);
    }
}</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/regex/">正则表达式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p>
</blockquote>
<p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.<br>“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p>
<p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br>我们使用以下正则表达式来验证一个用户名:</p>
<p>以上的正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>.<br>但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#1-基本匹配">1. 基本匹配</a></li>
<li><a href="#2-元字符">2. 元字符</a><ul>
<li><a href="#21-点运算符-">2.1 点运算符 .</a></li>
<li><a href="#22-字符集">2.2 字符集</a><ul>
<li><a href="#221-否定字符集">2.2.1 否定字符集</a><ul>
<li><a href="#23-重复次数">2.3 重复次数</a></li>
</ul>
</li>
<li><a href="#231--号">2.3.1 * 号</a></li>
<li><a href="#232--号">2.3.2   号</a></li>
<li><a href="#233--号">2.3.3 ? 号</a><ul>
<li><a href="#24--号">2.4 {} 号</a></li>
<li><a href="#25--特征标群">2.5 (…) 特征标群</a></li>
<li><a href="#26--或运算符">2.6 | 或运算符</a></li>
<li><a href="#27-转码特殊字符">2.7 转码特殊字符</a></li>
<li><a href="#28-锚点">2.8 锚点</a></li>
</ul>
</li>
<li><a href="#281--号">2.8.1 ^ 号</a></li>
<li><a href="#282--号">2.8.2 $ 号</a><ul>
<li><a href="#3-简写字符集">3. 简写字符集</a></li>
<li><a href="#4-前后关联约束前后预查">4. 前后关联约束(前后预查)</a></li>
<li><a href="#41--前置约束存在">4.1 ?=… 前置约束(存在)</a></li>
<li><a href="#42--前置约束-排除">4.2 ?!… 前置约束-排除</a></li>
<li><a href="#43---后置约束-存在">4.3 ?&lt;= … 后置约束-存在</a></li>
<li><a href="#44--后置约束-排除">4.4 ?&lt;!… 后置约束-排除</a></li>
<li><a href="#5-标志">5. 标志</a></li>
<li><a href="#51-忽略大小写-case-insensitive">5.1 忽略大小写 (Case Insensitive)</a></li>
<li><a href="#52-全局搜索-global-search">5.2 全局搜索 (Global search)</a></li>
<li><a href="#53-多行修饰符-multiline">5.3 多行修饰符 (Multiline)</a></li>
<li><a href="#额外补充">额外补充</a></li>
<li><a href="#贡献">贡献</a></li>
<li><a href="#许可证">许可证</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.<br>例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p>
<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较.</p>
<p>正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>正则表达式主要依赖于元字符.<br>元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>句号匹配任意单个字符除了换行符.</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td>字符种类. 匹配方括号内的任意字符.</td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td>否定的字符种类. 匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td align="center">*</td>
<td>匹配&gt;=0个重复的在*号之前的字符.</td>
</tr>
<tr>
<td align="center">+</td>
<td>匹配&gt;=1个重复的+号前的字符.</td>
</tr>
<tr>
<td align="center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td align="center">(xyz)</td>
<td>字符集, 匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td align="center">&#124;</td>
<td>或运算符,匹配符号前或后的字符.</td>
</tr>
<tr>
<td align="center">&#92;</td>
<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td>
</tr>
<tr>
<td align="center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td align="center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody></table>
<h2 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a>2.1 点运算符 <code>.</code></h2><p><code>.</code>是元字符中最简单的例子.<br><code>.</code>匹配任意单个字符, 但不匹配换行符.<br>例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.<br>例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener">在线练习</a></p>
<p>方括号的句号就表示句号.<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<pre>
"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a>
</pre>

<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h2><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p>
<h3 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h3><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.
</pre>

<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h3><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.<br>例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>{}</code> 号</h2><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.<br>例如,  表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener">在线练习</a></p>
<p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>
<p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h2><p>或运算符就表示或, 用作判断条件.</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h2><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>
<h3 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>
<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>
<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h3><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p>
<p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配所有非空格字符: <code>[^\s]</code></td>
</tr>
<tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\p</td>
<td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<h2 id="4-前后关联约束-前后预查"><a href="#4-前后关联约束-前后预查" class="headerlink" title="4. 前后关联约束(前后预查)"></a>4. 前后关联约束(前后预查)</h2><p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br>前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p>
<p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\$)[0-9\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>
<p>前后关联约束如下:</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?=</td>
<td>前置约束-存在</td>
</tr>
<tr>
<td align="center">?!</td>
<td>前置约束-排除</td>
</tr>
<tr>
<td align="center">?&lt;=</td>
<td>后置约束-存在</td>
</tr>
<tr>
<td align="center">?&lt;!</td>
<td>后置约束-排除</td>
</tr>
</tbody></table>
<h3 id="4-1-前置约束-存在"><a href="#4-1-前置约束-存在" class="headerlink" title="4.1 ?=... 前置约束(存在)"></a>4.1 <code>?=...</code> 前置约束(存在)</h3><p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p>
<p>返回结果只满足第一部分表达式.<br>定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p>
<p>前置约束的内容写在括号中的等号后面.<br>例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-2-前置约束-排除"><a href="#4-2-前置约束-排除" class="headerlink" title="4.2 ?!... 前置约束-排除"></a>4.2 <code>?!...</code> 前置约束-排除</h3><p>前置约束-排除 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式<br><code>前置约束-排除</code>  定义和 <code>前置约束(存在)</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-3-lt-后置约束-存在"><a href="#4-3-lt-后置约束-存在" class="headerlink" title="4.3 ?&lt;= ... 后置约束-存在"></a>4.3 <code>?&lt;= ...</code> 后置约束-存在</h3><p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br>例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?<=(t|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</=(t|t)he\s)(fat|mat)"></pre>

<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="4-4-lt-后置约束-排除"><a href="#4-4-lt-后置约束-排除" class="headerlink" title="4.4 ?&lt;!... 后置约束-排除"></a>4.4 <code>?&lt;!...</code> 后置约束-排除</h3><p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5. 标志"></a>5. 标志</h2><p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>忽略大小写.</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索.</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>
</tr>
</tbody></table>
<h3 id="5-1-忽略大小写-Case-Insensitive"><a href="#5-1-忽略大小写-Case-Insensitive" class="headerlink" title="5.1 忽略大小写 (Case Insensitive)"></a>5.1 忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="5-2-全局搜索-Global-search"><a href="#5-2-全局搜索-Global-search" class="headerlink" title="5.2 全局搜索 (Global search)"></a>5.2 全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>
<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="5-3-多行修饰符-Multiline"><a href="#5-3-多行修饰符-Multiline" class="headerlink" title="5.3 多行修饰符 (Multiline)"></a>5.3 多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用语执行一个多行匹配.</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>
<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> , 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾.</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener">在线练习</a></p>
<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>


<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com" target="_blank" rel="noopener">ziishaned@gmail.com</a> 或 <a href="https://twitter.com/ziishaned" target="_blank" rel="noopener"><img src="https://img.shields.io/twitter/url/https/twitter.com/ziishaned.svg?style=social&label=Follow%20%40ziishaned" alt="Twitter URL"></a></li>
</ul>
<h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p>MIT © <a href="mailto:ziishaned@gmail.com" target="_blank" rel="noopener">Zeeshan Ahmed</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/POI操作EXCEl/">通过 POI 将数据库中的数据上传至 OSS 对象存储</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/poi/">poi</a></span><div class="content"><h1 id="通过-POI-将数据库中的数据上传至-OSS-对象存储"><a href="#通过-POI-将数据库中的数据上传至-OSS-对象存储" class="headerlink" title="通过 POI 将数据库中的数据上传至 OSS 对象存储"></a>通过 POI 将数据库中的数据上传至 OSS 对象存储</h1><center>
`我爱你，第一句是假的，第二句也是假的。`
</center>

<p><img src="https://upload-images.jianshu.io/upload_images/13603359-996a2c470135ea09.png" alt="我爱你，第一句是假的，第二句也是假的。"></p></div><a class="more" href="/2018/09/29/后端/java/POI操作EXCEl/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/DB-MySQL常用命令/">模拟Ping</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/工具函数/">工具函数</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code class="mysql">/* Windows服务 */
-- 启动 MySQL
    net start mysql
-- 创建Windows 服务
    sc create mysql binPath= mysqld_bin_path(等号与值之间有空格)
/* 连接与断开服务器 */
    mysql -h 地址 -P 端口 -u 用户名 -p 密码
-- 显示哪些线程正在运行
    SHOW PROCESSLIST
-- 显示系统变量信息
    SHOW VARIABLES</code></pre>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><pre><code class="mysql">/* 数据库操作 */
-- 查看当前数据库
    SELECT DATABASE();
-- 显示当前时间、用户名、数据库版本
    SELECT now(), user(), version();
-- 创建库
    CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    SHOW DATABASES [ LIKE &#39;PATTERN&#39; ]
-- 查看当前库信息
    SHOW CREATE DATABASE 数据库名
-- 修改库的选项信息
    ALTER DATABASE 数据库名 选项信息
-- 删除库
    DROP DATABASE [ IF EXISTS ] 数据库名
        同时删除数据库相关的目录及目录内容</code></pre>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><pre><code class="mysql">-- 创建表
    CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [数据库名.]表名 (
        表的结构定义
    ) [表选项]
        - 每个字段必须有数据类型
        - 最后一个字段后不能有都好
        - TEMPORARY 临时表，会话结束时表自动消失
        - 对于字段的定义：
            字段名 数据类型 [NOT NULL|NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | PRIMARY [KEY]] [COMMENT &#39;string&#39;]
-- 表选项
    -- 字符集
        CHARSET = charset_name
        - 如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name
        - 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        - 常见的引擎：InnoDB、MyISAM、Memory/Heap、BDB、Merge、Example、CSV、MaxDB、Archive
        - 不同的引擎在保存表的结构和数据时采用不同的方式
            - MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
            - InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        - 显示存储引擎的状态信息
            SHOW ENGINES；
        - 显示存储引擎的日志或状态信息
            SHOW ENGINE 引擎名 {LOGS|STATUS}
    -- 自增起始数
        AUTO_INCREMENT = 行数
    -- 数据文件目录
        DATA DIRECTORY = &#39;目录&#39;
    -- 索引文件目录
        INDEX DIRECTORY = &#39;目录&#39;
    -- 表注释
        COMMENT = &#39;string&#39;
    -- 分区选项
        PARTITION BY ...
-- 查看所有表
    SHOW TABLES [LIKE &#39;pattern&#39;]
    SHOW TABLES FROM 库名
-- 查看表结构
    SHOW CREATE TABLE 表名
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;pattern&#39;]
    SHOW TABLE STATUS [FROM db_name] [like &#39;pattern&#39;]
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        - eg: ALTER TABLE db_name ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名
        - RENAME 可以交换两个表名
    -- 修改表的字段结构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD [COLUMN] 字段定义               -- 增加字段
            ADD [COLUMN] AFTER 字段名            -- 增加在该字段名后面
            ADD [COLUMN] FIRST                   -- 增加在第一个
            ADD PRIMARY KEY(字段名)            -- 创建主键
            ADD UNIQUE [索引名] (字段名)          -- 创建唯一索引
            ADD INDEX [索引名] (字段名)          -- 创建普通索引
            DROP [COLUMN] 字段名                 -- 删除字段
            MODIFY [COLUMN] 字段名 字段属性     -- 支持对字段属性修改，不支持修改字段名
            CHANGE [COLUMN] 原字段名 新字段名 属性 -- 支持对字段名修改
            DROP PRIMARY KEY                  -- 删除主键(删除主键前，需要删除其 AUTO_INCREMENT 属性)
            DROP INDEX 索引名                    -- 删除索引
            DROP FOREIGN KEY 外键                 -- 删除外键
-- 删除表
    DROP TABLE [IF EXISTS] 表名...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 复制名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tb_name [,tb_name2] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb_name [,tb_name]...</code></pre>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><pre><code class="mysql">-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[,(值列表),...]
        - 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表
        - 可同时插入多条数据记录
        - REPLACE 与 INSERT 完全一样，可互换
    INSERT [INTO] 表名 SET 字段名=值[,字段名=值,...]
-- 删
    DELETE FROM 表名 [删除条件子句]
        - 没有条件子句，会删除全部
-- 改
    UPDATE 表名 SET 字段名=值[,字段名=值,...] [更新条件]
-- 查
    SELECT 字段列表 FROM 表名 [其他子句]
        - 可来自多个表的多个字段
        - 其他子句可以不使用
        - 字段列表可以用*代替，表示所有字段</code></pre>
<h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><pre><code class="mysql">-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码无需一致
-- 查看所有字符集编码项
SHOW VARIABLES LIKE &#39;character_set_%&#39;
    character_set_client    -- 客户端向服务器发送数据时使用的编码
    character_set_results    -- 服务器端将结果返回给客户端所使用的编码
    character_set_connection-- 连接层编码
SET 变量名 = 变量值
    SET character_set_client = gbk;
    SET character_set_results = gbk;
    SET character_set_connection = gbk;
SET NAMES gbk;     -- 以上三个配置
-- 校对集
    校对集用以排序
    -- 查看所有字符集
    SHOW CHARACTER SET [LIKE &#39;pattern&#39;] / SHOW CHARSET [LIKE &#39;pattern&#39;]
    -- 查看所欲校对集
    SHOW COLLATION [LIKE &#39;pattern&#39;]
    -- 设置字符集编码
    CHARSET 字符集编码
    -- 设置校对集编码
    COLLATE 校对集编码</code></pre>
<h2 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h2><pre><code class="mysql">1. 数值类型
-- a.整型
    类型            字节        范围
    tinyint       1字节     -128~127 无符号位：0~255
    smallint      2字节      -32768~32767
    mediumint      3字节     -8388608~8388607
    int          4字节    
    bigint         8字节
    int(M)         M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例如：int(5) 插入&#39;123&#39;,补填后为&#39;00123&#39;
    - 在满足要求的情况下，越小越好
    - 1表示bool真，0表示bool假。常用 tinyint(1) 表示布尔型
-- b.浮点型
    类型            字节        范围
    float         4字节
    double         8字节
    - 浮点型既支持符号位 unsigned，也支持显示宽度 zerofill
        - 不同于整型，前后均会补填0
    - 定义浮点型时，需指定总位数和小数位数
        - float(M,D)    double(M,D)
        - M表示总位数，D表示小数位数
        - M和D的大小会决定浮点数的范围，不同于整型的固定范围
        - M既表示总位数(不包括小数点和正负号)，也表示显示宽度(所有显示符号均包括)
        - 支持科学计数法表示
        - 浮点数表示近似值
-- c.定点数
    decimal  -- 可变长度
    decimal(M,D)  -- M表示总位数，D表示小数位数
    - 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入
    - 将浮点数转换为字符串来保存，每9位数字保存为4个字节
2. 字符串类型
-- a.char，varchar
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    - M表示能存储的最大长度，此长度为字符数，非字节数
    - 不同的编码，所占用的空间不同
    - char，最多255个字符，与编码无关
    - varchar，最多65535个字符，与编码有关
    - 一条有效记录最大不能超过 65535 个字节
     - utf8 最大为21844个字符，gbk 最大为 32766个字符，latin 最大为65532个字符
    - varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存
    - varchar 的最大有效长度由最大行大小和使用的字符集确定。
    - 最大有效长度是 65532 字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是 64432-1-2=65532字节
     - 例如：表 定义为 CREATE TABLE tb(c1 int,c2 char(30),c3 varchar(N)) charset=utf8；问N的最大值是多少？答：(65535-1-2-4-30*3)/3
-- b.blob,text
    blob    二进制字符串（字节字符串）
        tinyblob,blob,mediumblob,longblob
    text    非二进制字符串（字符字符串）
        tinytext,text,mediumtext,longtext
    - text 在定义时，不需要定义长度，也不会计算总长度
    - text 类型在定义时，不可给default值
-- c,binary,varbinary
    类似于 char 和 varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串
    char、varchar、text 对应 binary、varbinary、blob
3. 日期时间类型
    一般用整型保存时间戳
    datetime        8字节    日期及时间
        YYYY-MM-DD hh:mm:ss
    date            3字节 日期
        YYYY-MM-DD
        YY-MM-DD
        YYYYMMDD
        YYMMDD
    timestamp        4字节 时间戳
        YY-MM-DD hh:mm:ss
        YYYYMMDDhhmmss
        YYMMDDhhmmss
    time            3字节 时间
        hh:mm:ss
        hhmmss
    year            1字节 年份
        YYYY
        YY
4. 枚举和集合
-- 枚举
    enum(val1,val2,val3...)
        - 在已知的值中进行单选，最大数量为65535
        - 枚举值在保存时，以2字节的整型保存，每个枚举值，按保存的位置顺序，从1开始逐一递增
        - 表现为字符串类型，存储却是整型
        - NULL值的索引是NULL
        - 空字符串错误值的索引值是0
-- 集合
    set(val1,val2,val3....)
        - CREATE TABLE tb(gener set(&#39;男&#39;,&#39;女&#39;,&#39;无&#39;))
        - INSERT INTO tb values (&#39;男，女&#39;)
        - 最多可以有64个不同成员，以bigint存储，共8字节，采取位运算的形式
        - 当创建表时，SET 成员值的尾部空格将自动删除</code></pre>
<p>文章摘抄自 <a href="https://juejin.im/post/5d6faf8f6fb9a06b0b1c9535?utm_source=gold_browser_extension" target="_blank" rel="noopener">掘金 - 一千行MySQL命令</a> 。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/29/后端/java/钩子函数/">钩子函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java成神之路/">Java成神之路</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><blockquote>
<p>钩子(hook)，是一种具有 <code>既定生命周期</code> 的框架工具，在生命周期的各个阶段预留给用户执行一些特定操作的口子，其实是一种 <code>面向切面</code> 编程。</p>
<p>例如当 JVM 程序即将退出时，会执行我们注入的 钩子线程。</p>
<pre><code class="java"> public static void main(String[] args) {
     Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
         @Override
         public void run() {
             System.out.println(&quot;The hook thread 1 is running.&quot;);
             try {
                 TimeUnit.SECONDS.sleep(2);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             System.out.println(&quot;The hook thread 1 is exit.&quot;);
         }
     }));

     Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
         @Override
         public void run() {
             System.out.println(&quot;The hook thread 2 is running.&quot;);
             try {
                 TimeUnit.SECONDS.sleep(2);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             System.out.println(&quot;The hook thread 2 is exit.&quot;);
         }
     }));
 }</code></pre>
<p>当该方法运行结束时，会调用这两个 hook 线程。</p>
<h2 id="应用场景：防止应用程序重复启动"><a href="#应用场景：防止应用程序重复启动" class="headerlink" title="应用场景：防止应用程序重复启动"></a>应用场景：防止应用程序重复启动</h2><pre><code class="java">public static void main(String[] args) {
    File file = new File(&quot;./.lock&quot;);
    if(file.exists()){
        throw new RuntimeException(&quot;The program already running.&quot;);
    }
    try {
        file.createNewFile();
    } catch (IOException e) {
        e.printStackTrace();
    }

    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;The program received kill signal.&quot;);
            file.delete();
        }
    }));

    while(true){
        try {
            TimeUnit.SECONDS.sleep(1);
            System.out.println(&quot;The program is running.&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/41/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/43/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>