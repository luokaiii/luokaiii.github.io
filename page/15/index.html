<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">243</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">19</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/12/读书笔记/《React》官方文档/2_JSX简介/">《React官方文档》JSX简介</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-12</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h2><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知 UI，以及需要在 UI 中展示准备好的数据。</p>
<h3 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h3><pre><code class="js">const title = response.potentiallyMaliciousInput
// 直接使用是安全的
const element = &lt;h1&gt;{title}&lt;/h1&gt;</code></pre>
<p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些非自己明确编写的内容。所有内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS 攻击。</p>
<h3 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h3><pre><code class="js">const element = (
    &lt;h1 className=&quot;greeting&quot;&gt;
        Hello,World!
    &lt;/h1&gt;
)</code></pre>
<p>Babel 会把 JSX 转译成一个名为 React.createElement() 的函数调用。React.createElement() 会预先执行一些检查，以帮助你编写无错代码：</p>
<pre><code class="javascript">// 这是简化的过程，真实的要复杂的多
const element = {
    type: &#39;h1&#39;,
    props: {
        className: &#39;greeting&#39;,
        children: &#39;Hello,World!&#39;
    }
}</code></pre>
<p>这些对象被称为”React元素”，描述了屏幕前看到的内容，React通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/12/读书笔记/《React》官方文档/0_目录/">《React》官方文档 - 目录</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-12</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><p><img src="https://i.loli.net/2019/09/25/T6tIHkAJMZm2yXB.png" alt="React官方文档 - 读书笔记"></p></div><a class="more" href="/2019/09/12/读书笔记/《React》官方文档/0_目录/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/0_目录/">《MyBatis》读书笔记 - 目录</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><p><img src="https://i.loli.net/2019/09/05/BjHJCbY6luQPnhK.png" alt="mybatis-superbird-small.png"></p></div><a class="more" href="/2019/09/05/读书笔记/《Mybatis》/0_目录/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/4_动态SQL/">《MyBatis》读书笔记 - MyBatis 动态SQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="四、MyBatis-动态SQL"><a href="#四、MyBatis-动态SQL" class="headerlink" title="四、MyBatis 动态SQL"></a>四、MyBatis 动态SQL</h1><p>MyBatis 提供了可以被用在任意 SQL 映射语句中的动态SQL。动态 SQL 元素和 JSTL 或基于 XML 的文本处理器相似。</p>
<p>MyBatis 采用基于 OGNL 的表达式来淘汰其他元素。</p>
<ul>
<li>if</li>
<li>choose(when,otherwise)</li>
<li>trim(where,set)</li>
<li>foreach</li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分，如：</p>
<pre><code class="xml">&lt;select id=&quot;findActive&quot; resultType=&quot;Blog&quot;&gt;
    select * from blog
    where  state=&#39;active&#39;
    &lt;if test=&quot;title != null&quot;&gt;
        and title like #{title}
    &lt;/if&gt;
&lt;/select&gt;</code></pre>
<p>需要多个条件，可以使用 and 连接</p>
<h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><pre><code class="xml">&lt;select id=&quot;findActive&quot; resultType=&quot;Blog&quot;&gt;
    select * from blog
    where state=&quot;active&quot;
    &lt;choose&gt;
        &lt;when test=&quot;title != null&quot;&gt;
            and title like #{title}
        &lt;/when&gt;
        &lt;when test=&quot;author != null and author.name != null&quot;&gt;
            and author_name like #{author.name}
        &lt;/when&gt;
        &lt;otherwise&gt;
            and featured = 1
        &lt;/otherwise&gt;
    &lt;/choose&gt;
&lt;/select&gt;</code></pre>
<h2 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h2><p>如果上面的 where 语句中，去掉了 “state=active”，当所有条件都不匹配时，sql 就不正常了。此时，可以使用 where 标签来解决</p>
<pre><code class="xml">&lt;select id=&quot;findActive&quot; resultType=&quot;Blog&quot;&gt;
     select * from blog
    &lt;where&gt;
        &lt;if test=&quot;state != null&quot;&gt;
            state = #{state}
        &lt;/if&gt;
        &lt;if test=&quot;title != null&quot;&gt;
            and title like #{title}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre>
<p>where 元素会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 where 子句。</p>
<p>若语句开头为 AND 或 OR ，where 元素也会将它们去除。</p>
<p>和 where 元素等价的自定义 trim 元素：</p>
<pre><code class="xml">&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;AND | OR&quot;&gt;
     ...
&lt;/trim&gt;</code></pre>
<p>set 元素可以用于动态包含需要更新的列，而舍去其他的，如：</p>
<pre><code class="xml">&lt;update id=&quot;updateActive&quot;&gt;
    update Author
    &lt;set&gt;
        &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;
        &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;
        &lt;if test=&quot;email != null&quot;&gt;email=#{email}&lt;/if&gt;
    &lt;/set&gt;
&lt;/update&gt;</code></pre>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另一个常用操作是对一个集合进行遍历，通常是在构建 IN 条件语句的时候，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;Post&quot;&gt;
    select * from post p
    where id in
    &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;
             open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
        #{item}
    &lt;/foreach&gt;
&lt;/select&gt;</code></pre>
<blockquote>
<p>foreach 可迭代的对象如 List、Set、Map或数组都可以作为参数。</p>
</blockquote>
<h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>如果要在注解中使用动态SQL，可以使用 script 元素：</p>
<pre><code class="java">    @Update({&quot;&lt;script&gt;&quot;,
      &quot;update Author&quot;,
      &quot;  &lt;set&gt;&quot;,
      &quot;    &lt;if test=&#39;username != null&#39;&gt;username=#{username},&lt;/if&gt;&quot;,
      &quot;    &lt;if test=&#39;password != null&#39;&gt;password=#{password},&lt;/if&gt;&quot;,
      &quot;    &lt;if test=&#39;email != null&#39;&gt;email=#{email},&lt;/if&gt;&quot;,
      &quot;    &lt;if test=&#39;bio != null&#39;&gt;bio=#{bio}&lt;/if&gt;&quot;,
      &quot;  &lt;/set&gt;&quot;,
      &quot;where id=#{id}&quot;,
      &quot;&lt;/script&gt;&quot;})
    void updateAuthorValues(Author author);</code></pre>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文中：</p>
<pre><code class="xml">&lt;select id=&quot;selectBlogs&quot; resultType=&quot;Blog&quot;&gt;
    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot;/&gt;
    select * from blog
    where title like #{pattern}
&lt;/select&gt;</code></pre>
<h2 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h2><pre><code class="xml">&lt;insert id=&quot;insert&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    &lt;if test=&quot;_databaseId == &#39;oracle&#39;&quot;&gt;
      select seq_users.nextval from dual
    &lt;/if&gt;
    &lt;if test=&quot;_databaseId == &#39;db2&#39;&quot;&gt;
      select nextval for seq_users from sysibm.sysdummy1&quot;
    &lt;/if&gt;
  &lt;/selectKey&gt;
  insert into users values (#{id}, #{name})
&lt;/insert&gt;</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/3_XML映射文件/">《MyBatis》读书笔记 - MyBatis XML 映射文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="三、MyBatis-XML-映射文件"><a href="#三、MyBatis-XML-映射文件" class="headerlink" title="三、MyBatis XML 映射文件"></a>三、MyBatis XML 映射文件</h1><p>MyBatis 通过映射 XML 文件的方式，减少了 JDBC 的样板代码，十分的简单。</p>
<p>SQL 映射文件只有少数几个顶级约束：</p>
<ul>
<li>cache - 对给定命名空间的缓存配置</li>
<li>cache-ref - 对其他命名空间缓存配置的引用</li>
<li>resultMap - 描述如何从数据库结果集中加载对象</li>
<li><del>parameterMap - 废弃，参数映射</del></li>
<li>sql - 可重用语句块</li>
<li>insert - 插入语句</li>
<li>update - 更新语句</li>
<li>delete - 删除语句</li>
<li>select - 查询语句</li>
</ul>
<h2 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h2><p>查询语句，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
    SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</code></pre>
<p>select 元素允许你配置很多属性来配置每条语句的作用细节</p>
<pre><code class="xml">&lt;select
          id=&quot;selectPerson&quot;
        parameterType=&quot;int&quot;
        parameterMap=&quot;deprecated&quot;
        result=&quot;hashMap&quot;
        resultMap=&quot;personResultMap&quot;
        flushCache=&quot;false&quot;
        useCache=&quot;true&quot;
        timeout=&quot;10&quot;
        fetchSize=&quot;256&quot;
        statementType=&quot;PREPARED&quot;
        resultSetType=&quot;FORWARD_ONLY&quot;
        &gt;

&lt;/select&gt;</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>命名空间中的唯一标识符，用来引用该语句</td>
</tr>
<tr>
<td>parameterType</td>
<td>传入的参数的完全限定名，可选。MyBatis会通过类型处理器推断具体传入的参数类型</td>
</tr>
<tr>
<td><del>parameterMap</del></td>
<td><del>引用外部 parametermap 的方法</del></td>
</tr>
<tr>
<td>resultType</td>
<td>返回的期望乐行的类的完全限定名或别名。如果结果为集合，则应该设置为集合包含的类型，而不是集合本身。</td>
</tr>
<tr>
<td>resultMap</td>
<td>外部 resultMap 的命名引用。与resultType不能同时使用</td>
</tr>
<tr>
<td>flushCache</td>
<td>默认为false。为true时，只要语句被调用，都会导致本地缓存和二级缓存被清空</td>
</tr>
<tr>
<td>useCache</td>
<td>默认对select元素为true。将本条语句的结果使用二级缓存缓存起来</td>
</tr>
<tr>
<td>timeout</td>
<td>驱动程序等待数据库返回请求结果的秒数，而后抛出异常</td>
</tr>
<tr>
<td>fetchSize</td>
<td>尝试让驱动程序每次批量返回的结果行数和设置的值相等</td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PREPARED(默认)、CALLABLE中的一个</td>
</tr>
<tr>
<td>resultSetType</td>
<td>FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE、DEFAULT中的一个</td>
</tr>
<tr>
<td>databaseId</td>
<td>数据库厂商标识</td>
</tr>
<tr>
<td>resultOrdered</td>
<td>仅针对嵌套select，如果为true，则假设包含了嵌套结果集或是分组，这样返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。使得在获取嵌套结果集时不至于导致内存不够用</td>
</tr>
<tr>
<td>resultSets</td>
<td>针对多结果集情况。将列出语句执行后返回的结果集并给每个结果集一个名称</td>
</tr>
</tbody></table>
<h2 id="二、insert、update、delete"><a href="#二、insert、update、delete" class="headerlink" title="二、insert、update、delete"></a>二、insert、update、delete</h2><p>与 select 参数相似，以一个示例来说明：</p>
<pre><code class="xml">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into  Author(username,password,email) values 
   &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
       (#{item.username},#{item.password},#{item.email})
   &lt;/foreach&gt;
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
    update Author set
     username=#{username},
     password=#{password},
     email=#{email}
    where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
    delete from Author where id=#{id}
&lt;/delete&gt;</code></pre>
<h2 id="三、sql"><a href="#三、sql" class="headerlink" title="三、sql"></a>三、sql</h2><p>该元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以在加载的时候被静态地设置参数。在不同的包含语句中可以设置不同的值到参数占位符上，如：</p>
<pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password&lt;/sql&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
    select
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
    from some_table t1
    cross join some_table t2
&lt;/select&gt;</code></pre>
<blockquote>
<p>cross join 表示笛卡尔积，t1+t2的所有情况</p>
</blockquote>
<p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，如：</p>
<pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;
    ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclud&quot;&gt;
      from
     &lt;includ refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
    select
     field1,field2,field3
    &lt;includ refid=&quot;someinclud&quot;&gt;
     &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
     &lt;property name=&quot;includ_target&quot; value=&quot;sometable&quot;/&gt;
    &lt;/includ&gt;
&lt;/select&gt;</code></pre>
<h2 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h2><pre><code class="xml">&lt;insert id=&quot;selectUser&quot; parameterType=&quot;User&quot;&gt;
    insert into users (id,username,password)
    values (#{id},#{username},#{password})
&lt;/insert&gt;</code></pre>
<p>上面的语句中，User 类型的参数对象传递到了语句中，id、username、password 属性会被查找，然后将它们的值传入预处理语句的参数中。</p>
<p>参数也可以指定一个特殊的数据类型：</p>
<blockquote>
<p>#{property,javaType=int,jdbcType=NUMERIC}</p>
</blockquote>
<p>也可以指定一个特殊的类型处理器类：</p>
<blockquote>
<p>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</p>
</blockquote>
<p>需要保留小数点的数值类型：</p>
<blockquote>
<p>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</p>
</blockquote>
<p>尽管该选项功能强大，但大多数情况下只需要简单地指定属性名，MyBatis 会自己推断类型，顶多<code>需要为可能为空的列指定 jdbcType</code>。</p>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>默认情况下，使用 <code>#{}</code> 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数(就像？一样)。不过有时想直接在 SQL 中插入一个不转义的字符串，如：</p>
<blockquote>
<p>order by ${columnName}</p>
</blockquote>
<p>这样，MyBatis 不会修改或转义字符串。</p>
<p>有时，替换字符串会非常有用，如：</p>
<pre><code class="java">@Select(&quot;select * from user where id=#{id}&quot;)
User findById(@Param(&quot;id&quot;) long id);

@Select(&quot;select * from user where name=#{name}&quot;)
User findByName(@Param(&quot;name&quot;) String name);

@Select(&quot;select * from user where email=#{email}&quot;)
User findByEmail(@Param(&quot;email&quot;) long email);</code></pre>
<p>可以只写一个方法：</p>
<pre><code class="java">@Select(&quot;select * from user where ${column}=#{email}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;email&quot;) long email);</code></pre>
<p>使用的时候，可以如下调用：</p>
<pre><code class="java">User u1 = userMapper.findByColumn(&quot;id&quot;,1L);
User u2 = userMapper.findByColumn(&quot;name&quot;,&quot;zhangsan&quot;);
User u3 = userMapper.findByColumn(&quot;email&quot;,&quot;xx@qq.com&quot;);</code></pre>
<h2 id="五、结果映射"><a href="#五、结果映射" class="headerlink" title="五、结果映射"></a>五、结果映射</h2><p>resultMap 可以将返回结果映射到JavaBean或POJO上。如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>也可以使用类型别名，来代替完全限定名：</p>
<pre><code class="xml">&lt;typeAlias type=&quot;cn.luokaiii.model.User&quot; alias=&quot;User&quot;/&gt;

&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>如果列名与属性名没有精确匹配，可以在 SELECT 语句中对列使用别名来匹配标签，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select 
     id        as &quot;id&quot;,
     username  as &quot;userName&quot;
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>或者使用外部的 <code>resultMap</code> 来映射：</p>
<pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<h3 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h3><pre><code class="xml">&lt;!-- 非常复杂的语句 --&gt;
&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt;
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;!-- 非常复杂的结果映射 --&gt;
&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt;
  &lt;constructor&gt;
    &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;
  &lt;/constructor&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
    &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt;
  &lt;/association&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt;
    &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt;
      &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
    &lt;/discriminator&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="结果映射（resultMap）"><a href="#结果映射（resultMap）" class="headerlink" title="结果映射（resultMap）"></a>结果映射（resultMap）</h3><ul>
<li>constructor - 用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg - ID参数，标记出ID，可以帮助提高整体性能</li>
<li>arg - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id - 一个ID结果</li>
<li>result - 注入到字段或 JavaBean 属性的普通结果</li>
<li>association - 一个复杂类型的关联；许多结果将包装成这种类型<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>collection - 一个复杂类型的集合<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>discriminator - 使用结果值来决定使用哪个 resultMap<ul>
<li>case - 基于某些值的结果映射<ul>
<li>嵌套结果映射 - case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h3><p>id 和 result 元素都将一个列的值映射到一个简单数据类型的属性或字段。</p>
<pre><code class="xml">&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;</code></pre>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>有时，需要使用不可变类来接收，即在构造方法中注入允许在初始化时设置的值，而不暴露出公有方法。</p>
<pre><code class="java">public class User {
    // ...property
    public User(Integer id, String userName, int age){
        // ...set
    }

    // private setter and getter
}</code></pre>
<pre><code class="xml">&lt;constructor&gt;
    &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot;/&gt;
    &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;userName&quot;/&gt;
    &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot;/&gt;
&lt;/constructor&gt;</code></pre>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联（association）元素处理“有一个”类型的关系。</p>
<pre><code class="xml">&lt;association property=&quot;author&quot; cloumn=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/association&gt;</code></pre>
<p>MyBatis 有两种方式加载关联：</p>
<ul>
<li>嵌套 Select 查询：通过执行另一个 SQL 映射语句来加载期望的复杂类型</li>
<li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集</li>
</ul>
<h3 id="关联的嵌套Select查询"><a href="#关联的嵌套Select查询" class="headerlink" title="关联的嵌套Select查询"></a>关联的嵌套Select查询</h3><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
    select * from Author where id=#{id}
&lt;/select&gt;</code></pre>
<p>selectBlog 用来加载博客，selectAuthor 用来加载作者，而 blogResult 结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。</p>
<p>这种方式虽然简单，但是<code>在大型数据集或大型数据表上表现不佳</code>。这个问题被称为“N+1查询问题”：</p>
<ul>
<li>执行了一个单独的 SQL 语句来获取结果的一个列表（就是+1）</li>
<li>对列表返回的每条记录，执行一个 select 查询语句来加载详细信息（就是N）</li>
</ul>
<p>虽然 MyBatis 能够对这样的查询进行延迟加载，但是如果你在加载完记录表后，立即进行了遍历。此时就会触发所有的延迟加载查询，性能会变得很糟糕。</p>
<blockquote>
<p>解决方法：使用联合查询来避免N+1问题</p>
</blockquote>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合元素和关联元素几乎是一样的</p>
<pre><code class="xml">&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;</code></pre>
<h4 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h4><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
    select * from post where blog_id=#{id}
&lt;/select&gt;</code></pre>
<blockquote>
<p><code>javaType=&quot;ArrayList&quot; ofType=&quot;Post&quot;</code> 等同于结果为：ArrayList<post></post></p>
</blockquote>
<h4 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h4><pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h4 id="集合的多结果集（ResultSet）"><a href="#集合的多结果集（ResultSet）" class="headerlink" title="集合的多结果集（ResultSet）"></a>集合的多结果集（ResultSet）</h4><p>可以通过执行存储过程来实现，存储过程会执行两个查询并返回两个结果集。</p>
<pre><code class="sql">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}</code></pre>
<p>在映射时，必须通过 resultSets 属性为每个结果集指定一个名字，使用逗号隔开。</p>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt;
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;</code></pre>
<p>指定结果集的数据进行填充</p>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="鉴别器（discriminator）"><a href="#鉴别器（discriminator）" class="headerlink" title="鉴别器（discriminator）"></a>鉴别器（discriminator）</h3><p>有时，一个数据库查询可能会返回多个不同的结果集。鉴别器元素就是被设计出来应对这种情况的，也能处理如类的继承层次结构的问题。类似于 java 语言中的 switch 语句。</p>
<pre><code class="xml">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><p>在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，则需要自行构建一个结果映射。</p>
<h2 id="六、缓存"><a href="#六、缓存" class="headerlink" title="六、缓存"></a>六、缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，可以非常方便地配置和定制。</p>
<p>默认情况下，只启用了本地的会话缓存，仅对一个会话中的数据进行缓存。要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<blockquote>
<cache>
</cache></blockquote>
<p>其效果如下：</p>
<ul>
<li>映射语句文件中的所有 select 结果都将被缓存</li>
<li>映射语句文件中的所有 insert、update、delete 都会刷新缓存</li>
<li>缓存会使用 最少使用算法 来清除不需要的缓存</li>
<li>缓存不会定时进行刷新</li>
<li>缓存会保存列表或对象的1024个引用</li>
<li>缓存会被视为读/写缓存，意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或县城所做的潜在修改</li>
</ul>
<blockquote>
<p>缓存只作用于 cache 标签所在的映射文件中的语句。混用 API和XML，在共用接口中的语句将不会被默认缓存。 可以修改cache 元素的属性：</p>
</blockquote>
<pre><code class="xml">&lt;cache 
       eviction=&quot;FIFO&quot; // FIFO缓存
       flushInerval=&quot;60000&quot; // 每隔60秒刷新
       size=&quot;512&quot;         // 最多可存512个引用
       readOnly=&quot;true&quot;  // 返回对象只读
/&gt;</code></pre>
<p>可用的清除策略：</p>
<ul>
<li>LRU - 最近最少使用：移除最长时间不被使用的对象</li>
<li>FIFO - 先进先出：按对象进入缓存的顺序来移除他们</li>
<li>SOFT - 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li>WEAK - 弱引用：更积极地基于垃圾回收期状态和弱引用规则移除对象</li>
</ul>
<h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><p>通过实现 Cache 接口或者第三方缓存方案，来完全覆盖缓存行为。</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;</code></pre>
<blockquote>
<p>上面说到的缓存配置（如清除策略、可读写等），不适用于自定义缓存</p>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>