<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">239</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/3_XML映射文件/">《MyBatis》读书笔记 - MyBatis XML 映射文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="三、MyBatis-XML-映射文件"><a href="#三、MyBatis-XML-映射文件" class="headerlink" title="三、MyBatis XML 映射文件"></a>三、MyBatis XML 映射文件</h1><p>MyBatis 通过映射 XML 文件的方式，减少了 JDBC 的样板代码，十分的简单。</p>
<p>SQL 映射文件只有少数几个顶级约束：</p>
<ul>
<li>cache - 对给定命名空间的缓存配置</li>
<li>cache-ref - 对其他命名空间缓存配置的引用</li>
<li>resultMap - 描述如何从数据库结果集中加载对象</li>
<li><del>parameterMap - 废弃，参数映射</del></li>
<li>sql - 可重用语句块</li>
<li>insert - 插入语句</li>
<li>update - 更新语句</li>
<li>delete - 删除语句</li>
<li>select - 查询语句</li>
</ul>
<h2 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h2><p>查询语句，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
    SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</code></pre>
<p>select 元素允许你配置很多属性来配置每条语句的作用细节</p>
<pre><code class="xml">&lt;select
          id=&quot;selectPerson&quot;
        parameterType=&quot;int&quot;
        parameterMap=&quot;deprecated&quot;
        result=&quot;hashMap&quot;
        resultMap=&quot;personResultMap&quot;
        flushCache=&quot;false&quot;
        useCache=&quot;true&quot;
        timeout=&quot;10&quot;
        fetchSize=&quot;256&quot;
        statementType=&quot;PREPARED&quot;
        resultSetType=&quot;FORWARD_ONLY&quot;
        &gt;

&lt;/select&gt;</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>命名空间中的唯一标识符，用来引用该语句</td>
</tr>
<tr>
<td>parameterType</td>
<td>传入的参数的完全限定名，可选。MyBatis会通过类型处理器推断具体传入的参数类型</td>
</tr>
<tr>
<td><del>parameterMap</del></td>
<td><del>引用外部 parametermap 的方法</del></td>
</tr>
<tr>
<td>resultType</td>
<td>返回的期望乐行的类的完全限定名或别名。如果结果为集合，则应该设置为集合包含的类型，而不是集合本身。</td>
</tr>
<tr>
<td>resultMap</td>
<td>外部 resultMap 的命名引用。与resultType不能同时使用</td>
</tr>
<tr>
<td>flushCache</td>
<td>默认为false。为true时，只要语句被调用，都会导致本地缓存和二级缓存被清空</td>
</tr>
<tr>
<td>useCache</td>
<td>默认对select元素为true。将本条语句的结果使用二级缓存缓存起来</td>
</tr>
<tr>
<td>timeout</td>
<td>驱动程序等待数据库返回请求结果的秒数，而后抛出异常</td>
</tr>
<tr>
<td>fetchSize</td>
<td>尝试让驱动程序每次批量返回的结果行数和设置的值相等</td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PREPARED(默认)、CALLABLE中的一个</td>
</tr>
<tr>
<td>resultSetType</td>
<td>FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE、DEFAULT中的一个</td>
</tr>
<tr>
<td>databaseId</td>
<td>数据库厂商标识</td>
</tr>
<tr>
<td>resultOrdered</td>
<td>仅针对嵌套select，如果为true，则假设包含了嵌套结果集或是分组，这样返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。使得在获取嵌套结果集时不至于导致内存不够用</td>
</tr>
<tr>
<td>resultSets</td>
<td>针对多结果集情况。将列出语句执行后返回的结果集并给每个结果集一个名称</td>
</tr>
</tbody></table>
<h2 id="二、insert、update、delete"><a href="#二、insert、update、delete" class="headerlink" title="二、insert、update、delete"></a>二、insert、update、delete</h2><p>与 select 参数相似，以一个示例来说明：</p>
<pre><code class="xml">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into  Author(username,password,email) values 
   &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
       (#{item.username},#{item.password},#{item.email})
   &lt;/foreach&gt;
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
    update Author set
     username=#{username},
     password=#{password},
     email=#{email}
    where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
    delete from Author where id=#{id}
&lt;/delete&gt;</code></pre>
<h2 id="三、sql"><a href="#三、sql" class="headerlink" title="三、sql"></a>三、sql</h2><p>该元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以在加载的时候被静态地设置参数。在不同的包含语句中可以设置不同的值到参数占位符上，如：</p>
<pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password&lt;/sql&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
    select
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
    from some_table t1
    cross join some_table t2
&lt;/select&gt;</code></pre>
<blockquote>
<p>cross join 表示笛卡尔积，t1+t2的所有情况</p>
</blockquote>
<p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，如：</p>
<pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;
    ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclud&quot;&gt;
      from
     &lt;includ refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
    select
     field1,field2,field3
    &lt;includ refid=&quot;someinclud&quot;&gt;
     &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
     &lt;property name=&quot;includ_target&quot; value=&quot;sometable&quot;/&gt;
    &lt;/includ&gt;
&lt;/select&gt;</code></pre>
<h2 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h2><pre><code class="xml">&lt;insert id=&quot;selectUser&quot; parameterType=&quot;User&quot;&gt;
    insert into users (id,username,password)
    values (#{id},#{username},#{password})
&lt;/insert&gt;</code></pre>
<p>上面的语句中，User 类型的参数对象传递到了语句中，id、username、password 属性会被查找，然后将它们的值传入预处理语句的参数中。</p>
<p>参数也可以指定一个特殊的数据类型：</p>
<blockquote>
<p>#{property,javaType=int,jdbcType=NUMERIC}</p>
</blockquote>
<p>也可以指定一个特殊的类型处理器类：</p>
<blockquote>
<p>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</p>
</blockquote>
<p>需要保留小数点的数值类型：</p>
<blockquote>
<p>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</p>
</blockquote>
<p>尽管该选项功能强大，但大多数情况下只需要简单地指定属性名，MyBatis 会自己推断类型，顶多<code>需要为可能为空的列指定 jdbcType</code>。</p>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>默认情况下，使用 <code>#{}</code> 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数(就像？一样)。不过有时想直接在 SQL 中插入一个不转义的字符串，如：</p>
<blockquote>
<p>order by ${columnName}</p>
</blockquote>
<p>这样，MyBatis 不会修改或转义字符串。</p>
<p>有时，替换字符串会非常有用，如：</p>
<pre><code class="java">@Select(&quot;select * from user where id=#{id}&quot;)
User findById(@Param(&quot;id&quot;) long id);

@Select(&quot;select * from user where name=#{name}&quot;)
User findByName(@Param(&quot;name&quot;) String name);

@Select(&quot;select * from user where email=#{email}&quot;)
User findByEmail(@Param(&quot;email&quot;) long email);</code></pre>
<p>可以只写一个方法：</p>
<pre><code class="java">@Select(&quot;select * from user where ${column}=#{email}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;email&quot;) long email);</code></pre>
<p>使用的时候，可以如下调用：</p>
<pre><code class="java">User u1 = userMapper.findByColumn(&quot;id&quot;,1L);
User u2 = userMapper.findByColumn(&quot;name&quot;,&quot;zhangsan&quot;);
User u3 = userMapper.findByColumn(&quot;email&quot;,&quot;xx@qq.com&quot;);</code></pre>
<h2 id="五、结果映射"><a href="#五、结果映射" class="headerlink" title="五、结果映射"></a>五、结果映射</h2><p>resultMap 可以将返回结果映射到JavaBean或POJO上。如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>也可以使用类型别名，来代替完全限定名：</p>
<pre><code class="xml">&lt;typeAlias type=&quot;cn.luokaiii.model.User&quot; alias=&quot;User&quot;/&gt;

&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>如果列名与属性名没有精确匹配，可以在 SELECT 语句中对列使用别名来匹配标签，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select 
     id        as &quot;id&quot;,
     username  as &quot;userName&quot;
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>或者使用外部的 <code>resultMap</code> 来映射：</p>
<pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<h3 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h3><pre><code class="xml">&lt;!-- 非常复杂的语句 --&gt;
&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt;
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;!-- 非常复杂的结果映射 --&gt;
&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt;
  &lt;constructor&gt;
    &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;
  &lt;/constructor&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
    &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt;
  &lt;/association&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt;
    &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt;
      &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
    &lt;/discriminator&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="结果映射（resultMap）"><a href="#结果映射（resultMap）" class="headerlink" title="结果映射（resultMap）"></a>结果映射（resultMap）</h3><ul>
<li>constructor - 用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg - ID参数，标记出ID，可以帮助提高整体性能</li>
<li>arg - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id - 一个ID结果</li>
<li>result - 注入到字段或 JavaBean 属性的普通结果</li>
<li>association - 一个复杂类型的关联；许多结果将包装成这种类型<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>collection - 一个复杂类型的集合<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>discriminator - 使用结果值来决定使用哪个 resultMap<ul>
<li>case - 基于某些值的结果映射<ul>
<li>嵌套结果映射 - case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h3><p>id 和 result 元素都将一个列的值映射到一个简单数据类型的属性或字段。</p>
<pre><code class="xml">&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;</code></pre>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>有时，需要使用不可变类来接收，即在构造方法中注入允许在初始化时设置的值，而不暴露出公有方法。</p>
<pre><code class="java">public class User {
    // ...property
    public User(Integer id, String userName, int age){
        // ...set
    }

    // private setter and getter
}</code></pre>
<pre><code class="xml">&lt;constructor&gt;
    &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot;/&gt;
    &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;userName&quot;/&gt;
    &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot;/&gt;
&lt;/constructor&gt;</code></pre>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联（association）元素处理“有一个”类型的关系。</p>
<pre><code class="xml">&lt;association property=&quot;author&quot; cloumn=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/association&gt;</code></pre>
<p>MyBatis 有两种方式加载关联：</p>
<ul>
<li>嵌套 Select 查询：通过执行另一个 SQL 映射语句来加载期望的复杂类型</li>
<li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集</li>
</ul>
<h3 id="关联的嵌套Select查询"><a href="#关联的嵌套Select查询" class="headerlink" title="关联的嵌套Select查询"></a>关联的嵌套Select查询</h3><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
    select * from Author where id=#{id}
&lt;/select&gt;</code></pre>
<p>selectBlog 用来加载博客，selectAuthor 用来加载作者，而 blogResult 结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。</p>
<p>这种方式虽然简单，但是<code>在大型数据集或大型数据表上表现不佳</code>。这个问题被称为“N+1查询问题”：</p>
<ul>
<li>执行了一个单独的 SQL 语句来获取结果的一个列表（就是+1）</li>
<li>对列表返回的每条记录，执行一个 select 查询语句来加载详细信息（就是N）</li>
</ul>
<p>虽然 MyBatis 能够对这样的查询进行延迟加载，但是如果你在加载完记录表后，立即进行了遍历。此时就会触发所有的延迟加载查询，性能会变得很糟糕。</p>
<blockquote>
<p>解决方法：使用联合查询来避免N+1问题</p>
</blockquote>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合元素和关联元素几乎是一样的</p>
<pre><code class="xml">&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;</code></pre>
<h4 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h4><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
    select * from post where blog_id=#{id}
&lt;/select&gt;</code></pre>
<blockquote>
<p><code>javaType=&quot;ArrayList&quot; ofType=&quot;Post&quot;</code> 等同于结果为：ArrayList<post></post></p>
</blockquote>
<h4 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h4><pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h4 id="集合的多结果集（ResultSet）"><a href="#集合的多结果集（ResultSet）" class="headerlink" title="集合的多结果集（ResultSet）"></a>集合的多结果集（ResultSet）</h4><p>可以通过执行存储过程来实现，存储过程会执行两个查询并返回两个结果集。</p>
<pre><code class="sql">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}</code></pre>
<p>在映射时，必须通过 resultSets 属性为每个结果集指定一个名字，使用逗号隔开。</p>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt;
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;</code></pre>
<p>指定结果集的数据进行填充</p>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="鉴别器（discriminator）"><a href="#鉴别器（discriminator）" class="headerlink" title="鉴别器（discriminator）"></a>鉴别器（discriminator）</h3><p>有时，一个数据库查询可能会返回多个不同的结果集。鉴别器元素就是被设计出来应对这种情况的，也能处理如类的继承层次结构的问题。类似于 java 语言中的 switch 语句。</p>
<pre><code class="xml">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><p>在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，则需要自行构建一个结果映射。</p>
<h2 id="六、缓存"><a href="#六、缓存" class="headerlink" title="六、缓存"></a>六、缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，可以非常方便地配置和定制。</p>
<p>默认情况下，只启用了本地的会话缓存，仅对一个会话中的数据进行缓存。要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<blockquote>
<cache>
</cache></blockquote>
<p>其效果如下：</p>
<ul>
<li>映射语句文件中的所有 select 结果都将被缓存</li>
<li>映射语句文件中的所有 insert、update、delete 都会刷新缓存</li>
<li>缓存会使用 最少使用算法 来清除不需要的缓存</li>
<li>缓存不会定时进行刷新</li>
<li>缓存会保存列表或对象的1024个引用</li>
<li>缓存会被视为读/写缓存，意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或县城所做的潜在修改</li>
</ul>
<blockquote>
<p>缓存只作用于 cache 标签所在的映射文件中的语句。混用 API和XML，在共用接口中的语句将不会被默认缓存。 可以修改cache 元素的属性：</p>
</blockquote>
<pre><code class="xml">&lt;cache 
       eviction=&quot;FIFO&quot; // FIFO缓存
       flushInerval=&quot;60000&quot; // 每隔60秒刷新
       size=&quot;512&quot;         // 最多可存512个引用
       readOnly=&quot;true&quot;  // 返回对象只读
/&gt;</code></pre>
<p>可用的清除策略：</p>
<ul>
<li>LRU - 最近最少使用：移除最长时间不被使用的对象</li>
<li>FIFO - 先进先出：按对象进入缓存的顺序来移除他们</li>
<li>SOFT - 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li>WEAK - 弱引用：更积极地基于垃圾回收期状态和弱引用规则移除对象</li>
</ul>
<h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><p>通过实现 Cache 接口或者第三方缓存方案，来完全覆盖缓存行为。</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;</code></pre>
<blockquote>
<p>上面说到的缓存配置（如清除策略、可读写等），不适用于自定义缓存</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《SpringSecurity》/23.自定义权限验证/">《Spring Security》自定义权限验证@PreAuthorize</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spring-Security/">Spring Security</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a></span><div class="content"><h1 id="自定义安全表达式"><a href="#自定义安全表达式" class="headerlink" title="自定义安全表达式"></a>自定义安全表达式</h1><pre><code class="java">/**
 * Base root object for use in Spring Security expression evaluations.
 *
 * @author Luke Taylor
 * @since 3.0
 */
public abstract class SecurityExpressionRoot implements SecurityExpressionOperations</code></pre>
<p>SecurityExpressionRoot 是所有安全表达式的基类，我们需要做的就是：</p>
<ol>
<li>继承 SecurityExpressionRoot，自定义 MethodSecurity 表达式</li>
<li>继承 DefaultMethodSecurityExpressionHandler，自定义方法级别的安全校验处理器</li>
<li>继承 GlobalMethodSecurityConfiguration，添加自定义的表达式处理器</li>
</ol>
<h2 id="一、MethodSecurityConfig"><a href="#一、MethodSecurityConfig" class="headerlink" title="一、MethodSecurityConfig"></a>一、MethodSecurityConfig</h2><p>开启方法级别的安全校验，注入登录用户时加载 UserDetails 的DB服务对象，通过 createExpressionHandler 注入自定义的表达式处理器。</p>
<pre><code class="java">/**
 * 配置 MethodSecurity 表达式
 */
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

    private final LoginDetailService loginDetailService;

    public MethodSecurityConfig(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        return new ResourceMethodSecurityExpressionHandler(loginDetailService);
    }
}</code></pre>
<h2 id="二、ResourceMethodSecurityExpressionHandler"><a href="#二、ResourceMethodSecurityExpressionHandler" class="headerlink" title="二、ResourceMethodSecurityExpressionHandler"></a>二、ResourceMethodSecurityExpressionHandler</h2><p>接收 UserDetailsService，并创建一个处理表达式的操作类</p>
<pre><code class="java">/**
 * 自定义方法级别的安全校验处理器
 */
public class ResourceMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {

    private final LoginDetailService loginDetailService;

    private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();

    public ResourceMethodSecurityExpressionHandler(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
        final ResourceMethodSecurityExpressionRoot root = new ResourceMethodSecurityExpressionRoot(authentication, loginDetailService);
        root.setPermissionEvaluator(getPermissionEvaluator());
        root.setTrustResolver(this.trustResolver);
        root.setRoleHierarchy(getRoleHierarchy());
        return root;
    }
}</code></pre>
<h2 id="三、ResourceMethodSecurityExpressionRoot"><a href="#三、ResourceMethodSecurityExpressionRoot" class="headerlink" title="三、ResourceMethodSecurityExpressionRoot"></a>三、ResourceMethodSecurityExpressionRoot</h2><p>仿照 hasAuthority，编写一个自己的实现</p>
<pre><code class="java">/**
 * 自定义 MethodSecurity 表达式
 */
@Slf4j
public class ResourceMethodSecurityExpressionRoot extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {

    private LoginDetailService loginDetailService;

    private Object filterObject;
    private Object returnObject;
    private Object target;

    public ResourceMethodSecurityExpressionRoot(Authentication authentication, LoginDetailService loginDetailService) {
        super(authentication);
        this.loginDetailService = loginDetailService;
    }

    /**
     * 自定义接口，是否允许对该id的访问
     */
    public boolean canReadCourse(String courseId) {
        log.debug(&quot;method params courseId&quot;, courseId);
        log.debug(&quot;current principal {}&quot;, getPrincipal());
        return true;
    }

    public final boolean hasGlobalAuthority(String authority) {
        return hasAnyGlobalAuthority(authority);
    }

    public final boolean hasAnyGlobalAuthority(String... authorities) {
        return hasAnyGlobalAuthorityName(null, authorities);
    }

    private boolean hasAnyGlobalAuthorityName(String prefix, String... roles) {
        final String username = ((UserDetails) getPrincipal()).getUsername();
        final UserDetails details = loginDetailService.loadUserByUsername(username);

        if (details.getAuthorities() != null) {
            final Set&lt;String&gt; roleSet = details.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority).collect(Collectors.toSet());

            for (String role : roles) {
                String defaultedRole = getRoleWithDefaultPrefix(prefix, role);
                if (roleSet.contains(defaultedRole)) {
                    return true;
                }
            }
        }

        return false;
    }

    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) {
        if (role == null) {
            return role;
        }
        if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) {
            return role;
        }
        if (role.startsWith(defaultRolePrefix)) {
            return role;
        }
        return defaultRolePrefix + role;
    }

    @Override
    public void setFilterObject(Object filterObject) {
        this.filterObject = filterObject;
    }

    @Override
    public Object getFilterObject() {
        return filterObject;
    }

    @Override
    public void setReturnObject(Object returnObject) {
        this.returnObject = returnObject;
    }

    @Override
    public Object getReturnObject() {
        return returnObject;
    }

    @Override
    public Object getThis() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    @Override
    public void setRoleHierarchy(RoleHierarchy roleHierarchy) {
        super.setRoleHierarchy(roleHierarchy);
    }
}</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/2_XML配置/">《MyBatis》读书笔记 - MyBatis 中的 XML 详细配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="二、MyBatis-中的-XML-详细配置"><a href="#二、MyBatis-中的-XML-详细配置" class="headerlink" title="二、MyBatis 中的 XML 详细配置"></a>二、MyBatis 中的 XML 详细配置</h1><p>MyBatis 的配置文件包含了深深影响 MyBatis 行为的设置和属性信息。配置文档的顶层结构如下：</p>
<ul>
<li>configuration(配置)<ul>
<li>properties(属性)</li>
<li>settings(设置)</li>
<li>typealiases(类型别名)</li>
<li>typeHandlers(类型处理器)</li>
<li>objectFactory(对象工厂)</li>
<li>plugins(插件)</li>
<li>environments(环境配置)<ul>
<li>environment(环境变量)<ul>
<li>transactionManager(事务管理器)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider(数据库厂商标识)</li>
<li>mappers(映射器)</li>
</ul>
</li>
</ul>
<h2 id="一、属性（Properties）"><a href="#一、属性（Properties）" class="headerlink" title="一、属性（Properties）"></a>一、属性（Properties）</h2><p>这些属性都是可外部配置且可动态替换的，如：</p>
<pre><code class="xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;12345678&quot;/&gt;
&lt;/properties&gt;</code></pre>
<p>可替换的动态配置属性值：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>如果属性不值在一个地方进行了配置，那么 MyBatis 的加载顺序如下：</p>
<ul>
<li>首先读取在 properties 元素体内属性值</li>
<li>根据 properties 元素中的 resource 属性读取类路径下的文件或 url 读取属性文件，并覆盖已读取的同名属性</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性</li>
</ul>
<p>因此，方法参数传递的属性优先级最高，其次是 resource/url 指定的配置文件，最后是 properties 中指定的属性。</p>
<p>在 MyBatis 3.4.2 开始，可以为占位符制定一个默认值，如：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!-- 如果属性 username 没有配置，那么默认值为 ut_user --&gt;
     &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>这个特性默认是关闭的，应该添加一个指定的属性来开启这个特性，如：</p>
<pre><code class="xml">&lt;properties resoure=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;!-- 启用默认值特性 --&gt;
    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot; /&gt;
&lt;/properties&gt;</code></pre>
<h2 id="二、设置（settings）"><a href="#二、设置（settings）" class="headerlink" title="二、设置（settings）"></a>二、设置（settings）</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为，下标描述了设置中各项的意图、默认值等。</p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>全局地开关映射器中已经配置的缓存</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关，所有关联对象都会延迟加载，可以通过 fetchType 来覆盖该项</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>开启时，任何方法的调用都会加载该对象的所有属性。否则，每个对象会按需加载</td>
</tr>
<tr>
<td>multipleResultSetsEnabled</td>
<td>是否允许单一语句返回多结果集（需要驱动支持）</td>
</tr>
<tr>
<td>useColumnLabel</td>
<td>使用列标签代替列名</td>
</tr>
<tr>
<td>useGeneratedKeys</td>
<td>允许 JDBC 支持自动生成主键</td>
</tr>
<tr>
<td>autoMappingBehavior</td>
<td>指定MyBatis应如何自动映射列到字段或属性。NONE：取消自动映射；PARTIAL：自动映射没有定义嵌套结果集的；FULL：自动映射任意复杂的结果集</td>
</tr>
<tr>
<td>autoMappingUnknownColumnBehavior</td>
<td>指定发现自动映射目标未知列（或未知属性）的行为。NONE：不做任何反应；WARNING：输出提醒日志；FAILING：映射失败（抛出SqlSessionException）</td>
</tr>
<tr>
<td>defaultExecutorType</td>
<td>配置默认的执行器。SIMPLE：普通执行器；REUSE 执行器会重用预处理语句；BATCH：执行器将重用语句并执行批量更新</td>
</tr>
<tr>
<td>defaultStatementTimeout</td>
<td>设置超时时间，决定驱动等待数据库响应的描述</td>
</tr>
<tr>
<td>defaultFetchSize</td>
<td>为驱动的结果集获取数量（fetchSize）设置一个提示值</td>
</tr>
<tr>
<td>defaultResultSetType</td>
<td>指定每个语句的省略滚动策略</td>
</tr>
<tr>
<td>safeRowBoundsEnabled</td>
<td>允许在嵌套语句中使用分页（RowBounds）。false为允许</td>
</tr>
<tr>
<td>safeResultHandlerEnabled</td>
<td>允许在嵌套局域中使用分页(RowHandler)。false为允许</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启自动驼峰命名规则映射，即从列名 A_COLUMN 到 Java 属性名 aColumn 的类似映射</td>
</tr>
<tr>
<td>localCacheScope</td>
<td>MyBatis 利用本地缓存机制防止循环引用和加速重复嵌套查询。SESSION：默认，会缓存一个会话中执行的所有查询；STATEMENT：仅用在局域执行上，对相同的 SqlSession 的不同调用不会共享数据</td>
</tr>
<tr>
<td>jdbcTypeForNull</td>
<td>当没有参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型</td>
</tr>
<tr>
<td>lazyLoadTriggerMethods</td>
<td>指定哪个对象的方法触发一次延迟加载</td>
</tr>
<tr>
<td>defaultScriptingLanguage</td>
<td>指定动态 SQL 生成的默认语言</td>
</tr>
<tr>
<td>defaultEnumTypeHandler</td>
<td>指定 Enum 使用的默认 TypeHandler(3.4.5)</td>
</tr>
<tr>
<td>callSettersOnNulls</td>
<td>指定当结果集中值为 null 时，是否调用映射对象的 setter 方法。</td>
</tr>
<tr>
<td>returnInstanceForEmptyRow</td>
<td>当返回的列都是空时，MyBatis默认返回 null。开启后，会返回一个空实例</td>
</tr>
<tr>
<td>logPrefix</td>
<td>指定 MyBatis 增加到日志名称的前缀</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找</td>
</tr>
<tr>
<td>proxyFactory</td>
<td>指定 MyBatis 创建具有延迟加载能力的对象所用到的代理工具</td>
</tr>
<tr>
<td>vfsImpl</td>
<td>指定 VFS 的实现</td>
</tr>
<tr>
<td>useActualParamName</td>
<td>允许使用方法签名中的名称作为语句参数名称。需要java 8编译，并加上 -parameters 选项</td>
</tr>
<tr>
<td>configurationFactory</td>
<td>指定一个提供 Configuration 实例的类。这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。这个类必须包含一个签名为 static Configuration getConfiguration() 的方法(3.2.3)</td>
</tr>
</tbody></table>
<p>一个完整的 settings 元素示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;multipleResultSetEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;EXAMPLE&quot;/&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
&lt;/settings&gt;</code></pre>
<h2 id="三、类型别名（typeAliases）"><a href="#三、类型别名（typeAliases）" class="headerlink" title="三、类型别名（typeAliases）"></a>三、类型别名（typeAliases）</h2><p>类型别名用来减少类完全限定名的冗余，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;typeAlias alias=&quot;Author&quot; type=&quot;cn.luokaiii.adminservice.model.Author&quot;/&gt;
    &lt;typeAlias alias=&quot;Teacher&quot; type=&quot;cn.luokaiii.adminservice.model.Teacher&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
<p>也可以指定一个报名，MyBatis 会在包名下搜索 Java Bean，在没有注解的情况下，会使用Bean 的首字母小写的非限定类名来作为它的别名，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;package name=&quot;domain.blog&quot; /&gt;
&lt;/typeAliases&gt;</code></pre>
<p>或者使用注解的方式，如：</p>
<pre><code class="java">@Alias(&quot;author&quot;)
public class Author {
    ......
}</code></pre>
<p>Java 类型内建的相应类型别名（不区分大小写）：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashMap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="四、类型处理器（typeHandlers）"><a href="#四、类型处理器（typeHandlers）" class="headerlink" title="四、类型处理器（typeHandlers）"></a>四、类型处理器（typeHandlers）</h2><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换为 Java 类型。</p>
<table>
<thead>
<tr>
<th>类型处理器</th>
<th>Java 类型</th>
<th>JDBC 类型</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanTypeHandler</td>
<td>Java.lang.Boolean,boolean</td>
<td>BOOLEAN</td>
</tr>
<tr>
<td>ByteTypeHandler</td>
<td>java.lang.Byte,byte</td>
<td>NUMERIC,BYTE</td>
</tr>
<tr>
<td>ShortTypeHandler</td>
<td>java.lang.Short,short</td>
<td>NUMERIC,SMALLINT</td>
</tr>
<tr>
<td>IntegerTypeHandler</td>
<td>java.lang.Integer,int</td>
<td>NUMERIC,INTEGER</td>
</tr>
<tr>
<td>FloatTypeHandler</td>
<td>java.lang.Float,float</td>
<td>NUMERIC,FLOAT</td>
</tr>
<tr>
<td>DoubleTypeHandler</td>
<td>java.lang.Double,double</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>BigDecimalTypeHandler</td>
<td>java.math.BigDecimal</td>
<td>NUMERIC,DECIMAL</td>
</tr>
<tr>
<td>StringTypeHandler</td>
<td>java.lang.String</td>
<td>CHAR,VARCHAR</td>
</tr>
<tr>
<td>ClobReaderTypeHandler</td>
<td>java.io.Reader</td>
<td>-</td>
</tr>
<tr>
<td>ClobTypeHandler</td>
<td>java.lang.String</td>
<td>CLOB,LONGVARCHAR</td>
</tr>
<tr>
<td>NStringTypeHandler</td>
<td>java.lang.String</td>
<td>NVARCHAR,NCHAR</td>
</tr>
<tr>
<td>NClobTypeHandler</td>
<td>java.lang.String</td>
<td>NCLOB</td>
</tr>
<tr>
<td>BlobInputStreamTypeHandler</td>
<td>java.io.InputStream</td>
<td>-</td>
</tr>
<tr>
<td>ByteArrayTypeHandler</td>
<td>byte[]</td>
<td></td>
</tr>
<tr>
<td>DateTypeHandler</td>
<td>byte[]</td>
<td>L</td>
</tr>
<tr>
<td>DateOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>TimeOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimestampTypeHandler</td>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>SqlDateTypeHandler</td>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimeTypeHandler</td>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>ObjectTypeHandler</td>
<td>Any</td>
<td>OTHER</td>
</tr>
<tr>
<td>EnumTypeHandler</td>
<td>Enum</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>EnumOrdinalTypeHandler</td>
<td>Enum</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>SqlxmlTypeHandler</td>
<td>java.lang.String</td>
<td>SQLXML</td>
</tr>
<tr>
<td>InstantTypeHandler</td>
<td>java.time.Instant</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTimeTypeHandler</td>
<td>java.time.LocalDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTypeHandler</td>
<td>java.time.LocalDate</td>
<td>DATE</td>
</tr>
<tr>
<td>OffsetTimeTypeHandler</td>
<td>java.time.OffsetDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>ZonedDateTimeTypeHandler</td>
<td>java.time.ZonedDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>YearTypeHandler</td>
<td>java.time.Year</td>
<td>INTEGER</td>
</tr>
<tr>
<td>MonthTypeHandler</td>
<td>java.time.Month</td>
<td>INTEGER</td>
</tr>
<tr>
<td>YearMonthTypeHandler</td>
<td>java.time.YearMonth</td>
<td>VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>JapaneseDateTypeHandler</td>
<td>java.time.chrono.JapaneseDate</td>
<td>DATE</td>
</tr>
</tbody></table>
<p>可以通过重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 或集成 org.apache.ibatis.type.BaseTypeHandler，然后将它映射到一个 JDBC 类型：</p>
<pre><code class="java">@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {
  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}</code></pre>
<pre><code class="xml">&lt;typeHandlers&gt;
    &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;</code></pre>
<h2 id="五、对象工厂（objectFactory）"><a href="#五、对象工厂（objectFactory）" class="headerlink" title="五、对象工厂（objectFactory）"></a>五、对象工厂（objectFactory）</h2><p>MyBatis 每次创建结果对象的新实例时，都会使用一个对象工厂（ObjectFactory）实例来完成。要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。</p>
<p>如何想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现，如：</p>
<pre><code class="java">public class ExampleObjectFactory extends DefaultObjectFactory {
    // 包含两个创建方法
    // 处理默认构造方法
    public Object create(Class type){
        return super.create(type);
    }

    // 处理带参数的构造方法
    public Object create(Class type,List&lt;Class&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs){
        return super.create(type,constructorArgTypes,constructorArgs);
    }

    // 可以被用来配置 ObjectFactory，在初始化ObjectFactory后，objectFactory元素体中定义的属性会被传递给 setProperties 方法
    public void setProperties(Properties properties){
        super.setProperties(properties);
    }

    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type){
        return Collection.class.isAssignableFrom(type);
    }
}</code></pre>
<pre><code class="xml">&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;</code></pre>
<h2 id="六、插件（Plugins）"><a href="#六、插件（Plugins）" class="headerlink" title="六、插件（Plugins）"></a>六、插件（Plugins）</h2><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包含：</p>
<ul>
<li>Executor（update、query、flushStatements、commit、rollback、getTransaction、close、isClosed）</li>
<li>ParameterHandler（getParameterObject、setParameters）</li>
<li>ResultSetHandler（handleResultSets、handleOutputParameters）</li>
<li>StatementHandler（prepare、parameterize、batch、update、query）</li>
</ul>
<p>这些都是很底层的类和方法，如果在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis的核心模块，因此在使用插件的时候要当心。</p>
<h2 id="七、环境配置（environments）"><a href="#七、环境配置（environments）" class="headerlink" title="七、环境配置（environments）"></a>七、环境配置（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。</p>
<p>如开发、测试、生产环境需要不同的配置；或者现在相同 Schema 的多个库中使用相同的 SQL 映射。</p>
<blockquote>
<p>尽管可以配置多个环境，但是每个 SqlSessionFactory 实例只能选择一种环境</p>
</blockquote>
<p>环境元素定义了如何配置环境：</p>
<pre><code class="xml">&lt;enviroments default=&quot;development&quot;&gt;
    &lt;enviroment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;...&quot;/&gt;
            ...
        &lt;/dataSource&gt;
    &lt;/enviroment&gt;
&lt;/enviroments&gt;</code></pre>
<p>这里的关键：</p>
<ul>
<li>默认使用的环境ID（default=”development”）</li>
<li>每个元素都有一个环境ID</li>
<li>事务管理器的配置</li>
<li>数据源的配置</li>
</ul>
<h3 id="1-事务管理器（transactionManager）"><a href="#1-事务管理器（transactionManager）" class="headerlink" title="1. 事务管理器（transactionManager）"></a>1. 事务管理器（transactionManager）</h3><p>MyBatis 有两种类型的事务管理器：</p>
<ol>
<li>JDBC - 直接使用 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务作用域</li>
<li>MANAGED - 让容器来管理事务的整个生命周期。默认会关闭连接，然而一些容器不希望这样，因此需要将 closeConnection 设置为 false 来阻止它默认的关闭行为</li>
</ol>
<blockquote>
<p>如果使用 Spring+MyBatis，则没必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</blockquote>
<h3 id="2-数据源（DataSource）"><a href="#2-数据源（DataSource）" class="headerlink" title="2. 数据源（DataSource）"></a>2. 数据源（DataSource）</h3><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<p>MyBatis 提供了三种内建的数据源类型。</p>
<h4 id="UNPOOLED"><a href="#UNPOOLED" class="headerlink" title="UNPOOLED"></a>UNPOOLED</h4><p>每次被请求时打开和关闭连接</p>
<h4 id="POOLED"><a href="#POOLED" class="headerlink" title="POOLED"></a>POOLED</h4><p>使用连接池的方式，避免创建新实例时所需的初始化和认证时间</p>
<h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p>为了能在如 EJB 或应用服务器这类容器汇总使用，容器可以集成或在外部配置数据源</p>
<h4 id="第三方数据源"><a href="#第三方数据源" class="headerlink" title="第三方数据源"></a>第三方数据源</h4><p>可以通过实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 来使用第三方数据源。</p>
<h2 id="八、数据库厂商标识（databaseIdProvider）"><a href="#八、数据库厂商标识（databaseIdProvider）" class="headerlink" title="八、数据库厂商标识（databaseIdProvider）"></a>八、数据库厂商标识（databaseIdProvider）</h2><h2 id="九、映射器（mappers）"><a href="#九、映射器（mappers）" class="headerlink" title="九、映射器（mappers）"></a>九、映射器（mappers）</h2><p>mappers 定义 SQL 映射语句，告诉 MyBatis 去哪里找这些语句。如：</p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用完全限定资源定位符 URL --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/1_入门/">《MyBatis》读书笔记 - 入门</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>构建项目，需要引入如下的 dependency 到 pom.xml 中：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;or.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="2-从XML配置SQLSessionFactory"><a href="#2-从XML配置SQLSessionFactory" class="headerlink" title="2. 从XML配置SQLSessionFactory"></a>2. 从XML配置SQLSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。</p>
<p>以下 XML 配置文件中包含了对 MyBatis 系统的核心设置，如获取数据源(DataSource)和决定事务作用于和控制方式的事务管理器(TransactionManager)：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot; /&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<p>使用类路径下的资源文件进行配置，构建 SqlSessionFactory 实例：</p>
<pre><code class="java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre>
<h2 id="3-从SqlSessionFactory-获取-SqlSession"><a href="#3-从SqlSessionFactory-获取-SqlSession" class="headerlink" title="3. 从SqlSessionFactory 获取 SqlSession"></a>3. 从SqlSessionFactory 获取 SqlSession</h2><p>SqlSession 中完全包含了面向数据库执行 SQL 命令所需的所有方法，例如：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    Blog blog = (Blog)session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;,101);
}</code></pre>
<p>或者使用一种更简单的方式：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Blog blog = mapper.selectBlog(101);
}</code></pre>
<h3 id="提示：命名空间（Namespaces）"><a href="#提示：命名空间（Namespaces）" class="headerlink" title="提示：命名空间（Namespaces）"></a>提示：命名空间（Namespaces）</h3><p>命名空间的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了接口绑定。</p>
<p>命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ol>
<li>完全限定名，将被直接用于查找和使用</li>
<li>短名称，如果全局唯一也可作为单独的应用。如果不唯一，那么使用时就会出现错误，此时就需要使用完全限定名</li>
</ol>
<h2 id="4-基于-XML-映射语句的示例"><a href="#4-基于-XML-映射语句的示例" class="headerlink" title="4. 基于 XML 映射语句的示例"></a>4. 基于 XML 映射语句的示例</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h2 id="5-基于注解的示例"><a href="#5-基于注解的示例" class="headerlink" title="5. 基于注解的示例"></a>5. 基于注解的示例</h2><pre><code class="java">public interface BlogMapper {
    @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;)
    Blog selectBlog(int id);
}</code></pre>
<h2 id="6-作用域（Scope）和生命周期"><a href="#6-作用域（Scope）和生命周期" class="headerlink" title="6. 作用域（Scope）和生命周期"></a>6. 作用域（Scope）和生命周期</h2><p><code>依赖注入框架</code>可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要了。</p>
<p>因此该实例的最佳作用域为<code>方法作用域</code>，可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory，但是使用后最好不要让其一直存在，以保证 XML 资源可以被释放。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>一旦创建就应该在应用的运行期间一直存在，尽量不要重复创建该实例。</p>
<p>因此该实例的最佳作用域为<code>应用作用域</code>。可以使用单例模式或静态单例模式来做到。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该由自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此不能被共享。</p>
<p>因此该实例的最佳作用于为<code>请求或方法作用域</code>。绝不能将 SqlSession 的实例引用放在静态域中，甚至一个类的实例变量也不行，也不能将引用放在任何类型的托管作用域中（如Servlet 的HttpSession）。</p>
<p>如果您使用的是 Web 框架，那么应该考虑将 SqlSession 放在和 Http 请求对象相似的作用域中。即每次 Http 请求，都打开一个 SqlSession，返回响应后就关闭它。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是映射Sql语句的接口，该接口的实例是从 SqlSession 中获得的。</p>
<p>因此该实例的最佳作用于<code>与 SqlSession 的作用域保持一致</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/分布式/SpringCloud/分布式并发问题/">分布式环境中的并发问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分布式/">分布式</a></span><div class="content"><p>分布式环境中，处理并发问题没发通过操作系统和 JVM 提供的工具来解决，因为 LOCK 命令、总线锁、缓存所、monitor 对象、锁、等并发工具都无法影响到其他服务器的线程。</p>
<p>那么在分布式环境中，可以使用一下策略和方式处理：</p>
<ol>
<li>避免并发<ol>
<li>通过某些策略和业务来避免并发，如合理分配时间调度，避开共享资源的存取冲突等。</li>
<li>可以通过hash算法的方式，使一个对象的数据计算和访问都交给同一个线程来完成</li>
</ol>
</li>
<li>时间戳<ol>
<li>每次系统A发送给系统B的时候都带上一个时间戳，B在拿到通知后，比较时间戳</li>
<li>这样只需要调用方保证时间戳的时序有效性即可</li>
</ol>
</li>
<li>串行化<ol>
<li>串行化可能产生并发的问题，通过牺牲性能和扩展性，来满足对数据一致性的要求。</li>
<li>比如分布式消息系统，没法保证消息的有序性，但是可以通过将分布式消息系统改为单一消息系统，就可以保证消息的有序性了。</li>
<li>如果接收方无法保证处理的有序性，那么可以使用一个队列将调用信息缓存起来，再串行地处理这些调用</li>
</ol>
</li>
<li>数据库<ol>
<li>在分布式环境中，数据库是个服务器的共享点，可以通过数据库的高可靠一致性机制来满足需求。</li>
<li>比如通过唯一性约束，来解决并发过程中重复数据的生产或重复任务的执行</li>
<li>某些更新操作也尽量使用SQL来完成，在程序中计算后再更新，可能会出现脏复写的问题，但是通过一条SQL来完成计算和更新，就能通过数据库的锁机制来保证更新的一致性</li>
</ol>
</li>
<li>行锁<ol>
<li>有些事务较为复杂时，无法通过一条SQL解决问题，并且可能存在并发问题，此时可以考虑使用行锁来解决问题</li>
<li>如 select … for update ，在查询后将该行数据锁定，直到 commit。但是这么做会导致其他涉及该行的所有操作都会被挂起</li>
<li>通过在表中增加一个标志锁的字段，每次操作之前通过update，来模拟竞争锁的操作，操作完成后再update复位该标志，表示锁归还。（这种操作很类似Redis分布式锁、MongoDB分布式锁，说白了就是自己定义一个模拟竞争锁的场景）</li>
</ol>
</li>
<li>统一触发途径<ol>
<li>如果一个数据会被多个业务同时涉及到，就会有并发问题产生的隐患。因此可以通过前期架构和业务涉及，尽量统一触发途径，减少并发的可能，也有利于对并发问题的分析和判断。</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/cutesource/article/details/5791350" target="_blank" rel="noopener">文章总结自 : https://blog.csdn.net/cutesource/article/details/5791350</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>