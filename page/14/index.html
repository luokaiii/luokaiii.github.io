<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>罗凯的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
<meta name="keywords" content="帅">
<meta property="og:type" content="website">
<meta property="og:title" content="罗凯的博客">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="罗凯的博客">
<meta property="og:description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="罗凯的博客">
<meta name="twitter:description" content="如果我16岁，我可以悄悄的说我好喜欢你，如果我26岁，我可以大声告诉你我很爱你，可惜我6岁，我什么都给不了你，我还要上小学。">
  
    <link rel="alternate" href="/atom.xml" title="罗凯的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.loli.net/2019/07/04/5d1db2fb9593c58427.gif">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">罗凯的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个大帅哥</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SpringBoot/SpringSecurity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/SpringBoot/SpringSecurity/" class="article-date">
  <time datetime="2019-07-01T02:49:01.373Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="根据踏瑞云的权限架构，所认知的SpringSecurity"><a href="#根据踏瑞云的权限架构，所认知的SpringSecurity" class="headerlink" title="根据踏瑞云的权限架构，所认知的SpringSecurity"></a>根据踏瑞云的权限架构，所认知的SpringSecurity</h1><h2 id="一、-实体类"><a href="#一、-实体类" class="headerlink" title="一、 实体类"></a>一、 实体类</h2><h2 id="1-1-CoreUser"><a href="#1-1-CoreUser" class="headerlink" title="1.1 CoreUser"></a>1.1 CoreUser</h2><pre><code>用于存储用户的基本信息，如用户名、密码、真实姓名、手机号、邮箱、是否是管理员、是否禁用、学号、备注、学校备注、组织、权限集合
</code></pre><h2 id="1-2-Organization"><a href="#1-2-Organization" class="headerlink" title="1.2 Organization"></a>1.2 Organization</h2><pre><code>组织，包含编号、管理员备注、产品、是否禁用
</code></pre><h2 id="1-3-OrganizationMemeber"><a href="#1-3-OrganizationMemeber" class="headerlink" title="1.3 OrganizationMemeber"></a>1.3 OrganizationMemeber</h2><pre><code>组织成员，包含 用户Id、组织Id、组织权限role
</code></pre><h2 id="1-4-OrganizationMemeberRole"><a href="#1-4-OrganizationMemeberRole" class="headerlink" title="1.4 OrganizationMemeberRole"></a>1.4 OrganizationMemeberRole</h2><pre><code>组织权限：Administrator 管理员、Teacher 教师、Student 学生
</code></pre><h2 id="1-5-OrganizationAuthorization"><a href="#1-5-OrganizationAuthorization" class="headerlink" title="1.5 OrganizationAuthorization"></a>1.5 OrganizationAuthorization</h2><pre><code>组织授权： 授权Id、过期时间、授权的课程集合
</code></pre><h2 id="二、权限类"><a href="#二、权限类" class="headerlink" title="二、权限类"></a>二、权限类</h2><h2 id="2-1-CoreUserDetails"><a href="#2-1-CoreUserDetails" class="headerlink" title="2.1 CoreUserDetails"></a>2.1 CoreUserDetails</h2><pre><code>该类包含了 CoreUser 的信息，和权限的方法，因此需要继承 CoreUser 类和实现 CoreUserDetails 类：UserDetails extends CoreUser implements UserDetails
即：CoreUserDetails = CoreUser用户信息 + UserDetails的方法 + Organization组织 + OrganizationMember组织内的权限 + OrganizationAuthorization组织授权课程
新增参数：
    organizations：List&lt;Organization&gt;  组织集合
    loginName : String  用户名
    organizationMemebers：List&lt;OrganizationMember&gt;    成员与组织对应的权限
    organizationAuthorizations： List&lt;OrganizationAuthorization&gt;    授权内容
三个构造方法：
    1. 无参构造
    2. 含有 登录名 loginName 的构造函数
    3. 含有 组织集合、组织授权集合、登录名 的构造函数
实现了 UserDetails 的 7 个方法
    getAuthorities()        得到权限集合
    getPassword()           密码
    getUsername()           用户名
    isAccountNonExpired()   账户是否未过期
    isAccountNonLocked()    账户是否未被锁
    isCredentialsNonExpired()   证书是否未过期
    isEnabled()             是否可用
</code></pre><h2 id="2-2-LoginUserService"><a href="#2-2-LoginUserService" class="headerlink" title="2.2 LoginUserService"></a>2.2 LoginUserService</h2><pre><code>用户登录的 Service，实现 UserDetailsService 类的 UserDetails loadUserByUsername(String loginName) 方法，该方法返回 UserDetails，因此需要 CoreUserDetails 实现 CoreUserDetails 类，来将 CoreUserDetails 返回。
在实现的方法中：
    1. 通过 loginName (手机号、邮箱、用户名) 查询数据库中是否存在该用户 --&gt; 得到 CoreUser
    2. 构造一个 带 loginName 的 CoreUserDetails，将 CoreUser 注入 CoreUserDetails &lt;&lt;**1**&gt;&gt;
    3. 查询用户对应的 组织权限(memberList)，并添加到 CoreUserDetails，即 coreUserDetails.setOrganizationMembers(memberList) &lt;&lt;**2**&gt;&gt;
    4. 提取 用户组织权限 中的所有组织Id，得到所有的组织信息(organizations)，添加到 CoreUserDetails，即coreUserDetails.setOrganizations(organizations) &lt;&lt;**3**&gt;&gt;
    5. 通过 组织Id ，得到组织下所有的授权信息(authorizations)，添加到 CoreUserDetails，即 coreUserDetails.setOrganizationAuthorizations(authorizations) &lt;&lt;**4**&gt;&gt;
    6. 最后，将注入之后的 coreUserDetails 返回
</code></pre><h2 id="2-3-MethodSecurityConfig"><a href="#2-3-MethodSecurityConfig" class="headerlink" title="2.3 MethodSecurityConfig"></a>2.3 MethodSecurityConfig</h2><blockquote>
<p>开启方法级别的权限验证。<br>    // @EnableGlocalMethodSecurity()在任何 @Configuration 实例上使用，用来开启基于注解的安全验证<br>    //      prePostEnabled = true ； 表示在方法执行之前进行验证<br>    @EnableGlobalMethodSecurity(prePostEnabled = true)<br>    @Configuration<br>    // GlobalMethodSecurityConfiguration 表示基于方法的安全验证<br>    public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {</p>
</blockquote>
<pre><code>    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        // 返回一个 表达式验证的方法级控制器
        return new ResourceMethodSecurityExpressionHandler();
    }
}
</code></pre><h2 id="2-4-ResourceMethodSecurityExpressionHandler"><a href="#2-4-ResourceMethodSecurityExpressionHandler" class="headerlink" title="2.4 ResourceMethodSecurityExpressionHandler"></a>2.4 ResourceMethodSecurityExpressionHandler</h2><pre><code>实现 DefaultMethodSecurityExpressionHandler 控制器的 createSecurityExpressionRoot 方法，重写ResourceMethodSecurityExpressionRoot

public class ResourceMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {

    private AuthenticationTrustResolver trustResolver =
            new AuthenticationTrustResolverImpl();

    @Override
    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
        ResourceMethodSecurityExpressionRoot root =
                new ResourceMethodSecurityExpressionRoot(authentication);
        root.setPermissionEvaluator(getPermissionEvaluator());
        root.setTrustResolver(this.trustResolver);
        root.setRoleHierarchy(getRoleHierarchy());
        return root;
    }
}
</code></pre><h2 id="2-5-ResourceMethodSecurityExpressionRoot"><a href="#2-5-ResourceMethodSecurityExpressionRoot" class="headerlink" title="2.5 ResourceMethodSecurityExpressionRoot"></a>2.5 ResourceMethodSecurityExpressionRoot</h2><pre><code>自定义 MethodSecurity 的表达式，eg：

public class ResourceMethodSecurityExpressionRoot extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {
    private static final Logger logger = LoggerFactory.getLogger(ResourceMethodSecurityExpressionRoot.class);
    private Object filterObject;
    private Object returnObject;
    private Object target;
    public ResourceMethodSecurityExpressionRoot(Authentication authentication) {
        super(authentication);
    }
    // 用来在 @PreAuthorize 注解中使用的方法
    public boolean canReadCourse(String courseId) {
        logger.debug(&quot;method params courseId : {}&quot;, courseId);
        logger.debug(&quot;current principal {}&quot;, getPrincipal());
        return true;
    }
    /** setter and getter */
}
</code></pre><h1 id="三、大致的流程："><a href="#三、大致的流程：" class="headerlink" title="三、大致的流程："></a>三、大致的流程：</h1><pre><code>1. 用户登录，判定用户名密码是否正确，登录成功此时会将登录名交给 UserSetailsService
2. 在 loadUserByUsername(String loginName) 方法中，填充用户的组织等信息，并返回
    此时的用户已经通过 验证了
2. 在请求资源时，在需要判定的方法上加上注解：@PreAuthorize(&quot;hasRole(&apos;Administrator&apos;)&quot;) 
</code></pre><h1 id="四、常用的注解"><a href="#四、常用的注解" class="headerlink" title="四、常用的注解"></a>四、常用的注解</h1><pre><code>access()                    SpringEL表达式结果为true时可访问
anonymous()                 匿名可访问
denyAll()                   用户不可访问
fullyAuthenticated()        用户完全认证可访问（非Remeber me下自动登录）
hasAnyAuthority(String...)  参数中任意 权限 的用户可访问
hasAnyRole(String...)       参数中任意 角色 的用户可访问
hasAuthority(String)        某一 权限 的用户可访问
hasRole(String)             某一 角色 的用户可访问
permitAll()                 所有用户可访问
rememberMe()                允许通过 remeber me 登录的用户访问
hasIpAddress(String)        用户来自参数中的ip时可访问
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/01/SpringBoot/SpringSecurity/" data-id="cjxpj02tf002frgtwdwwufkxk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringBoot/SpringBoot配置文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/SpringBoot/SpringBoot配置文件/" class="article-date">
  <time datetime="2019-07-01T02:49:01.372Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>#SpringBoot�������ļ�.properties
</code></pre><h1 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h1><pre><code>logging.config=classpath:logback-spring.xml
</code></pre><h1 id="Mysql-Configuration"><a href="#Mysql-Configuration" class="headerlink" title="Mysql Configuration"></a>Mysql Configuration</h1><pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/pgc                          #���ݿ��ַ
spring.datasource.username=root                                                #�˺�
spring.datasource.password=password                                            #����
</code></pre><h1 id="Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production"><a href="#Keep-the-connection-alive-if-idle-for-a-long-time-needed-in-production" class="headerlink" title="Keep the connection alive if idle for a long time (needed in production)"></a>Keep the connection alive if idle for a long time (needed in production)</h1><pre><code>spring.datasource.testWhileIdle=true                                        #ָ�������Ƿ񱻿��������ӻ���������
spring.datasource.validationQuery=SELECT 1                                    #��֤�����ӳ�ȡ��������
</code></pre><h1 id="Show-or-not-log-for-each-sql-query"><a href="#Show-or-not-log-for-each-sql-query" class="headerlink" title="Show or not log for each sql query"></a>Show or not log for each sql query</h1><pre><code>spring.jpa.show-sql=true                                                    #����ʱ���sql���
</code></pre><h1 id="Hibernate-ddl-auto-save-save-drop-update"><a href="#Hibernate-ddl-auto-save-save-drop-update" class="headerlink" title="Hibernate ddl auto (save, save-drop, update)"></a>Hibernate ddl auto (save, save-drop, update)</h1><pre><code>spring.jpa.hibernate.ddl-auto=update                                        #hibernate���ݶ���Ĺ��򣬸���
</code></pre><h1 id="Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’"><a href="#Set-to-true-if-we-need-to-populate-the-database-using-‘data-sql’" class="headerlink" title="Set to true if we need to populate the database using ‘data.sql’."></a>Set to true if we need to populate the database using ‘data.sql’.</h1><pre><code>spring.datasource.initialize=false                                            #ָ����ʼ������Դ���Ƿ���data.sql����ʼ����Ĭ��: true
</code></pre><h1 id="Naming-strategy"><a href="#Naming-strategy" class="headerlink" title="Naming strategy"></a>Naming strategy</h1><pre><code>spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy    #ָ����������
</code></pre><h1 id="The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database"><a href="#The-SQL-dialect-makes-Hibernate-generate-better-SQL-for-the-chosen-database" class="headerlink" title="The SQL dialect makes Hibernate generate better SQL for the chosen database"></a>The SQL dialect makes Hibernate generate better SQL for the chosen database</h1><pre><code>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect    #hibernate����
</code></pre><h1 id="Mongodb-Configuration"><a href="#Mongodb-Configuration" class="headerlink" title="Mongodb Configuration"></a>Mongodb Configuration</h1><pre><code>spring.data.mongodb.uri=mongodb://localhost:27000/pgc                        #mongodb��uri
</code></pre><h1 id="OSS-Configuration"><a href="#OSS-Configuration" class="headerlink" title="OSS Configuration"></a>OSS Configuration</h1><pre><code>oss.endpoint=oss-cn-shanghai.aliyuncs.com                                    #oss�����Ƶ��������
oss.access.key.id=LTAIxYKpaBqbAIK3
oss.access.key.secret=WuTDXWS8PBqSdqMuMxrPfT5ryYmmd0
oss.bucket.name=new-pgc
spring.http.multipart.maxFileSize=100MB
spring.http.multipart.maxRequestSize=100MB
</code></pre><h1 id="SSO-Configuration"><a href="#SSO-Configuration" class="headerlink" title="SSO Configuration"></a>SSO Configuration</h1><pre><code>security.enabled=true
</code></pre><p>#Ĭ��callback<br>    security.defaultCallback=/</p>
<p>#sso��֤token��ַ<br>    security.ssoServerValidate=<a href="http://106.15.179.107:7127/api/c/sso/validate-token" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/validate-token</a></p>
<p>#�������Ӧ��û�е�½��ȥ��֤<br>    security.ssoServerAuth=<a href="http://106.15.179.107:7127/api/c/sso/auth" target="_blank" rel="noopener">http://106.15.179.107:7127/api/c/sso/auth</a></p>
<p>#����Ӧ������<br>    security.ssoKey=574163310</p>
<p>#����Ӧ�õ�ַ, should be defined by the same field under each app</p>
<h1 id="security-appHost-http-localhost-8000"><a href="#security-appHost-http-localhost-8000" class="headerlink" title="security.appHost=http://localhost:8000"></a>security.appHost=<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a></h1><p>#gizp<br>    spring.resources.chain.gzipped=true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/01/SpringBoot/SpringBoot配置文件/" data-id="cjxpj02td002crgtwog642j70" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringBoot/SpringBoot常用Listener" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/SpringBoot/SpringBoot常用Listener/" class="article-date">
  <time datetime="2019-07-01T02:49:01.371Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SpringBoot-的几种常见监听器"><a href="#SpringBoot-的几种常见监听器" class="headerlink" title="SpringBoot 的几种常见监听器"></a>SpringBoot 的几种常见监听器</h1><p>例如：在Web项目启动时，需要执行一段代码，该写在哪里呢？<br>解决方法：注册监听器监听 ServletContext 创建的钩子函数，并重写自己的实现</p>
<h2 id="1-创建Listener"><a href="#1-创建Listener" class="headerlink" title="1. 创建Listener"></a>1. 创建Listener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Web Initialized!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Web Destroyed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 @WebListener 注册声明类为监听器</p>
</blockquote>
<h2 id="2-添加-servlet-扫描"><a href="#2-添加-servlet-扫描" class="headerlink" title="2. 添加 servlet 扫描"></a>2. 添加 servlet 扫描</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span>(basePackages = <span class="string">"com.test.*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>启动项目，可在堆栈信息中找到对应的输出</p>
<h2 id="4-常见监听器接口"><a href="#4-常见监听器接口" class="headerlink" title="4. 常见监听器接口"></a>4. 常见监听器接口</h2><ol>
<li>ServletContextListener - 监听 ServletContext 对象的创建及销毁<ol>
<li>contextInitialized(ServletContextEventsce) - web应用程序初始化进程正在启动的通知</li>
<li>contextDestroyed(ServletContextEvent sce) - 通知servlet上下文即将关闭。所有servlet和过滤器之前已经被销毁()</li>
</ol>
</li>
<li>HttpSessionListener - 监听 session 对象的创建及销毁<ol>
<li>sessionCreated(HttpSessionEvent se) - 创建会话的通知</li>
<li>sessionDestroyed(HttpSessionEvent se) - 会话即将失效的通知</li>
</ol>
</li>
<li>ServletRequestListener - 监听 request 对象的创建及销毁<ol>
<li>requestDestroyed(ServletRequestEvent src) - 请求将超出web应用程序的范围</li>
<li>requestInitialized(ServletRequestEvent src) - 请求将进入web应用程序的范围</li>
</ol>
</li>
<li>ServletContextAttributeListener - 监听 servletContext 对象中属性的变化<ol>
<li>attributeAdded(ServletContextAttributeEvent scae) - 通知servlet上下文中添加了一个新属性。在添加属性后调用</li>
<li>attributeRemoved(ServletContextAttributeEvent scae) - 从servlet上下文中删除现有属性的通知。删除属性后调用</li>
<li>attributeReplaced(ServletContextAttributeEvent scae) - 通知servlet上下文上的属性已被替换。替换属性后调用。</li>
</ol>
</li>
<li>HttpSessionAttributeListener - 监听 session 对象中属性的改变<ol>
<li>同 ServletContextAttributeListener</li>
</ol>
</li>
<li>ServletRequestAttributeListener - 监听request 对象中属性的改变<ol>
<li>同 ServletContextAttributeListener</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/01/SpringBoot/SpringBoot常用Listener/" data-id="cjxpj02tb002argtwynrytect" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《JavaDesignPatterns》/7.原型模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/读书笔记/《JavaDesignPatterns》/7.原型模式/" class="article-date">
  <time datetime="2019-06-27T09:11:00.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/读书笔记/《JavaDesignPatterns》/7.原型模式/">《Java Design Patterns》第五章 原型模式 - 对象的克隆</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第五章-原型模式-对象的克隆"><a href="#第五章-原型模式-对象的克隆" class="headerlink" title="第五章 原型模式 - 对象的克隆"></a>第五章 原型模式 - 对象的克隆</h1><p>原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。属于一种对象创建型模式。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p>
<h3 id="1-2-原型模式中的几个角色"><a href="#1-2-原型模式中的几个角色" class="headerlink" title="1.2 原型模式中的几个角色"></a>1.2 原型模式中的几个角色</h3><ol>
<li>Prototype - 抽象原型类<ol>
<li>声明克隆方法的接口，是所有具体原型类的公共父类</li>
</ol>
</li>
<li>ConcretePrototype - 具体原型类<ol>
<li>实现抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</li>
</ol>
</li>
<li>Client - 客户类<ol>
<li>让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。</li>
</ol>
</li>
</ol>
<h3 id="1-3-案例"><a href="#1-3-案例" class="headerlink" title="1.3 案例"></a>1.3 案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeeklyLog</span> <span class="keyword">implements</span> <span class="title">Clonealbe</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publci WeekLog <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            obj = <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> (WeekLog)obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"不支持复制"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、浅克隆与深克隆"><a href="#二、浅克隆与深克隆" class="headerlink" title="二、浅克隆与深克隆"></a>二、浅克隆与深克隆</h2><h3 id="2-1-浅克隆"><a href="#2-1-浅克隆" class="headerlink" title="2.1 浅克隆"></a>2.1 浅克隆</h3><p>在浅克隆中，如果原型对象的成员是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象。也就是说，原型对象的引用类型变量与克隆对象中的变量指向同一内存地址。</p>
<p>即值类型成员变量会被复制，但是引用成员变量不会。</p>
<h3 id="2-2-深克隆"><a href="#2-2-深克隆" class="headerlink" title="2.2 深克隆"></a>2.2 深克隆</h3><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象。</p>
<p>如果需要实现深克隆，可以通过序列化（Serialization）等方式实现：将对象写入到流，再从流中读出。</p>
<blockquote>
<p>Java语言提供的 Cloneable 接口和 Serializable 接口都是空接口，也称为标识接口。标识接口无任何方法定义，只提供告诉JRE这些接口的实现类是否支持克隆、序列化等功能。</p>
</blockquote>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>当创建新对象较为复杂时，可以使用原型模式简化对象的创建过程，复制一个已有实例以提高新实例的创建效率</li>
<li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中</li>
<li>原型模式提供了简化的创建结构，工厂方法模式需要与产品等级结构对应的工厂等级结构，而原型模式则直接通过封装在原型类中的克隆方法实现</li>
<li>深克隆方式可以保存对象的状态</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>需要每个类配置一个克隆方法，且位于类内部，当对类进行改造时需要修改源码，违反了“开闭原则”</li>
<li>实现深克隆时较为复杂，对象的每一层子对象都需要进行深克隆</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>创建新对象成本较大（如初始化时间长、占用CPU资源多或网络资源占用多），新对象能够通过原型模式进行复制，复制相似对象再进行修改</li>
<li>可以通过原型模式+备忘录模式，来实现保存对象的状态</li>
<li>避免使用工厂模式来创建对象</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/读书笔记/《JavaDesignPatterns》/7.原型模式/" data-id="cjxpj039z00a5rgtwk1nrk8rq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记/《JavaDesignPatterns》/6.单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/读书笔记/《JavaDesignPatterns》/6.单例模式/" class="article-date">
  <time datetime="2019-06-27T09:11:00.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/读书笔记/《JavaDesignPatterns》/6.单例模式/">《Java Design Patterns》第四章 单例模式 - 确保对象的唯一性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四章-单例模式-确保对象的唯一性"><a href="#第四章-单例模式-确保对象的唯一性" class="headerlink" title="第四章 单例模式 - 确保对象的唯一性"></a>第四章 单例模式 - 确保对象的唯一性</h1><p>单例模式用于确保对象的唯一性，为了确保系统中某一个类只有一个唯一实例，当这个唯一实例创建后，无法再创建一个同类型的其他对象。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>单例模式：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。属于对象创建型模式。</p>
<h3 id="1-2-单例模式中的角色"><a href="#1-2-单例模式中的角色" class="headerlink" title="1.2 单例模式中的角色"></a>1.2 单例模式中的角色</h3><ul>
<li>Singleton - 单例角色<ul>
<li>在单例类内容实现只生成一个实例，同时提供一个静态工厂方法用于获取该唯一实例</li>
<li>为了防止外部实例化，将其构造函数设计为私有</li>
<li>单例类内部顶一个Singleton类型的静态对象，作为外部共享的唯一实例</li>
</ul>
</li>
</ul>
<h2 id="二、懒汉模式与饿汉模式"><a href="#二、懒汉模式与饿汉模式" class="headerlink" title="二、懒汉模式与饿汉模式"></a>二、懒汉模式与饿汉模式</h2><h3 id="2-1-饿汉式单例类-线程安全"><a href="#2-1-饿汉式单例类-线程安全" class="headerlink" title="2.1 饿汉式单例类 - 线程安全"></a>2.1 饿汉式单例类 - 线程安全</h3><p><img src="https://i.loli.net/2019/07/04/5d1da0231e7a752730.png" alt="懒汉单例模式"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉模式实现起来最为简单，在类加载时，静态变量 instance 就会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。</p>
<h3 id="2-2-懒汉式单例类（一）-线程安全"><a href="#2-2-懒汉式单例类（一）-线程安全" class="headerlink" title="2.2 懒汉式单例类（一） - 线程安全"></a>2.2 懒汉式单例类（一） - 线程安全</h3><p><img src="https://i.loli.net/2019/07/04/5d1da0b319cb857695.png" alt="懒汉单例模式"></p>
<p>懒汉模式能将类进行 延迟加载，即在需要使用时再加载实例，为了避免多线程调用 getInstance() 时实例化多个 LazySingleton，这里使用 synchronized 关键字进行加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-懒汉式单例类（二）-线程不安全"><a href="#2-3-懒汉式单例类（二）-线程不安全" class="headerlink" title="2.3 懒汉式单例类（二） - 线程不安全"></a>2.3 懒汉式单例类（二） - 线程不安全</h3><p>虽然 synchronized 关键字进行了线程锁定，但是每次调用 getInstance() 方法时都会进行加锁操作，在多线程高并发场景下，会导致系统性能大大降低。</p>
<p>事实上，只需要在 new L:azySingleton() 时进行加锁即可，即第一次实例化实例时加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-懒汉模式单例类（三-DoubleCheck）-线程不安全"><a href="#2-4-懒汉模式单例类（三-DoubleCheck）-线程不安全" class="headerlink" title="2.4 懒汉模式单例类（三 DoubleCheck） - 线程不安全"></a>2.4 懒汉模式单例类（三 DoubleCheck） - 线程不安全</h3><p>如果当两个线程同时进行了 if 条件之中，当线程A完成实例化之后，线程B继续执行，依旧会进行一次实例化。违背了单例模式的设计思想。</p>
<p>双重检测机制：因此我们需要在 synchronized 中在进行一次判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-懒汉模式单例类（四-volatile-DoubleCheck）-线程安全"><a href="#2-5-懒汉模式单例类（四-volatile-DoubleCheck）-线程安全" class="headerlink" title="2.5 懒汉模式单例类（四 volatile+DoubleCheck） - 线程安全"></a>2.5 懒汉模式单例类（四 volatile+DoubleCheck） - 线程安全</h3><p>上述代码看起来可能没什么问题，但是</p>
<p>instance = new LazySingleton() 在内存中的指令顺序应该为：</p>
<ol>
<li>instance 分配内存地址</li>
<li>实例化 LazySingleton</li>
<li>将实例化地址指向instance</li>
</ol>
<p>因为 JVM 的指令重排和优化，可能会导致以上执行顺序与所想像的不一致。最终导致单例出现问题，因此我们在静态实例 instance 前，加上 volatile 关键词，避免 instance 的实例化发生指令重排。</p>
<blockquote>
<p>因此<code>完整的懒汉模式</code>如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用volatile 修改时静态实例，避免指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySignleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 构造方法私有化，防止外部实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 静态工厂类，用于返回唯一实例，且使用延迟加载技术</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一重检查，只有当instance 为空时才进行实例化</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 实例化时对当前类进行加锁，避免多线程同时实例化</span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                <span class="comment">// 第二重检查，避免当前线程通过第一重检查后其他线程已实例化过</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺点也很明显：1. volatile 关键词虽然能保证实例避免重排，但是只在1.5以上的版本才能生效 2. volatile关键词会屏蔽 JVM 的一些代码优化，可能导致系统运行效率降低</p>
</blockquote>
<h2 id="三、一种更好的单例实现方法"><a href="#三、一种更好的单例实现方法" class="headerlink" title="三、一种更好的单例实现方法"></a>三、一种更好的单例实现方法</h2><h2 id="3-1-懒汉模式与饿汉模式的缺点"><a href="#3-1-懒汉模式与饿汉模式的缺点" class="headerlink" title="3.1 懒汉模式与饿汉模式的缺点"></a>3.1 懒汉模式与饿汉模式的缺点</h2><p>饿汉模式：不能实现延迟加载，不管实例是否使用都将占据内存</p>
<p>饿汉模式：繁琐的线程安全控制，且性能会受到一定影响</p>
<h2 id="3-2-静态内部类单例-IoDH-线程安全"><a href="#3-2-静态内部类单例-IoDH-线程安全" class="headerlink" title="3.2 静态内部类单例 - IoDH - 线程安全"></a>3.2 静态内部类单例 - IoDH - 线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 静态内部类只有在第一次调用时才会进行加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因为instance 不是Singleton的成员变量，所以不会在Singleton加载时实例化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过JVM特性来保证线程安全性，确保成员变量只能初始化一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Initialization Demand Holder 技术，在单例类内部增加一个静态内部类，在该内部类中创建单例对象，再将单例对象通过 getInstance() 方法返回给外部使用。</p>
<blockquote>
<p>但是IoDH依赖于JVM的特性，并不适用于所有语言。但是IoDH既可以实现延迟加载，又可以保证线程安全，又不影响性能，不失为一种最好的Java语言单例模式。</p>
</blockquote>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，严格控制客户如何访问</li>
<li>节约系统资源。因为内存中只存在一个对象，无需频繁的创建、销毁对象</li>
<li>允许可变数目的实例。可以通过变种，让getInstance返回至多几个实例</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>由于单例类没有抽象层，很难进行扩展</li>
<li>单例类职责过重，违背了“单一职责原则”。因为单例类即是工厂角色，提供工厂方法，又是产品角色，包含一些业务方法。将产品的创建和产品的功能融合到了一起</li>
<li>许多面向对象语言（如Java、C#）的自动垃圾回收技术，如果实例化的共享变量长时间不被使用。GC 会自动销毁并回收资源，导致单例对象状态的丢失。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li>系统只需要一个实例对象。如资源消耗过大的对象、资源管理器等只能实例一次的对象</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，不能通过其他途径访问该实例。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/读书笔记/《JavaDesignPatterns》/6.单例模式/" data-id="cjxpj039t009yrgtw4adeog4j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/15/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker学习/">Docker学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git命令学习/">Git命令学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-核心知识点整理/">JAVA 核心知识点整理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发编程与高并发解决方案/">Java并发编程与高并发解决方案</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发编程的艺术/">Java并发编程的艺术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/">Java成神之路</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java成神之路/Study社区/">Study社区</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux学习之路/">Linux学习之路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown语法/">MarkDown语法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React学习/">React学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-参考指南/">SpringBoot 参考指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具函数/">工具函数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高性能MySQL/">高性能MySQL</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git-Bash/">Git Bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/POI/">POI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Data/">Spring Data</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poi/">poi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发编程/">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发/">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Git/" style="font-size: 13.75px;">Git</a> <a href="/tags/Git-Bash/" style="font-size: 11.25px;">Git Bash</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/MQ/" style="font-size: 15px;">MQ</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/POI/" style="font-size: 16.25px;">POI</a> <a href="/tags/Spring-Cloud/" style="font-size: 10px;">Spring Cloud</a> <a href="/tags/Spring-Data/" style="font-size: 12.5px;">Spring Data</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/gradle/" style="font-size: 11.25px;">gradle</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/poi/" style="font-size: 10px;">poi</a> <a href="/tags/并发编程/" style="font-size: 12.5px;">并发编程</a> <a href="/tags/数据库/" style="font-size: 17.5px;">数据库</a> <a href="/tags/读书笔记/" style="font-size: 18.75px;">读书笔记</a> <a href="/tags/高并发/" style="font-size: 12.5px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/30/blog/2019/">2019年目标</a>
          </li>
        
          <li>
            <a href="/2019/12/01/读书笔记/《Java并发编程的艺术》/0.0_目录/">《Java并发编程的艺术》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/12/01/读书笔记/《Java核心知识点整理》/0.目录/">《JAVA 核心知识点整理》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/11/30/读书笔记/《高性能MySQL》/0.目录/">《高性能MySQL》读书笔记 - 目录</a>
          </li>
        
          <li>
            <a href="/2019/07/05/读书笔记/《JavaDesignPatterns》/8.建造者模式/">《Java Design Patterns》第六章 建造者模式 - 复杂对象的组装与创建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 koral<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>