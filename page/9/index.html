<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">239</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/15/leetcode/第一章-递归/1-递归原理/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-15</time><div class="content"><h1 id="递归的原理"><a href="#递归的原理" class="headerlink" title="递归的原理"></a>递归的原理</h1><blockquote>
<p>递归，每当递归函数调用自身时，都会将一个问题不断的拆解为子问题，直到子问题无需进一步递归。</p>
</blockquote>
<p>递归应该具有以下两个属性：</p>
<ol>
<li>一个简单的基本案例（basic case）</li>
<li>一组规则，也称作递推关系（recurrence relation）</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/读书笔记/Spring技术内幕/3_IoC容器/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><div class="content"><h2 id="第二章-Spring-Framework-的核心：IoC容器的实现"><a href="#第二章-Spring-Framework-的核心：IoC容器的实现" class="headerlink" title="第二章 Spring Framework 的核心：IoC容器的实现"></a>第二章 Spring Framework 的核心：IoC容器的实现</h2><p>通过 Spring 的核心 IoC 容器和 AOP 的设计和实现可以了解 Spring 所倡导的开发思路，如 <strong>使用 POJO 开发企业应用</strong>、提供<strong>一致的编程模型</strong>、<strong>强调对接口编程</strong>等。</p>
<p>Spring 核心的模式实现，是为应用提供 IoC 容器和 AOP 框架：</p>
<p>IoC 容器很好地降低了框架的侵入性，在简化用户开发的同时，依然能够使用强大的服务；</p>
<p>AOP 技术决定了 Spring 作为一个平台的地位，使 Spring 成为一个兼容并包的开放体系，通过 AOP 技术，使第三方解决方案能够尽可能地结合到 Spring 平台上。</p>
<h2 id="一、Spring-IoC容器概述"><a href="#一、Spring-IoC容器概述" class="headerlink" title="一、Spring IoC容器概述"></a>一、Spring IoC容器概述</h2><h3 id="1-1-什么是依赖反转？"><a href="#1-1-什么是依赖反转？" class="headerlink" title="1.1 什么是依赖反转？"></a>1.1 什么是依赖反转？</h3><p>如果一个对象 与其合作对象的应用 或 依赖关系的管理 由具体对象来完成，那么会导致代码的高度耦合和可测试性的降低。</p>
<p>在面向对象系统中，对象封装了数据和对数据的处理，对象的依赖关系常常体现在对数据和方法的依赖上。</p>
<p>这些依赖关系通过把对象的依赖注入交给IoC容器来完成，则可以很大程度上简化该复杂性。</p>
<blockquote>
<p>控制反转是关于一个对象如何获取它所依赖的对象的应用。在这里，反转指的是责任的反转（将对象的依赖转到 IoC 容器中了）。</p>
</blockquote>
<h3 id="1-2-Ioc-的应用场景"><a href="#1-2-Ioc-的应用场景" class="headerlink" title="1.2 Ioc 的应用场景"></a>1.2 Ioc 的应用场景</h3><p>上面介绍的 IoC 设计模式，是解耦组件之间复杂关系的利器，Spring IoC 模块就是这一模式的实现。</p>
<p>在原有的 EJB 模式中，开发者需要编写满足 EJB 规范的组件，才能运行在 EJB 容器中，从而获取事务管理、生命周期管理等组件开发的基本服务。</p>
<p>Spring 提供的服务与 EJB 并无太大区别，但两者在设计模式上有很大不同。</p>
<p>Spring 通过 IoC 模式管理依赖关系，并通过依赖注入和 AOP 切面增强了为 JavaBean 这样的  POJO 对象赋予事务管理、生命周期管理等基本功能。</p>
<p>也就是说 Spring 把 EJB 组件还原成了 POJO 对象或 JavaBean 对象，降低了应用开发对传统 J2EE 技术规范的依赖。</p>
<p>一方面，通过 IoC 容器的资源控制反转，使依赖关系的适配和管理更加灵活；另一方面，如果在反转的实现中，通过可读文本来完成配置，则在变动时无需修改和重新编译源代码，符合设计模式中的开闭原则，能够提高组件系统设计的灵活性。</p>
<h2 id="二、IoC-容器系列的设计与实现：BeanFactory-和-ApplicationContext"><a href="#二、IoC-容器系列的设计与实现：BeanFactory-和-ApplicationContext" class="headerlink" title="二、IoC 容器系列的设计与实现：BeanFactory 和 ApplicationContext"></a>二、IoC 容器系列的设计与实现：BeanFactory 和 ApplicationContext</h2><p>在 Spring IoC 容器的设计中，包含两个主要的容器：BeanFactory 接口的简单容器系列，只实现了容器的最基本功能；ApplicationContext 应用上下文，作为容器的高级形态而存在，在简单容器的基础上增加了许多面向框架的特性。</p>
<h2 id="2-1-Spring-的-IoC-容器"><a href="#2-1-Spring-的-IoC-容器" class="headerlink" title="2.1 Spring 的 IoC 容器"></a>2.1 Spring 的 IoC 容器</h2><p>BeanFactory 定义了作为 IoC 容器所需要的最基本的功能规范。且 Spring 通过定义 BeanDefinition 来管理基于 Spring 应用中的各种对象以及它们之间的相互依赖关系。</p>
<p>BeanDefinition 抽象了对 Bean 的定义，即依赖反转模式中管理的对象依赖关系的数据抽象，也是容器实现依赖反转功能的核心数据结构。</p>
<p><img src="https://i.loli.net/2019/10/28/GBZJu6QvjUnb1x5.png" alt="IoC容器的接口设计图"></p>
<h4 id="1-BeanFactory-的应用场景"><a href="#1-BeanFactory-的应用场景" class="headerlink" title="1. BeanFactory 的应用场景"></a>1. BeanFactory 的应用场景</h4><p>BeanFactory 接口定义了 IoC 容器最基本的形式，也是最基本的规范，勾画了 IoC 的基本轮廓。</p>
<blockquote>
<p>FactoryBean 和 BeanFactory 的区别：</p>
<p>虽然看起来挺像，但是本质是不同的。BeanFactory 是 管理所有 Bean 的工厂，而 FactoryBean 是一个工厂类型的 Bean。</p>
</blockquote>
<p>BeanFactory 设计了 getBean 方法，用来通过名称获取 IoC 容器中管理的 Bean。</p>
<p>有了BeanFactory 的定义，用户可以执行以下操作：</p>
<ul>
<li>containsBean，判断容器是否含有指定名称的Bean</li>
<li>isSingleton，查询指定名称的 Bean 是否是 Singleton 类型</li>
<li>isPrototype，查询指定名称的 Bean 是否是 prototype 类型的</li>
<li>isTypeMatch，查询指定名称的 Bean 是否是特定的 Class 类型</li>
<li>getType，查询Bean 的 Class 类型</li>
<li>getAliases，查询 Bean 的所有别名</li>
</ul>
<p>通过以上的一系列接口，可以使用不同的 Bean 的检索方法，很方便地从 IoC 容器中得到需要的 Bean，从而忽略具体的 IoC 容器的实现。</p>
<h4 id="2-BeanFactory-容器的设计原理"><a href="#2-BeanFactory-容器的设计原理" class="headerlink" title="2. BeanFactory 容器的设计原理"></a>2. BeanFactory 容器的设计原理</h4><p><code>BeanFactory</code> 接口提供了使用 IoC 容器的规范。我们以 <code>XmlBeanFactory</code> 为例，从其源码来看看 <code>BeanFactory</code> 的设计思路。</p>
<pre><code class="java">public class XmlBeanFactory extends DefaultListableBeanFactory {
    /**
     * 初始化一个 XmlBeanDefinitionReader，用来处理 BeanDefinition
     */
    private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);

    /**
     * 通过 Resource 获取存储 BeanDefinition 的 .xml 文件
     * 用来定位需要的 BeanDefinition 信息来对 Bean 完成容器的初始化和依赖注入过程
     */
    public XmlBeanFactory(Resource resource) throws BeansException {
        this(resource, null);
    }

    /**
     * 通过指定的 xml 文件加载 BeanDefinition
     */
    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
        super(parentBeanFactory);
        this.reader.loadBeanDefinitions(resource);
    }
}</code></pre>
<p>参考 XMLBeanFactory 的实现，大致可以将 IoC 容器的创建分为如下几个步骤：</p>
<ol>
<li>创建 IoC 配置文件的抽象资源</li>
<li>创建一个 BeanFactory </li>
<li>创建一个载入 BeanDefinition 的读取器</li>
<li>从定义好的资源读入配置信息</li>
<li>完成 IoC 容器中 Bean 的初始化</li>
</ol>
<pre><code class="java">ClassPathResource res = new ClassPathResource(&quot;beans.xml&quot;);
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(res);</code></pre>
<h4 id="3-ApplicationContext-的应用场景"><a href="#3-ApplicationContext-的应用场景" class="headerlink" title="3. ApplicationContext 的应用场景"></a>3. ApplicationContext 的应用场景</h4><p>ApplicationContext 除了能够使用 IoC 容器的基本功能之外，还为用户提供了以下附加服务：</p>
<pre><code class="java">/**
 * 在 ApplicationContext 中提供的附加服务，使基本 IoC 容器的功能更加丰富。与简单的 BeanFactory 相比，它的使用是一种面向框架的使用风格
 * ListableBeanFactory：访问应用中 Bean 工厂的方法
 * MessageSource：解析消息的能力，支持国际化
 * ResourceLoader：加载文件资源的能力
 * ApplicationEventPublisher：发布应用事件的能力，这些事件和 Bean 的生命周期结合，为管理 Bean 提供了便利
 */
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver {   
    @Nullable   
    String getId();  
    String getApplicationName();  
    String getDisplayName();  
    long getStartupDate();  
    @Nullable   
    ApplicationContext getParent();   
    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;
}</code></pre>
<h4 id="4-ApplicationContext-的设计原理"><a href="#4-ApplicationContext-的设计原理" class="headerlink" title="4. ApplicationContext 的设计原理"></a>4. ApplicationContext 的设计原理</h4><p>在 ApplicationContext 容器的实现中，以 FileSystemXmlApplicationContext 的实现为例：</p>
<pre><code class="java">public class FileSystemXmlApplicationContext extends AbstractXmlApplicationContext {
    /**
     * 除了实例化应用上下文的支持，还支持启动 IoC 容器的 refresh() 
     * 在这个过程中，还通过下面的方法读取 文件系统中XML形式的 BeanDefinition 资源
     */
    public FileSystemXmlApplicationContext(
            String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
            throws BeansException {

        super(parent);
        setConfigLocations(configLocations);
        if (refresh) {
            refresh();
        }
    }

    /**
     * 获得 FileSystemResource 的资源定位
     */
    @Override
    protected Resource getResourceByPath(String path) {
        if (path.startsWith(&quot;/&quot;)) {
            path = path.substring(1);
        }
        return new FileSystemResource(path);
    }

}</code></pre>
<h2 id="三、IoC-容器的初始化过程"><a href="#三、IoC-容器的初始化过程" class="headerlink" title="三、IoC 容器的初始化过程"></a>三、IoC 容器的初始化过程</h2><p>IoC 容器的初始化是由前面介绍的 refresh() 方法来启动的。该启动包括 BeanDefinition 的 Resource 定位、载入和注册三个过程。</p>
<h3 id="3-1-BeanDefinition-的-Resource-定位"><a href="#3-1-BeanDefinition-的-Resource-定位" class="headerlink" title="3.1 BeanDefinition 的 Resource 定位"></a>3.1 BeanDefinition 的 Resource 定位</h3><p>当我们手动使用 IoC 容器的时候，是通过 <code>new Resource(&quot;beans.xml&quot;)</code> 的方式获取 xml 中的信息。</p>
<p>以 FileSystemXmlApplicationContext 为例，getResourceByPath 返回的是一个 FileSystemResource 对象，作为 Resource 的实现类。</p>
<p>其他 ApplicationContext 的子实现类也会生成对应的 Resource 实现类。</p>
<h3 id="3-2-BeanDefinition-的载入和解析"><a href="#3-2-BeanDefinition-的载入和解析" class="headerlink" title="3.2 BeanDefinition 的载入和解析"></a>3.2 BeanDefinition 的载入和解析</h3><p>对于 IoC 容器而言，BeanDefinition 信息的载入，相当于把定义的 BeanDefinition 转换为 Spring 内部表示的数据结构的过程。<strong>在 IoC 容器中是通过 HashMap 来保持和维护 BeanDefinition 数据的</strong>。</p>
<p>以 <code>AbstractApplicationContext</code> 的 refresh() 方法为例：</p>
<pre><code class="java">    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.
            prepareRefresh();

            // 创建或刷新 BeanFactory
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // 准备 BeanFactory 的一些初始化操作
            prepareBeanFactory(beanFactory);

            try {
                // 允许子类对 BeanFactory 进行一些后置操作
                postProcessBeanFactory(beanFactory);

                // 注册 BeanFactory 到 context 中
                invokeBeanFactoryPostProcessors(beanFactory);

                registerBeanPostProcessors(beanFactory);

                initMessageSource();

                initApplicationEventMulticaster();

                // 由子类实现该刷新方法
                onRefresh();

                // 检查并注册监听器
                registerListeners();

                // 实例化所有剩余单例
                finishBeanFactoryInitialization(beanFactory);

                // 完成刷新，并发布事件
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }</code></pre>
<p>具体刷新方法，可以参考 <code>AbstractApplicationContext</code> 的实现子类 <code>AbstractRefreshableApplicationContext</code>：</p>
<pre><code class="java">@Override
protected final void refreshBeanFactory() throws BeansException {
    // 如果存在 BeanFactory 则先关闭销毁
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
    }
}</code></pre>
<h3 id="3-3-BeanDefinition-在-IoC-容器中的注册"><a href="#3-3-BeanDefinition-在-IoC-容器中的注册" class="headerlink" title="3.3 BeanDefinition 在 IoC 容器中的注册"></a>3.3 BeanDefinition 在 IoC 容器中的注册</h3><p>在 DefaultListableBeanFactory 中，通过一个 HashMap 来持有载入的 BeanDefinition 的。</p>
<p>DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 的接口，用来完成 BeanDefinition 向容器的注册。注册的过程就是把解析得到的 BeanDefinition 设置到 HashMap 中去，如果遇到同名的 BeanDefinition，在处理时就需要依据 allowBeanDefinitionOverriding 的配置来完成。</p>
<h2 id="四、IoC-容器的依赖注入"><a href="#四、IoC-容器的依赖注入" class="headerlink" title="四、IoC 容器的依赖注入"></a>四、IoC 容器的依赖注入</h2><p><img src="https://i.loli.net/2019/10/29/L6lwDNeXrCmu97U.png" alt="依赖注入的过程"></p>
<p><code>createBeanInstance()</code> 生成了 Bean 所包含的 Java 对象，生成方式由相关的 BeanDefinition 指定(如工厂方法生成、容器autowire特性生成等)</p>
<p>在 Bean 的创建和对象依赖注入的过程中，需要依据 BeanDefinition 中的信息来递归地完成依赖注入。</p>
<p>这些递归都是以 getBean 为入口的。一个递归是在上下文体系中查找需要的 Bean 和创建 Bean 的递归调用；另一个递归是在依赖注入时，通过递归调用容器的 getBean 方法，得到当前 Bean 的依赖 Bean，同时也触发对依赖 Bean 的创建和注入。</p>
<p>在对 Bean 的属性进行依赖注入时，解析的过程也是一个递归的过程。根据依赖关系，一层一层地完成 Bean 的创建和注入，知道完成当前 Bean  的创建。</p>
<h2 id="五、容器其他相关特性的设计与实现"><a href="#五、容器其他相关特性的设计与实现" class="headerlink" title="五、容器其他相关特性的设计与实现"></a>五、容器其他相关特性的设计与实现</h2><p><img src="https://i.loli.net/2019/10/29/HSazslc1QID87iW.png" alt="容器初始化和关闭过程"></p>
<p><code>prepareBeanFactory(beanFactory)</code> 在初始化 IoC 容器时配置 ClassLoader、PropertyEditor 和 BeanPostProcessor 等，为容器的启动做必要的准备工作</p>
<p><img src="https://i.loli.net/2019/10/29/tu5IzsErGjPkYom.png" alt="prepareBeanFactory"></p>
<p>同样，关闭容器时，也会先发出关闭容器的信号，然后将 Bean 逐个关闭，最后关闭容器自身。</p>
<p><img src="https://i.loli.net/2019/10/29/cbATGnhrwI2DvH6.png" alt="容器关闭"></p>
<h3 id="5-1-IoC-容器中的-Bean-生命周期"><a href="#5-1-IoC-容器中的-Bean-生命周期" class="headerlink" title="5.1 IoC 容器中的 Bean 生命周期"></a>5.1 IoC 容器中的 Bean 生命周期</h3><ul>
<li>Bean 实例的创建</li>
<li>为 Bean 实例设置属性</li>
<li>调用 Bean 的初始化方法</li>
<li>应用可以通过 IoC 容器使用 Bean</li>
<li>当容器关闭时，调用 Bean 的销毁方法<ul>
<li>在 DisposableBeanAdapter 中可以看到 destory 方法的实现</li>
<li>首先对 postProcessBeforeDestruction 进行调用，然后调用 Bean 的 destory 方法，最后是对 Bean 的自定义销毁方法的调用</li>
</ul>
</li>
</ul>
<blockquote>
<p>在初始化 Bean 之前，会把相关的 BeanName、BeanClassLoader、BeanFactory 注入到 Bean 中去。</p>
<p>接着会调用 invokeInitMethods 和 afterPropertiesSet</p>
<p>最后还会判断 Bean 是否配置有 initMethod，如果有，则直接通过 invokeCustomInitMethod 调用，最终完成 Bean 的初始化</p>
</blockquote>
<h3 id="5-2-lazy-init-属性和预实例化"><a href="#5-2-lazy-init-属性和预实例化" class="headerlink" title="5.2 lazy-init 属性和预实例化"></a>5.2 lazy-init 属性和预实例化</h3><p>在 IoC 容器的初始化过程中，主要是对 BeanDefinition 的定位、载入、解析和注册。当应用第一次向容器索要 Bean 时，依赖注入才会发生。</p>
<p>通过设置 lazy-init 属性，可以使容器初始化时就完成对 Bean 的依赖注入。虽然这种方式会对容器初始化的性能有一些影响，但是会提高应用第一次获取 Bean 的性能。</p>
<p>在 <code>finishBeanFactoryInitialization</code> 中封装了对 lazy-init 属性的处理，实际的处理是在 <code>DefaultListableBeanFactory</code> 这个基本容器的 <code>preInstantiateSingletons</code> 方法中完成的。</p>
<h3 id="5-3-Bean-对-IoC-容器的感知"><a href="#5-3-Bean-对-IoC-容器的感知" class="headerlink" title="5.3 Bean 对 IoC 容器的感知"></a>5.3 Bean 对 IoC 容器的感知</h3><p>一般情况下，Bean 并不需要了解容器的状态和直接使用容器，但是 Spring IoC 容器也提供了该功能，它是通过特定的 aware 接口实现的：</p>
<ul>
<li>BeanNameAware - 获取实例名称</li>
<li>BeanFactoryAware - 直接得到 Bean 所在的 IoC 容器</li>
<li>ApplicationContextAware - 获得 Bean 所在的应用上下文 ApplicationContext</li>
<li>MessageSourceAware - 获得消息源</li>
<li>ApplicationEventPublisherAware - 获得应用上下文的事件发布器</li>
<li>ResourceLoaderAware - 得到 ResourceLoader，可以在 Bean中加载外部对应的 Resource 资源</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本章说明了 IoC 容器和上下文的基本工作原理、容器的初始化过程、依赖注入的实现，等等。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/读书笔记/Spring技术内幕/2_Spring架构/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><div class="content"><h1 id="第一章-Spring-的设计理念和整体架构"><a href="#第一章-Spring-的设计理念和整体架构" class="headerlink" title="第一章 Spring 的设计理念和整体架构"></a>第一章 Spring 的设计理念和整体架构</h1><h2 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h2><p>Spring 为开发者提供一个一站式的轻量级应用开发框架(平台)。</p>
<p>在 Java EE 的应用开发中，支持 POJO 和使用 JavaBean 的开发方式，使应用面向接口开发，充分支持 OO(面向对象) 的设计方法。</p>
<h2 id="一、Spring中的各个子项目"><a href="#一、Spring中的各个子项目" class="headerlink" title="一、Spring中的各个子项目"></a>一、Spring中的各个子项目</h2><p>打开 <a href="https://spring.io/projects" target="_blank" rel="noopener">Spring.io</a> 能看到 Spring 支持的所有模块：</p>
<ol>
<li>Spring Boot：更快地配置、启动和运行 Spring 应用程序</li>
<li>Spring Framework(Core)：提供依赖注入、事务管理、web支持、DB访问、消息传递等核心支持</li>
<li>Spring Cloud Data Flow：</li>
<li>Spring Cloud：为常见的分布式系统提供用于建立和部署微型服务的工具</li>
<li>Spring Data：为数据访问提供一致的方法，包含关系型、非关系型、map-reduce等</li>
<li>Spring Integration：企业集成模块</li>
<li>Spring Batch：简化大批量处理操作</li>
<li>Spring Security：全面可扩展的身份验证和授权支持</li>
<li>Spring Rest Docs：对 RESTful服务进行文档化</li>
<li>Spring AMQP：AMQP 消息传递的解决方案</li>
<li>Spring Web Flow</li>
<li>Spring Web Services：SOAP web 服务的开发</li>
<li>Spring LDAP：轻量级目录访问协议的开发</li>
<li>Spring Session：管理用户会话信息的API 和实现</li>
<li>Spring Shell：为使用基于 spring 的编程模型构建命令行应用程序提供了基础</li>
<li>Spring Kafka：Kafka 的抽象</li>
<li>Spring Scala：Spring 与 Scala 的结合</li>
</ol>
<p>其中有几个没用过的就没加上</p>
<h2 id="二、Spring-的整体架构"><a href="#二、Spring-的整体架构" class="headerlink" title="二、Spring 的整体架构"></a>二、Spring 的整体架构</h2><p><img src="https://i.loli.net/2019/10/28/Pjx6kau89h4GeyV.png" alt="UTOOLS1572233510528.png"></p>
<p>Spring架构分为以下七个模块：</p>
<ol>
<li>Spring IOC：包含了基本的IOC容器 BeanFactory 的接口与实现</li>
<li>Spring AOP：集成了 AspectJ 作为 AOP 的特定时限，围绕着 AOP 的增强功能，作为 Spring 集成其他模块的工具，如 TransactionProxyFactoryBean 声明式事务处理便是通过 AOP 集成到 Spring中的。Spring AOP 实现了一个完整的 AOP 代理对象，实现 AOP 拦截器、直至实现各种 Advice 通知的过程</li>
<li>Spring MVC：包含对 Web 应用的支持。该模块以 DispatcherServlet 为核心，实现了 MVC 模式，包含与 Web 容器环境的集成，web 请求的拦截、分发、处理和 ModelAndView 数据的返回，以及如何继承各种 UI 视图的展现，如 PDF、Excel 等</li>
<li>Spring JDBC/ORM：对于关系型数据库的数据处理的支持。除了 JdbcTemplate 外，还提供了对其他 ORM 工具的封装，如 Hibernate、iBatis等</li>
<li>Spring 事务：是一个通过 Spring AOP 实现自身功能增强的典型模块。通过 AOP 的切面增强实现了声明式事务处理的功能，包含怎样配置事务处理的拦截器，怎样读入事务配置属性，并结合事务配置属性对事务对象进行处理（如事务的创建、挂起、提交、回滚等基本过程），还可以看到具体的事务处理器（DataSourceTransactionManager、HibernateTransactionManager、JtaTransactionManager等）是怎样封装不同的事务处理机制的。</li>
<li>Spring 远程调用：远端调用为应用提供解耦，解耦后将应用模块分布式地部署，从而提高系统整体的性能</li>
<li>Spring 应用：对于 Spring 子项目的应用支持。如Spring 处理安全问题的 Spring Security、J2EE 实现规范的接口、对 JMS、JNID、JMX等的支持等等</li>
</ol>
<h2 id="三、Spring-的应用场景"><a href="#三、Spring-的应用场景" class="headerlink" title="三、Spring 的应用场景"></a>三、Spring 的应用场景</h2><p>在 Spring 这个一站式的应用平台或框架中，各个模块除了依赖 IoC 容器和 AOP 之外，相互之间并没有很强的耦合性。</p>
<p>Spring 设计时的轻量级特性，以及推崇 POJO 开发，所以使用起来非常灵活。</p>
<p>Spring 的特点：</p>
<ul>
<li>Spring 是一个非侵入性框架，其目标是使应用程序代码对框架的依赖最小化，应用代码可以在没有 Spring 或其他容器的情况下运行</li>
<li>Spring 提供了一个一致的编程模型，使应用直接使用 POJO 开发，从而可以与运行环境隔离开</li>
<li>Spring 改进了体系结构的选择，Spring 可以帮助我们选择不同的技术实现，如 Hibernate 到 Mybatis、Struts 到 SpringMVC 等，降低了平台锁定的风险(虽然一般不会这样做)</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>简要回顾了 Spring 的设计理念、架构设计和应用场景，对各个模块进行了简要的介绍。</p>
<p>后面会详细针对 <strong>Spring 的核心实现(IoC、AOP)</strong>、<strong>Spring 的常用组件(Web、数据库、事务、远端调用)</strong> 等几个模块进行深入阐述。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/28/读书笔记/Spring技术内幕/1_简介/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-28</time><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着 Spring 的不断成熟和完善，Spring 现已发展成为一个包含软件构建、开发、运行、部署整个软件生命周期的产品族群。</p>
<p>本书主要内容分为三个部分，分别阐述了 Spring 的核心、组件和应用三个方面：</p>
<p>第一部分详细分析了 IOC 容器和 AOP 的实现，这些是理解 Spring 平台的基础。</p>
<p>第二部分深入阐述了 Spring IOC 容器和 AOP 的 Java EE 组件在 Spring 中的实现。如事务处理、Web MVC、JDBC、O/R映射、远端调用等；</p>
<p>第三部分讲述了一些基于 Spring 的典型应用的实现(第八~十章)。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>第一章 Spring的设计理念和整体架构</li>
<li>第二章 Spring Framework 的核心：IoC容器的实现</li>
<li>第三章 Spring AOP 的实现</li>
<li>第四章 SpringMVC与 Web 环境</li>
<li>第五章 数据库操作组件的实现</li>
<li>第六章 Spring 事务处理的实现</li>
<li>第七章 Spring 远端调用的实现</li>
<li>第八章 安全框架 ACEGI 的设计与实现</li>
<li>第九章 SpringDM 模块的设计与实现</li>
<li>第十章 SpringFlex 的设计与实现</li>
</ul>
<blockquote>
<p>文章来自：《Spring技术内幕：深入解析Spring架构及设计原理》</p>
<p>以上版本均为 Spring-Core:5.0.9.RELEASE，部分代码与书中有出入，以各自的版本为主吧</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/10/14/读书笔记/《EffectiveJava》/2_Builder模式解决构造参数过多/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-14</time><div class="content"><h1 id="二、当构造方法参数过多时使用-Builder-模式"><a href="#二、当构造方法参数过多时使用-Builder-模式" class="headerlink" title="二、当构造方法参数过多时使用 Builder 模式"></a>二、当构造方法参数过多时使用 Builder 模式</h1></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>