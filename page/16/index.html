<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="罗凯的博客主页"><meta name="keywords" content="博客,全栈工程师,前端工程师,后端工程师,运维工程师,罗凯的博客,罗凯,DevOps,技术博客"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>现在的我可以做点什么，让未来的我可以受益匪浅？ | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">罗凯的博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">291</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">48</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">现在的我可以做点什么，让未来的我可以受益匪浅？</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/3_XML映射文件/">《MyBatis》读书笔记 - MyBatis XML 映射文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/MyBatis/">MyBatis</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="三、MyBatis-XML-映射文件"><a href="#三、MyBatis-XML-映射文件" class="headerlink" title="三、MyBatis XML 映射文件"></a>三、MyBatis XML 映射文件</h1><p>MyBatis 通过映射 XML 文件的方式，减少了 JDBC 的样板代码，十分的简单。</p>
<p>SQL 映射文件只有少数几个顶级约束：</p>
<ul>
<li>cache - 对给定命名空间的缓存配置</li>
<li>cache-ref - 对其他命名空间缓存配置的引用</li>
<li>resultMap - 描述如何从数据库结果集中加载对象</li>
<li><del>parameterMap - 废弃，参数映射</del></li>
<li>sql - 可重用语句块</li>
<li>insert - 插入语句</li>
<li>update - 更新语句</li>
<li>delete - 删除语句</li>
<li>select - 查询语句</li>
</ul>
<h2 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h2><p>查询语句，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
    SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</code></pre>
<p>select 元素允许你配置很多属性来配置每条语句的作用细节</p>
<pre><code class="xml">&lt;select
          id=&quot;selectPerson&quot;
        parameterType=&quot;int&quot;
        parameterMap=&quot;deprecated&quot;
        result=&quot;hashMap&quot;
        resultMap=&quot;personResultMap&quot;
        flushCache=&quot;false&quot;
        useCache=&quot;true&quot;
        timeout=&quot;10&quot;
        fetchSize=&quot;256&quot;
        statementType=&quot;PREPARED&quot;
        resultSetType=&quot;FORWARD_ONLY&quot;
        &gt;

&lt;/select&gt;</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>命名空间中的唯一标识符，用来引用该语句</td>
</tr>
<tr>
<td>parameterType</td>
<td>传入的参数的完全限定名，可选。MyBatis会通过类型处理器推断具体传入的参数类型</td>
</tr>
<tr>
<td><del>parameterMap</del></td>
<td><del>引用外部 parametermap 的方法</del></td>
</tr>
<tr>
<td>resultType</td>
<td>返回的期望乐行的类的完全限定名或别名。如果结果为集合，则应该设置为集合包含的类型，而不是集合本身。</td>
</tr>
<tr>
<td>resultMap</td>
<td>外部 resultMap 的命名引用。与resultType不能同时使用</td>
</tr>
<tr>
<td>flushCache</td>
<td>默认为false。为true时，只要语句被调用，都会导致本地缓存和二级缓存被清空</td>
</tr>
<tr>
<td>useCache</td>
<td>默认对select元素为true。将本条语句的结果使用二级缓存缓存起来</td>
</tr>
<tr>
<td>timeout</td>
<td>驱动程序等待数据库返回请求结果的秒数，而后抛出异常</td>
</tr>
<tr>
<td>fetchSize</td>
<td>尝试让驱动程序每次批量返回的结果行数和设置的值相等</td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PREPARED(默认)、CALLABLE中的一个</td>
</tr>
<tr>
<td>resultSetType</td>
<td>FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE、DEFAULT中的一个</td>
</tr>
<tr>
<td>databaseId</td>
<td>数据库厂商标识</td>
</tr>
<tr>
<td>resultOrdered</td>
<td>仅针对嵌套select，如果为true，则假设包含了嵌套结果集或是分组，这样返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。使得在获取嵌套结果集时不至于导致内存不够用</td>
</tr>
<tr>
<td>resultSets</td>
<td>针对多结果集情况。将列出语句执行后返回的结果集并给每个结果集一个名称</td>
</tr>
</tbody></table>
<h2 id="二、insert、update、delete"><a href="#二、insert、update、delete" class="headerlink" title="二、insert、update、delete"></a>二、insert、update、delete</h2><p>与 select 参数相似，以一个示例来说明：</p>
<pre><code class="xml">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into  Author(username,password,email) values 
   &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
       (#{item.username},#{item.password},#{item.email})
   &lt;/foreach&gt;
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
    update Author set
     username=#{username},
     password=#{password},
     email=#{email}
    where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
    delete from Author where id=#{id}
&lt;/delete&gt;</code></pre>
<h2 id="三、sql"><a href="#三、sql" class="headerlink" title="三、sql"></a>三、sql</h2><p>该元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以在加载的时候被静态地设置参数。在不同的包含语句中可以设置不同的值到参数占位符上，如：</p>
<pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password&lt;/sql&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
    select
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
    from some_table t1
    cross join some_table t2
&lt;/select&gt;</code></pre>
<blockquote>
<p>cross join 表示笛卡尔积，t1+t2的所有情况</p>
</blockquote>
<p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，如：</p>
<pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;
    ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclud&quot;&gt;
      from
     &lt;includ refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
    select
     field1,field2,field3
    &lt;includ refid=&quot;someinclud&quot;&gt;
     &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
     &lt;property name=&quot;includ_target&quot; value=&quot;sometable&quot;/&gt;
    &lt;/includ&gt;
&lt;/select&gt;</code></pre>
<h2 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h2><pre><code class="xml">&lt;insert id=&quot;selectUser&quot; parameterType=&quot;User&quot;&gt;
    insert into users (id,username,password)
    values (#{id},#{username},#{password})
&lt;/insert&gt;</code></pre>
<p>上面的语句中，User 类型的参数对象传递到了语句中，id、username、password 属性会被查找，然后将它们的值传入预处理语句的参数中。</p>
<p>参数也可以指定一个特殊的数据类型：</p>
<blockquote>
<p>#{property,javaType=int,jdbcType=NUMERIC}</p>
</blockquote>
<p>也可以指定一个特殊的类型处理器类：</p>
<blockquote>
<p>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</p>
</blockquote>
<p>需要保留小数点的数值类型：</p>
<blockquote>
<p>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</p>
</blockquote>
<p>尽管该选项功能强大，但大多数情况下只需要简单地指定属性名，MyBatis 会自己推断类型，顶多<code>需要为可能为空的列指定 jdbcType</code>。</p>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>默认情况下，使用 <code>#{}</code> 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数(就像？一样)。不过有时想直接在 SQL 中插入一个不转义的字符串，如：</p>
<blockquote>
<p>order by ${columnName}</p>
</blockquote>
<p>这样，MyBatis 不会修改或转义字符串。</p>
<p>有时，替换字符串会非常有用，如：</p>
<pre><code class="java">@Select(&quot;select * from user where id=#{id}&quot;)
User findById(@Param(&quot;id&quot;) long id);

@Select(&quot;select * from user where name=#{name}&quot;)
User findByName(@Param(&quot;name&quot;) String name);

@Select(&quot;select * from user where email=#{email}&quot;)
User findByEmail(@Param(&quot;email&quot;) long email);</code></pre>
<p>可以只写一个方法：</p>
<pre><code class="java">@Select(&quot;select * from user where ${column}=#{email}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;email&quot;) long email);</code></pre>
<p>使用的时候，可以如下调用：</p>
<pre><code class="java">User u1 = userMapper.findByColumn(&quot;id&quot;,1L);
User u2 = userMapper.findByColumn(&quot;name&quot;,&quot;zhangsan&quot;);
User u3 = userMapper.findByColumn(&quot;email&quot;,&quot;xx@qq.com&quot;);</code></pre>
<h2 id="五、结果映射"><a href="#五、结果映射" class="headerlink" title="五、结果映射"></a>五、结果映射</h2><p>resultMap 可以将返回结果映射到JavaBean或POJO上。如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>也可以使用类型别名，来代替完全限定名：</p>
<pre><code class="xml">&lt;typeAlias type=&quot;cn.luokaiii.model.User&quot; alias=&quot;User&quot;/&gt;

&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>如果列名与属性名没有精确匹配，可以在 SELECT 语句中对列使用别名来匹配标签，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select 
     id        as &quot;id&quot;,
     username  as &quot;userName&quot;
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>或者使用外部的 <code>resultMap</code> 来映射：</p>
<pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<h3 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h3><pre><code class="xml">&lt;!-- 非常复杂的语句 --&gt;
&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt;
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;!-- 非常复杂的结果映射 --&gt;
&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt;
  &lt;constructor&gt;
    &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;
  &lt;/constructor&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
    &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt;
  &lt;/association&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt;
    &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt;
      &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
    &lt;/discriminator&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="结果映射（resultMap）"><a href="#结果映射（resultMap）" class="headerlink" title="结果映射（resultMap）"></a>结果映射（resultMap）</h3><ul>
<li>constructor - 用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg - ID参数，标记出ID，可以帮助提高整体性能</li>
<li>arg - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id - 一个ID结果</li>
<li>result - 注入到字段或 JavaBean 属性的普通结果</li>
<li>association - 一个复杂类型的关联；许多结果将包装成这种类型<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>collection - 一个复杂类型的集合<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>discriminator - 使用结果值来决定使用哪个 resultMap<ul>
<li>case - 基于某些值的结果映射<ul>
<li>嵌套结果映射 - case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h3><p>id 和 result 元素都将一个列的值映射到一个简单数据类型的属性或字段。</p>
<pre><code class="xml">&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;</code></pre>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>有时，需要使用不可变类来接收，即在构造方法中注入允许在初始化时设置的值，而不暴露出公有方法。</p>
<pre><code class="java">public class User {
    // ...property
    public User(Integer id, String userName, int age){
        // ...set
    }

    // private setter and getter
}</code></pre>
<pre><code class="xml">&lt;constructor&gt;
    &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot;/&gt;
    &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;userName&quot;/&gt;
    &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot;/&gt;
&lt;/constructor&gt;</code></pre>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联（association）元素处理“有一个”类型的关系。</p>
<pre><code class="xml">&lt;association property=&quot;author&quot; cloumn=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/association&gt;</code></pre>
<p>MyBatis 有两种方式加载关联：</p>
<ul>
<li>嵌套 Select 查询：通过执行另一个 SQL 映射语句来加载期望的复杂类型</li>
<li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集</li>
</ul>
<h3 id="关联的嵌套Select查询"><a href="#关联的嵌套Select查询" class="headerlink" title="关联的嵌套Select查询"></a>关联的嵌套Select查询</h3><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
    select * from Author where id=#{id}
&lt;/select&gt;</code></pre>
<p>selectBlog 用来加载博客，selectAuthor 用来加载作者，而 blogResult 结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。</p>
<p>这种方式虽然简单，但是<code>在大型数据集或大型数据表上表现不佳</code>。这个问题被称为“N+1查询问题”：</p>
<ul>
<li>执行了一个单独的 SQL 语句来获取结果的一个列表（就是+1）</li>
<li>对列表返回的每条记录，执行一个 select 查询语句来加载详细信息（就是N）</li>
</ul>
<p>虽然 MyBatis 能够对这样的查询进行延迟加载，但是如果你在加载完记录表后，立即进行了遍历。此时就会触发所有的延迟加载查询，性能会变得很糟糕。</p>
<blockquote>
<p>解决方法：使用联合查询来避免N+1问题</p>
</blockquote>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合元素和关联元素几乎是一样的</p>
<pre><code class="xml">&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;</code></pre>
<h4 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h4><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
    select * from post where blog_id=#{id}
&lt;/select&gt;</code></pre>
<blockquote>
<p><code>javaType=&quot;ArrayList&quot; ofType=&quot;Post&quot;</code> 等同于结果为：ArrayList<post></post></p>
</blockquote>
<h4 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h4><pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h4 id="集合的多结果集（ResultSet）"><a href="#集合的多结果集（ResultSet）" class="headerlink" title="集合的多结果集（ResultSet）"></a>集合的多结果集（ResultSet）</h4><p>可以通过执行存储过程来实现，存储过程会执行两个查询并返回两个结果集。</p>
<pre><code class="sql">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}</code></pre>
<p>在映射时，必须通过 resultSets 属性为每个结果集指定一个名字，使用逗号隔开。</p>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt;
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;</code></pre>
<p>指定结果集的数据进行填充</p>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="鉴别器（discriminator）"><a href="#鉴别器（discriminator）" class="headerlink" title="鉴别器（discriminator）"></a>鉴别器（discriminator）</h3><p>有时，一个数据库查询可能会返回多个不同的结果集。鉴别器元素就是被设计出来应对这种情况的，也能处理如类的继承层次结构的问题。类似于 java 语言中的 switch 语句。</p>
<pre><code class="xml">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><p>在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，则需要自行构建一个结果映射。</p>
<h2 id="六、缓存"><a href="#六、缓存" class="headerlink" title="六、缓存"></a>六、缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，可以非常方便地配置和定制。</p>
<p>默认情况下，只启用了本地的会话缓存，仅对一个会话中的数据进行缓存。要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<blockquote>
<cache>
</cache></blockquote>
<p>其效果如下：</p>
<ul>
<li>映射语句文件中的所有 select 结果都将被缓存</li>
<li>映射语句文件中的所有 insert、update、delete 都会刷新缓存</li>
<li>缓存会使用 最少使用算法 来清除不需要的缓存</li>
<li>缓存不会定时进行刷新</li>
<li>缓存会保存列表或对象的1024个引用</li>
<li>缓存会被视为读/写缓存，意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或县城所做的潜在修改</li>
</ul>
<blockquote>
<p>缓存只作用于 cache 标签所在的映射文件中的语句。混用 API和XML，在共用接口中的语句将不会被默认缓存。 可以修改cache 元素的属性：</p>
</blockquote>
<pre><code class="xml">&lt;cache 
       eviction=&quot;FIFO&quot; // FIFO缓存
       flushInerval=&quot;60000&quot; // 每隔60秒刷新
       size=&quot;512&quot;         // 最多可存512个引用
       readOnly=&quot;true&quot;  // 返回对象只读
/&gt;</code></pre>
<p>可用的清除策略：</p>
<ul>
<li>LRU - 最近最少使用：移除最长时间不被使用的对象</li>
<li>FIFO - 先进先出：按对象进入缓存的顺序来移除他们</li>
<li>SOFT - 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li>WEAK - 弱引用：更积极地基于垃圾回收期状态和弱引用规则移除对象</li>
</ul>
<h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><p>通过实现 Cache 接口或者第三方缓存方案，来完全覆盖缓存行为。</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;</code></pre>
<blockquote>
<p>上面说到的缓存配置（如清除策略、可读写等），不适用于自定义缓存</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《SpringSecurity》/23.自定义权限验证/">《Spring Security》自定义权限验证@PreAuthorize</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Spring-Security/">Spring Security</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spring-Security/">Spring Security</a></span><div class="content"><h1 id="自定义安全表达式"><a href="#自定义安全表达式" class="headerlink" title="自定义安全表达式"></a>自定义安全表达式</h1><pre><code class="java">/**
 * Base root object for use in Spring Security expression evaluations.
 *
 * @author Luke Taylor
 * @since 3.0
 */
public abstract class SecurityExpressionRoot implements SecurityExpressionOperations</code></pre>
<p>SecurityExpressionRoot 是所有安全表达式的基类，我们需要做的就是：</p>
<ol>
<li>继承 SecurityExpressionRoot，自定义 MethodSecurity 表达式</li>
<li>继承 DefaultMethodSecurityExpressionHandler，自定义方法级别的安全校验处理器</li>
<li>继承 GlobalMethodSecurityConfiguration，添加自定义的表达式处理器</li>
</ol>
<h2 id="一、MethodSecurityConfig"><a href="#一、MethodSecurityConfig" class="headerlink" title="一、MethodSecurityConfig"></a>一、MethodSecurityConfig</h2><p>开启方法级别的安全校验，注入登录用户时加载 UserDetails 的DB服务对象，通过 createExpressionHandler 注入自定义的表达式处理器。</p>
<pre><code class="java">/**
 * 配置 MethodSecurity 表达式
 */
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

    private final LoginDetailService loginDetailService;

    public MethodSecurityConfig(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        return new ResourceMethodSecurityExpressionHandler(loginDetailService);
    }
}</code></pre>
<h2 id="二、ResourceMethodSecurityExpressionHandler"><a href="#二、ResourceMethodSecurityExpressionHandler" class="headerlink" title="二、ResourceMethodSecurityExpressionHandler"></a>二、ResourceMethodSecurityExpressionHandler</h2><p>接收 UserDetailsService，并创建一个处理表达式的操作类</p>
<pre><code class="java">/**
 * 自定义方法级别的安全校验处理器
 */
public class ResourceMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {

    private final LoginDetailService loginDetailService;

    private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();

    public ResourceMethodSecurityExpressionHandler(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
        final ResourceMethodSecurityExpressionRoot root = new ResourceMethodSecurityExpressionRoot(authentication, loginDetailService);
        root.setPermissionEvaluator(getPermissionEvaluator());
        root.setTrustResolver(this.trustResolver);
        root.setRoleHierarchy(getRoleHierarchy());
        return root;
    }
}</code></pre>
<h2 id="三、ResourceMethodSecurityExpressionRoot"><a href="#三、ResourceMethodSecurityExpressionRoot" class="headerlink" title="三、ResourceMethodSecurityExpressionRoot"></a>三、ResourceMethodSecurityExpressionRoot</h2><p>仿照 hasAuthority，编写一个自己的实现</p>
<pre><code class="java">/**
 * 自定义 MethodSecurity 表达式
 */
@Slf4j
public class ResourceMethodSecurityExpressionRoot extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {

    private LoginDetailService loginDetailService;

    private Object filterObject;
    private Object returnObject;
    private Object target;

    public ResourceMethodSecurityExpressionRoot(Authentication authentication, LoginDetailService loginDetailService) {
        super(authentication);
        this.loginDetailService = loginDetailService;
    }

    /**
     * 自定义接口，是否允许对该id的访问
     */
    public boolean canReadCourse(String courseId) {
        log.debug(&quot;method params courseId&quot;, courseId);
        log.debug(&quot;current principal {}&quot;, getPrincipal());
        return true;
    }

    public final boolean hasGlobalAuthority(String authority) {
        return hasAnyGlobalAuthority(authority);
    }

    public final boolean hasAnyGlobalAuthority(String... authorities) {
        return hasAnyGlobalAuthorityName(null, authorities);
    }

    private boolean hasAnyGlobalAuthorityName(String prefix, String... roles) {
        final String username = ((UserDetails) getPrincipal()).getUsername();
        final UserDetails details = loginDetailService.loadUserByUsername(username);

        if (details.getAuthorities() != null) {
            final Set&lt;String&gt; roleSet = details.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority).collect(Collectors.toSet());

            for (String role : roles) {
                String defaultedRole = getRoleWithDefaultPrefix(prefix, role);
                if (roleSet.contains(defaultedRole)) {
                    return true;
                }
            }
        }

        return false;
    }

    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) {
        if (role == null) {
            return role;
        }
        if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) {
            return role;
        }
        if (role.startsWith(defaultRolePrefix)) {
            return role;
        }
        return defaultRolePrefix + role;
    }

    @Override
    public void setFilterObject(Object filterObject) {
        this.filterObject = filterObject;
    }

    @Override
    public Object getFilterObject() {
        return filterObject;
    }

    @Override
    public void setReturnObject(Object returnObject) {
        this.returnObject = returnObject;
    }

    @Override
    public Object getReturnObject() {
        return returnObject;
    }

    @Override
    public Object getThis() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    @Override
    public void setRoleHierarchy(RoleHierarchy roleHierarchy) {
        super.setRoleHierarchy(roleHierarchy);
    }
}</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/2_XML配置/">《MyBatis》读书笔记 - MyBatis 中的 XML 详细配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/MyBatis/">MyBatis</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="二、MyBatis-中的-XML-详细配置"><a href="#二、MyBatis-中的-XML-详细配置" class="headerlink" title="二、MyBatis 中的 XML 详细配置"></a>二、MyBatis 中的 XML 详细配置</h1><p>MyBatis 的配置文件包含了深深影响 MyBatis 行为的设置和属性信息。配置文档的顶层结构如下：</p>
<ul>
<li>configuration(配置)<ul>
<li>properties(属性)</li>
<li>settings(设置)</li>
<li>typealiases(类型别名)</li>
<li>typeHandlers(类型处理器)</li>
<li>objectFactory(对象工厂)</li>
<li>plugins(插件)</li>
<li>environments(环境配置)<ul>
<li>environment(环境变量)<ul>
<li>transactionManager(事务管理器)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider(数据库厂商标识)</li>
<li>mappers(映射器)</li>
</ul>
</li>
</ul>
<h2 id="一、属性（Properties）"><a href="#一、属性（Properties）" class="headerlink" title="一、属性（Properties）"></a>一、属性（Properties）</h2><p>这些属性都是可外部配置且可动态替换的，如：</p>
<pre><code class="xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;12345678&quot;/&gt;
&lt;/properties&gt;</code></pre>
<p>可替换的动态配置属性值：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>如果属性不值在一个地方进行了配置，那么 MyBatis 的加载顺序如下：</p>
<ul>
<li>首先读取在 properties 元素体内属性值</li>
<li>根据 properties 元素中的 resource 属性读取类路径下的文件或 url 读取属性文件，并覆盖已读取的同名属性</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性</li>
</ul>
<p>因此，方法参数传递的属性优先级最高，其次是 resource/url 指定的配置文件，最后是 properties 中指定的属性。</p>
<p>在 MyBatis 3.4.2 开始，可以为占位符制定一个默认值，如：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!-- 如果属性 username 没有配置，那么默认值为 ut_user --&gt;
     &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>这个特性默认是关闭的，应该添加一个指定的属性来开启这个特性，如：</p>
<pre><code class="xml">&lt;properties resoure=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;!-- 启用默认值特性 --&gt;
    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot; /&gt;
&lt;/properties&gt;</code></pre>
<h2 id="二、设置（settings）"><a href="#二、设置（settings）" class="headerlink" title="二、设置（settings）"></a>二、设置（settings）</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为，下标描述了设置中各项的意图、默认值等。</p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>全局地开关映射器中已经配置的缓存</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关，所有关联对象都会延迟加载，可以通过 fetchType 来覆盖该项</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>开启时，任何方法的调用都会加载该对象的所有属性。否则，每个对象会按需加载</td>
</tr>
<tr>
<td>multipleResultSetsEnabled</td>
<td>是否允许单一语句返回多结果集（需要驱动支持）</td>
</tr>
<tr>
<td>useColumnLabel</td>
<td>使用列标签代替列名</td>
</tr>
<tr>
<td>useGeneratedKeys</td>
<td>允许 JDBC 支持自动生成主键</td>
</tr>
<tr>
<td>autoMappingBehavior</td>
<td>指定MyBatis应如何自动映射列到字段或属性。NONE：取消自动映射；PARTIAL：自动映射没有定义嵌套结果集的；FULL：自动映射任意复杂的结果集</td>
</tr>
<tr>
<td>autoMappingUnknownColumnBehavior</td>
<td>指定发现自动映射目标未知列（或未知属性）的行为。NONE：不做任何反应；WARNING：输出提醒日志；FAILING：映射失败（抛出SqlSessionException）</td>
</tr>
<tr>
<td>defaultExecutorType</td>
<td>配置默认的执行器。SIMPLE：普通执行器；REUSE 执行器会重用预处理语句；BATCH：执行器将重用语句并执行批量更新</td>
</tr>
<tr>
<td>defaultStatementTimeout</td>
<td>设置超时时间，决定驱动等待数据库响应的描述</td>
</tr>
<tr>
<td>defaultFetchSize</td>
<td>为驱动的结果集获取数量（fetchSize）设置一个提示值</td>
</tr>
<tr>
<td>defaultResultSetType</td>
<td>指定每个语句的省略滚动策略</td>
</tr>
<tr>
<td>safeRowBoundsEnabled</td>
<td>允许在嵌套语句中使用分页（RowBounds）。false为允许</td>
</tr>
<tr>
<td>safeResultHandlerEnabled</td>
<td>允许在嵌套局域中使用分页(RowHandler)。false为允许</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启自动驼峰命名规则映射，即从列名 A_COLUMN 到 Java 属性名 aColumn 的类似映射</td>
</tr>
<tr>
<td>localCacheScope</td>
<td>MyBatis 利用本地缓存机制防止循环引用和加速重复嵌套查询。SESSION：默认，会缓存一个会话中执行的所有查询；STATEMENT：仅用在局域执行上，对相同的 SqlSession 的不同调用不会共享数据</td>
</tr>
<tr>
<td>jdbcTypeForNull</td>
<td>当没有参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型</td>
</tr>
<tr>
<td>lazyLoadTriggerMethods</td>
<td>指定哪个对象的方法触发一次延迟加载</td>
</tr>
<tr>
<td>defaultScriptingLanguage</td>
<td>指定动态 SQL 生成的默认语言</td>
</tr>
<tr>
<td>defaultEnumTypeHandler</td>
<td>指定 Enum 使用的默认 TypeHandler(3.4.5)</td>
</tr>
<tr>
<td>callSettersOnNulls</td>
<td>指定当结果集中值为 null 时，是否调用映射对象的 setter 方法。</td>
</tr>
<tr>
<td>returnInstanceForEmptyRow</td>
<td>当返回的列都是空时，MyBatis默认返回 null。开启后，会返回一个空实例</td>
</tr>
<tr>
<td>logPrefix</td>
<td>指定 MyBatis 增加到日志名称的前缀</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找</td>
</tr>
<tr>
<td>proxyFactory</td>
<td>指定 MyBatis 创建具有延迟加载能力的对象所用到的代理工具</td>
</tr>
<tr>
<td>vfsImpl</td>
<td>指定 VFS 的实现</td>
</tr>
<tr>
<td>useActualParamName</td>
<td>允许使用方法签名中的名称作为语句参数名称。需要java 8编译，并加上 -parameters 选项</td>
</tr>
<tr>
<td>configurationFactory</td>
<td>指定一个提供 Configuration 实例的类。这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。这个类必须包含一个签名为 static Configuration getConfiguration() 的方法(3.2.3)</td>
</tr>
</tbody></table>
<p>一个完整的 settings 元素示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;multipleResultSetEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;EXAMPLE&quot;/&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
&lt;/settings&gt;</code></pre>
<h2 id="三、类型别名（typeAliases）"><a href="#三、类型别名（typeAliases）" class="headerlink" title="三、类型别名（typeAliases）"></a>三、类型别名（typeAliases）</h2><p>类型别名用来减少类完全限定名的冗余，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;typeAlias alias=&quot;Author&quot; type=&quot;cn.luokaiii.adminservice.model.Author&quot;/&gt;
    &lt;typeAlias alias=&quot;Teacher&quot; type=&quot;cn.luokaiii.adminservice.model.Teacher&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
<p>也可以指定一个报名，MyBatis 会在包名下搜索 Java Bean，在没有注解的情况下，会使用Bean 的首字母小写的非限定类名来作为它的别名，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;package name=&quot;domain.blog&quot; /&gt;
&lt;/typeAliases&gt;</code></pre>
<p>或者使用注解的方式，如：</p>
<pre><code class="java">@Alias(&quot;author&quot;)
public class Author {
    ......
}</code></pre>
<p>Java 类型内建的相应类型别名（不区分大小写）：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashMap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="四、类型处理器（typeHandlers）"><a href="#四、类型处理器（typeHandlers）" class="headerlink" title="四、类型处理器（typeHandlers）"></a>四、类型处理器（typeHandlers）</h2><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换为 Java 类型。</p>
<table>
<thead>
<tr>
<th>类型处理器</th>
<th>Java 类型</th>
<th>JDBC 类型</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanTypeHandler</td>
<td>Java.lang.Boolean,boolean</td>
<td>BOOLEAN</td>
</tr>
<tr>
<td>ByteTypeHandler</td>
<td>java.lang.Byte,byte</td>
<td>NUMERIC,BYTE</td>
</tr>
<tr>
<td>ShortTypeHandler</td>
<td>java.lang.Short,short</td>
<td>NUMERIC,SMALLINT</td>
</tr>
<tr>
<td>IntegerTypeHandler</td>
<td>java.lang.Integer,int</td>
<td>NUMERIC,INTEGER</td>
</tr>
<tr>
<td>FloatTypeHandler</td>
<td>java.lang.Float,float</td>
<td>NUMERIC,FLOAT</td>
</tr>
<tr>
<td>DoubleTypeHandler</td>
<td>java.lang.Double,double</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>BigDecimalTypeHandler</td>
<td>java.math.BigDecimal</td>
<td>NUMERIC,DECIMAL</td>
</tr>
<tr>
<td>StringTypeHandler</td>
<td>java.lang.String</td>
<td>CHAR,VARCHAR</td>
</tr>
<tr>
<td>ClobReaderTypeHandler</td>
<td>java.io.Reader</td>
<td>-</td>
</tr>
<tr>
<td>ClobTypeHandler</td>
<td>java.lang.String</td>
<td>CLOB,LONGVARCHAR</td>
</tr>
<tr>
<td>NStringTypeHandler</td>
<td>java.lang.String</td>
<td>NVARCHAR,NCHAR</td>
</tr>
<tr>
<td>NClobTypeHandler</td>
<td>java.lang.String</td>
<td>NCLOB</td>
</tr>
<tr>
<td>BlobInputStreamTypeHandler</td>
<td>java.io.InputStream</td>
<td>-</td>
</tr>
<tr>
<td>ByteArrayTypeHandler</td>
<td>byte[]</td>
<td></td>
</tr>
<tr>
<td>DateTypeHandler</td>
<td>byte[]</td>
<td>L</td>
</tr>
<tr>
<td>DateOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>TimeOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimestampTypeHandler</td>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>SqlDateTypeHandler</td>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimeTypeHandler</td>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>ObjectTypeHandler</td>
<td>Any</td>
<td>OTHER</td>
</tr>
<tr>
<td>EnumTypeHandler</td>
<td>Enum</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>EnumOrdinalTypeHandler</td>
<td>Enum</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>SqlxmlTypeHandler</td>
<td>java.lang.String</td>
<td>SQLXML</td>
</tr>
<tr>
<td>InstantTypeHandler</td>
<td>java.time.Instant</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTimeTypeHandler</td>
<td>java.time.LocalDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTypeHandler</td>
<td>java.time.LocalDate</td>
<td>DATE</td>
</tr>
<tr>
<td>OffsetTimeTypeHandler</td>
<td>java.time.OffsetDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>ZonedDateTimeTypeHandler</td>
<td>java.time.ZonedDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>YearTypeHandler</td>
<td>java.time.Year</td>
<td>INTEGER</td>
</tr>
<tr>
<td>MonthTypeHandler</td>
<td>java.time.Month</td>
<td>INTEGER</td>
</tr>
<tr>
<td>YearMonthTypeHandler</td>
<td>java.time.YearMonth</td>
<td>VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>JapaneseDateTypeHandler</td>
<td>java.time.chrono.JapaneseDate</td>
<td>DATE</td>
</tr>
</tbody></table>
<p>可以通过重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 或集成 org.apache.ibatis.type.BaseTypeHandler，然后将它映射到一个 JDBC 类型：</p>
<pre><code class="java">@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {
  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}</code></pre>
<pre><code class="xml">&lt;typeHandlers&gt;
    &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;</code></pre>
<h2 id="五、对象工厂（objectFactory）"><a href="#五、对象工厂（objectFactory）" class="headerlink" title="五、对象工厂（objectFactory）"></a>五、对象工厂（objectFactory）</h2><p>MyBatis 每次创建结果对象的新实例时，都会使用一个对象工厂（ObjectFactory）实例来完成。要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。</p>
<p>如何想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现，如：</p>
<pre><code class="java">public class ExampleObjectFactory extends DefaultObjectFactory {
    // 包含两个创建方法
    // 处理默认构造方法
    public Object create(Class type){
        return super.create(type);
    }

    // 处理带参数的构造方法
    public Object create(Class type,List&lt;Class&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs){
        return super.create(type,constructorArgTypes,constructorArgs);
    }

    // 可以被用来配置 ObjectFactory，在初始化ObjectFactory后，objectFactory元素体中定义的属性会被传递给 setProperties 方法
    public void setProperties(Properties properties){
        super.setProperties(properties);
    }

    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type){
        return Collection.class.isAssignableFrom(type);
    }
}</code></pre>
<pre><code class="xml">&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;</code></pre>
<h2 id="六、插件（Plugins）"><a href="#六、插件（Plugins）" class="headerlink" title="六、插件（Plugins）"></a>六、插件（Plugins）</h2><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包含：</p>
<ul>
<li>Executor（update、query、flushStatements、commit、rollback、getTransaction、close、isClosed）</li>
<li>ParameterHandler（getParameterObject、setParameters）</li>
<li>ResultSetHandler（handleResultSets、handleOutputParameters）</li>
<li>StatementHandler（prepare、parameterize、batch、update、query）</li>
</ul>
<p>这些都是很底层的类和方法，如果在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis的核心模块，因此在使用插件的时候要当心。</p>
<h2 id="七、环境配置（environments）"><a href="#七、环境配置（environments）" class="headerlink" title="七、环境配置（environments）"></a>七、环境配置（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。</p>
<p>如开发、测试、生产环境需要不同的配置；或者现在相同 Schema 的多个库中使用相同的 SQL 映射。</p>
<blockquote>
<p>尽管可以配置多个环境，但是每个 SqlSessionFactory 实例只能选择一种环境</p>
</blockquote>
<p>环境元素定义了如何配置环境：</p>
<pre><code class="xml">&lt;enviroments default=&quot;development&quot;&gt;
    &lt;enviroment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;...&quot;/&gt;
            ...
        &lt;/dataSource&gt;
    &lt;/enviroment&gt;
&lt;/enviroments&gt;</code></pre>
<p>这里的关键：</p>
<ul>
<li>默认使用的环境ID（default=”development”）</li>
<li>每个元素都有一个环境ID</li>
<li>事务管理器的配置</li>
<li>数据源的配置</li>
</ul>
<h3 id="1-事务管理器（transactionManager）"><a href="#1-事务管理器（transactionManager）" class="headerlink" title="1. 事务管理器（transactionManager）"></a>1. 事务管理器（transactionManager）</h3><p>MyBatis 有两种类型的事务管理器：</p>
<ol>
<li>JDBC - 直接使用 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务作用域</li>
<li>MANAGED - 让容器来管理事务的整个生命周期。默认会关闭连接，然而一些容器不希望这样，因此需要将 closeConnection 设置为 false 来阻止它默认的关闭行为</li>
</ol>
<blockquote>
<p>如果使用 Spring+MyBatis，则没必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</blockquote>
<h3 id="2-数据源（DataSource）"><a href="#2-数据源（DataSource）" class="headerlink" title="2. 数据源（DataSource）"></a>2. 数据源（DataSource）</h3><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<p>MyBatis 提供了三种内建的数据源类型。</p>
<h4 id="UNPOOLED"><a href="#UNPOOLED" class="headerlink" title="UNPOOLED"></a>UNPOOLED</h4><p>每次被请求时打开和关闭连接</p>
<h4 id="POOLED"><a href="#POOLED" class="headerlink" title="POOLED"></a>POOLED</h4><p>使用连接池的方式，避免创建新实例时所需的初始化和认证时间</p>
<h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p>为了能在如 EJB 或应用服务器这类容器汇总使用，容器可以集成或在外部配置数据源</p>
<h4 id="第三方数据源"><a href="#第三方数据源" class="headerlink" title="第三方数据源"></a>第三方数据源</h4><p>可以通过实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 来使用第三方数据源。</p>
<h2 id="八、数据库厂商标识（databaseIdProvider）"><a href="#八、数据库厂商标识（databaseIdProvider）" class="headerlink" title="八、数据库厂商标识（databaseIdProvider）"></a>八、数据库厂商标识（databaseIdProvider）</h2><h2 id="九、映射器（mappers）"><a href="#九、映射器（mappers）" class="headerlink" title="九、映射器（mappers）"></a>九、映射器（mappers）</h2><p>mappers 定义 SQL 映射语句，告诉 MyBatis 去哪里找这些语句。如：</p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用完全限定资源定位符 URL --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/1_入门/">《MyBatis》读书笔记 - 入门</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/MyBatis/">MyBatis</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>构建项目，需要引入如下的 dependency 到 pom.xml 中：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;or.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="2-从XML配置SQLSessionFactory"><a href="#2-从XML配置SQLSessionFactory" class="headerlink" title="2. 从XML配置SQLSessionFactory"></a>2. 从XML配置SQLSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。</p>
<p>以下 XML 配置文件中包含了对 MyBatis 系统的核心设置，如获取数据源(DataSource)和决定事务作用于和控制方式的事务管理器(TransactionManager)：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot; /&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<p>使用类路径下的资源文件进行配置，构建 SqlSessionFactory 实例：</p>
<pre><code class="java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre>
<h2 id="3-从SqlSessionFactory-获取-SqlSession"><a href="#3-从SqlSessionFactory-获取-SqlSession" class="headerlink" title="3. 从SqlSessionFactory 获取 SqlSession"></a>3. 从SqlSessionFactory 获取 SqlSession</h2><p>SqlSession 中完全包含了面向数据库执行 SQL 命令所需的所有方法，例如：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    Blog blog = (Blog)session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;,101);
}</code></pre>
<p>或者使用一种更简单的方式：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Blog blog = mapper.selectBlog(101);
}</code></pre>
<h3 id="提示：命名空间（Namespaces）"><a href="#提示：命名空间（Namespaces）" class="headerlink" title="提示：命名空间（Namespaces）"></a>提示：命名空间（Namespaces）</h3><p>命名空间的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了接口绑定。</p>
<p>命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ol>
<li>完全限定名，将被直接用于查找和使用</li>
<li>短名称，如果全局唯一也可作为单独的应用。如果不唯一，那么使用时就会出现错误，此时就需要使用完全限定名</li>
</ol>
<h2 id="4-基于-XML-映射语句的示例"><a href="#4-基于-XML-映射语句的示例" class="headerlink" title="4. 基于 XML 映射语句的示例"></a>4. 基于 XML 映射语句的示例</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h2 id="5-基于注解的示例"><a href="#5-基于注解的示例" class="headerlink" title="5. 基于注解的示例"></a>5. 基于注解的示例</h2><pre><code class="java">public interface BlogMapper {
    @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;)
    Blog selectBlog(int id);
}</code></pre>
<h2 id="6-作用域（Scope）和生命周期"><a href="#6-作用域（Scope）和生命周期" class="headerlink" title="6. 作用域（Scope）和生命周期"></a>6. 作用域（Scope）和生命周期</h2><p><code>依赖注入框架</code>可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要了。</p>
<p>因此该实例的最佳作用域为<code>方法作用域</code>，可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory，但是使用后最好不要让其一直存在，以保证 XML 资源可以被释放。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>一旦创建就应该在应用的运行期间一直存在，尽量不要重复创建该实例。</p>
<p>因此该实例的最佳作用域为<code>应用作用域</code>。可以使用单例模式或静态单例模式来做到。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该由自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此不能被共享。</p>
<p>因此该实例的最佳作用于为<code>请求或方法作用域</code>。绝不能将 SqlSession 的实例引用放在静态域中，甚至一个类的实例变量也不行，也不能将引用放在任何类型的托管作用域中（如Servlet 的HttpSession）。</p>
<p>如果您使用的是 Web 框架，那么应该考虑将 SqlSession 放在和 Http 请求对象相似的作用域中。即每次 Http 请求，都打开一个 SqlSession，返回响应后就关闭它。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是映射Sql语句的接口，该接口的实例是从 SqlSession 中获得的。</p>
<p>因此该实例的最佳作用于<code>与 SqlSession 的作用域保持一致</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/分布式/SpringBoot/Sso单点登录/">单点登录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分布式/">分布式</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a></span><div class="content"><h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="一、单点登录机制"><a href="#一、单点登录机制" class="headerlink" title="一、单点登录机制"></a>一、单点登录机制</h2><pre><code>web 应用采用的是 b/s 架构，以 http 作为通信协议。而 http 是无状态协议，浏览器每一次请求，服务器都会独立处理，不与之前或者之后的请求产生关联。</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155231912-1627010726.png" alt></p>
<pre><code>在三次请求、响应对之间没有任何联系。这同时也意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，就需要服务器和浏览器共同维护一个状态，这就是会话机制。</code></pre><h2 id="二、会话机制"><a href="#二、会话机制" class="headerlink" title="二、会话机制"></a>二、会话机制</h2><pre><code>浏览器第一次请求服务器，服务器创建一个会话，并将会话 id 作为响应的一部分发送给浏览器，浏览器存储会话 id ，并在后续的第二次和第三次请求中带上会话 id ，服务器取得请求中的会话 id 就知道是不是同一个用户了。</code></pre><blockquote>
<p>服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？</p>
</blockquote>
<pre><code>1.请求参数：将会话 id 作为每一次请求的参数，服务器接收请求自然能解析参数获得会话 id ，并借此判断是否来自同一会话，很明显不靠谱。

2.cookie：是浏览器用来存储少量数据的一种机制，数据以&quot; key/value&quot;形式存储，浏览器发送 http 请求时自动附带 cookie 信息。</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155234443-99011212.png" alt></p>
<pre><code>tomcat会话机制中也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID” 的cookie，这就是 tomcat 会话机制维护的会话 id 。</code></pre><h2 id="三、登录状态"><a href="#三、登录状态" class="headerlink" title="三、登录状态"></a>三、登录状态</h2><pre><code>我们假设浏览器第一次请求服务器需要输入用户名与密码来验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“一登录”之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象那个中的登录状态如下：

    HttpSession session = request.getSession();
    session.setAttribution(&quot;isLogin&quot;,true);
再次访问时，tomcat会在会话对象中查看登录状态。
每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin 时才能访问，登录机制因此实现。</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155235693-1708276896.png" alt></p>
<h2 id="四、多系统的复杂性"><a href="#四、多系统的复杂性" class="headerlink" title="四、多系统的复杂性"></a>四、多系统的复杂性</h2><pre><code>web系统由原始的单系统发展成为如今由多系统组成的应用群，面对多个系统，用户不可能以一个个登录再一个个注销。
而且由多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体。

虽然cookie是解决单系统登录的核心，但是cookie的限制在于cookie的域，浏览器发送 http 请求时会自动携带与该域匹配的 cookie ，而不是所有 cookie。

在早些年，很多登录系统就采用同域名共享 cookie 的方式，将 web 应用群中所有子系统的域名统一在一个顶级域名下，然后将它们的 cookie 域设置为“baidu.com”。这样做虽然可行，但并不好。共享 cookie 的方式存在众多局限：首先，应用群域名得统一；其次，应用群各系统使用的技术(至少是 web 服务器)要相同，不然 cookie 的key值不相同（例如 tomcat 的是 JSESSIONID），无法维持会话，共享 cookie 的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间；第三，cookie本身并不安全。

因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</code></pre><h2 id="五、单点登录"><a href="#五、单点登录" class="headerlink" title="五、单点登录"></a>五、单点登录</h2><pre><code>单点登录(Single Sign On)，指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</code></pre><p><img src="http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155238365-788619473.png" alt></p>
<h3 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h3><pre><code>对比单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。

间接授权通过令牌实现，sso 认证中心验证用户的用户名密码没问题，创建授权令牌吗，在跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即通过了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。
这个过程就是单点登录的原理。</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png" alt></p>
<p>简要描述</p>
<ol>
<li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户未登录，将用户引导至登录页面</li>
<li>用户输入用户名密码提交登录申请</li>
<li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</li>
<li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</li>
<li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 1</li>
<li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li>
<li>用户访问系统 2 的受保护资源</li>
<li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</li>
<li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</li>
<li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 2</li>
<li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</li>
</ol>
<h3 id="2-注销"><a href="#2-注销" class="headerlink" title="2.注销"></a>2.注销</h3><pre><code>单点登录的注销，在一个子系统中注销，所有子系统的会话都将被销毁：
sso认证中心一直坚挺全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作　　</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155243068-1378377736.png" alt></p>
<p>简要说明</p>
<ol>
<li>用户向系统 1 发起注销请求</li>
<li>系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求</li>
<li>sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso 认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收 sso 认证中心的注销请求，销毁局部会话</li>
<li>sso 认证中心引导用户至登录页面</li>
</ol>
<h2 id="六、部署图"><a href="#六、部署图" class="headerlink" title="六、部署图"></a>六、部署图</h2><pre><code>单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso 服务端，整个单点定了公路过程实质是 sso 客户端与服务端通信的过程。</code></pre><p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155244646-2067469767.png" alt title="图片"></p>
<pre><code>sso 认证中心与 sso 客户端通信方式有多种，例如 webservice、rpc、restful api等

sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</code></pre><p>sso-client</p>
<p>拦截子系统未登录用户请求，跳转至 sso 认证中心<br>接收并存储 sso 认证中心发送的令牌<br>与 sso-server 通信，校验令牌的有效性<br>建立局部会话<br>拦截用户注销请求，向 sso 认证中心发送注销请求<br>接收 sso 认证中心发出的注销请求，销毁局部会话<br>　　 sso-server</p>
<p>验证用户的登录信息<br>创建全局会话<br>创建授权令牌<br>与 sso-client 通信发送令牌<br>校验 sso-client 令牌有效性<br>系统注册<br>接收 sso-client 注销请求，注销所有会话<br>　　接下来，我们按照原理来一步步实现 sso 吧！</p>
<p>1、sso-client 拦截未登录请求<br>　　 java 拦截请求的方式有 servlet、filter、listener 三种方式，我们采用 filter。在 sso-client 中新建 LoginFilter.java 类并实现 Filter 接口，在 doFilter()方法中加入对未登录用户的拦截</p>
<p>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {<br>HttpServletRequest req = (HttpServletRequest) request;<br>HttpServletResponse res = (HttpServletResponse) response;<br>HttpSession session = req.getSession();</p>
<p> if (session.getAttribute(“isLogin”)) {<br>chain.doFilter(request, response);<br>return;<br>}<br>//跳转至 sso 认证中心<br>res.sendRedirect(“sso-server-url-with-system-url”);<br>}<br>2、sso-server 拦截未登录请求<br>　　拦截从 sso-client 跳转至 sso 认证中心的未登录请求，跳转至登录页面，这个过程与 sso-client 完全一样</p>
<p>3、sso-server 验证用户登录信息<br>　　用户在登录页面输入用户名密码，请求登录，sso 认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p>
<p>@RequestMapping(“/login”)<br>public String login(String username, String password, HttpServletRequest req) {<br>this.checkLoginInfo(username, password);<br>req.getSession().setAttribute(“isLogin”, true);<br>return “success”;<br>}<br>4、sso-server 创建授权令牌<br>　　授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子</p>
<p>String token = UUID.randomUUID().toString();<br>5、sso-client 取得令牌并校验<br>　　 sso 认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去 sso 认证中心校验，在 LoginFilter.java 的 doFilter()中添加几行</p>
<p>// 请求附带 token 参数<br>String token = req.getParameter(“token”);<br>if (token != null) {<br>// 去 sso 认证中心校验 token<br>boolean verifyResult = this.verify(“sso-server-verify-url”, token);<br>if (!verifyResult) {<br>res.sendRedirect(“sso-server-url”);<br>return;<br>}<br>chain.doFilter(request, response);<br>}<br>　　 verify()方法使用 httpClient 实现，这里仅简略介绍，httpClient 详细使用方法请参考官方文档</p>
<p>HttpPost httpPost = new HttpPost(“sso-server-verify-url-with-token”);<br>HttpResponse httpResponse = httpClient.execute(httpPost);<br>6、sso-server 接收并处理校验令牌请求<br>　　用户在 sso 认证中心登录成功后，sso-server 创建授权令牌并存储该令牌，所以，sso-server 对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后 sso-server 将发送校验请求的系统注册到 sso 认证中心（就是存储起来的意思）</p>
<p>令牌与注册系统地址通常存储在 key-value 数据库（如 redis）中，redis 可以为 key 设置有效时间也就是令牌的有效期。redis 运行在内存中，速度非常快，正好 sso-server 不需要持久化任何数据。</p>
<p>令牌与注册系统地址可以用下图描述的结构存储在 redis 中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向 sso 认证中心提交注销请求，sso 认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p>
<p><img src="https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155245506-1069288802.png" alt></p>
<p>7、sso-client 校验令牌成功创建局部会话<br>　　令牌校验成功后，sso-client 将当前局部会话标记为“已登录”，修改 LoginFilter.java，添加几行</p>
<p>if (verifyResult) {<br>session.setAttribute(“isLogin”, true);<br>}<br>　　 sso-client 还需将当前会话 id 与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用 java 的 hashmap 保存，保存的数据用来处理 sso 认证中心发来的注销请求</p>
<p>8、注销过程<br>　　用户向子系统发送带有“logout”参数的请求（注销请求），sso-client 拦截器拦截该请求，向 sso 认证中心发起注销请求</p>
<p>String logout = req.getParameter(“logout”);<br>if (logout != null) {<br>this.ssoServer.logout(token);<br>}<br>　　 sso 认证中心也用同样的方式识别出 sso-client 的请求是注销请求（带有“logout”参数），sso 认证中心注销全局会话</p>
<p>@RequestMapping(“/logout”)<br>public String logout(HttpServletRequest req) {<br>HttpSession session = req.getSession();<br>if (session != null) {<br>session.invalidate();//触发 LogoutListener<br>}<br>return “redirect:/“;<br>}<br>　　 sso 认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>public class LogoutListener implements HttpSessionListener {<br>@Override<br>public void sessionCreated(HttpSessionEvent event) {}<br>@Override<br>public void sessionDestroyed(HttpSessionEvent event) {<br>//通过 httpClient 向所有注册系统发送注销请求<br>}<br>}</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/分布式/SpringCloud/分布式并发问题/">分布式环境中的并发问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分布式/">分布式</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a></span><div class="content"><p>分布式环境中，处理并发问题没发通过操作系统和 JVM 提供的工具来解决，因为 LOCK 命令、总线锁、缓存所、monitor 对象、锁、等并发工具都无法影响到其他服务器的线程。</p>
<p>那么在分布式环境中，可以使用一下策略和方式处理：</p>
<ol>
<li>避免并发<ol>
<li>通过某些策略和业务来避免并发，如合理分配时间调度，避开共享资源的存取冲突等。</li>
<li>可以通过 hash 算法的方式，使一个对象的数据计算和访问都交给同一个线程来完成</li>
</ol>
</li>
<li>时间戳<ol>
<li>每次系统 A 发送给系统 B 的时候都带上一个时间戳，B 在拿到通知后，比较时间戳</li>
<li>这样只需要调用方保证时间戳的时序有效性即可</li>
</ol>
</li>
<li>串行化<ol>
<li>串行化可能产生并发的问题，通过牺牲性能和扩展性，来满足对数据一致性的要求。</li>
<li>比如分布式消息系统，没法保证消息的有序性，但是可以通过将分布式消息系统改为单一消息系统，就可以保证消息的有序性了。</li>
<li>如果接收方无法保证处理的有序性，那么可以使用一个队列将调用信息缓存起来，再串行地处理这些调用</li>
</ol>
</li>
<li>数据库<ol>
<li>在分布式环境中，数据库是个服务器的共享点，可以通过数据库的高可靠一致性机制来满足需求。</li>
<li>比如通过唯一性约束，来解决并发过程中重复数据的生产或重复任务的执行</li>
<li>某些更新操作也尽量使用 SQL 来完成，在程序中计算后再更新，可能会出现脏复写的问题，但是通过一条 SQL 来完成计算和更新，就能通过数据库的锁机制来保证更新的一致性</li>
</ol>
</li>
<li>行锁<ol>
<li>有些事务较为复杂时，无法通过一条 SQL 解决问题，并且可能存在并发问题，此时可以考虑使用行锁来解决问题</li>
<li>如 select … for update ，在查询后将该行数据锁定，直到 commit。但是这么做会导致其他涉及该行的所有操作都会被挂起</li>
<li>通过在表中增加一个标志锁的字段，每次操作之前通过 update，来模拟竞争锁的操作，操作完成后再 update 复位该标志，表示锁归还。（这种操作很类似 Redis 分布式锁、MongoDB 分布式锁，说白了就是自己定义一个模拟竞争锁的场景）</li>
</ol>
</li>
<li>统一触发途径<ol>
<li>如果一个数据会被多个业务同时涉及到，就会有并发问题产生的隐患。因此可以通过前期架构和业务涉及，尽量统一触发途径，减少并发的可能，也有利于对并发问题的分析和判断。</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/cutesource/article/details/5791350" target="_blank" rel="noopener">文章总结自 : https://blog.csdn.net/cutesource/article/details/5791350</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/分布式/SpringBoot/SpringBoot常用Listener/">SpringBoot中的几种常见监听器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分布式/">分布式</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a></span><div class="content"><h1 id="SpringBoot-的几种常见监听器"><a href="#SpringBoot-的几种常见监听器" class="headerlink" title="SpringBoot 的几种常见监听器"></a>SpringBoot 的几种常见监听器</h1><p>例如：在 Web 项目启动时，需要执行一段代码，该写在哪里呢？<br>解决方法：注册监听器监听 ServletContext 创建的钩子函数，并重写自己的实现</p>
<h2 id="1-创建-Listener"><a href="#1-创建-Listener" class="headerlink" title="1. 创建 Listener"></a>1. 创建 Listener</h2><pre><code class="java">@WebListener
public class InitDemo implements ServletContextListener {

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println(&quot;Web Initialized!&quot;);
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println(&quot;Web Destroyed!&quot;);
    }
}</code></pre>
<blockquote>
<p>使用 @WebListener 注册声明类为监听器</p>
</blockquote>
<h2 id="2-添加-servlet-扫描"><a href="#2-添加-servlet-扫描" class="headerlink" title="2. 添加 servlet 扫描"></a>2. 添加 servlet 扫描</h2><pre><code class="java">@SpringBootApplication
@ServletComponentScan(basePackages = &quot;com.test.*&quot;)
public class App {
    public static void main(String[] args){
        SpringApplication.run(App.class,args);
    }
}</code></pre>
<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>启动项目，可在堆栈信息中找到对应的输出</p>
<h2 id="4-常见监听器接口"><a href="#4-常见监听器接口" class="headerlink" title="4. 常见监听器接口"></a>4. 常见监听器接口</h2><ol>
<li>ServletContextListener - 监听 ServletContext 对象的创建及销毁<ol>
<li>contextInitialized(ServletContextEventsce) - web 应用程序初始化进程正在启动的通知</li>
<li>contextDestroyed(ServletContextEvent sce) - 通知 servlet 上下文即将关闭。所有 servlet 和过滤器之前已经被销毁()</li>
</ol>
</li>
<li>HttpSessionListener - 监听 session 对象的创建及销毁<ol>
<li>sessionCreated(HttpSessionEvent se) - 创建会话的通知</li>
<li>sessionDestroyed(HttpSessionEvent se) - 会话即将失效的通知</li>
</ol>
</li>
<li>ServletRequestListener - 监听 request 对象的创建及销毁<ol>
<li>requestDestroyed(ServletRequestEvent src) - 请求将超出 web 应用程序的范围</li>
<li>requestInitialized(ServletRequestEvent src) - 请求将进入 web 应用程序的范围</li>
</ol>
</li>
<li>ServletContextAttributeListener - 监听 servletContext 对象中属性的变化<ol>
<li>attributeAdded(ServletContextAttributeEvent scae) - 通知 servlet 上下文中添加了一个新属性。在添加属性后调用</li>
<li>attributeRemoved(ServletContextAttributeEvent scae) - 从 servlet 上下文中删除现有属性的通知。删除属性后调用</li>
<li>attributeReplaced(ServletContextAttributeEvent scae) - 通知 servlet 上下文上的属性已被替换。替换属性后调用。</li>
</ol>
</li>
<li>HttpSessionAttributeListener - 监听 session 对象中属性的改变<ol>
<li>同 ServletContextAttributeListener</li>
</ol>
</li>
<li>ServletRequestAttributeListener - 监听 request 对象中属性的改变<ol>
<li>同 ServletContextAttributeListener</li>
</ol>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/Interview/20190903上海基诺联生物/">20190903上海基诺联生物科技有限公司</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/面试题/">面试题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a></span><div class="content"><ol>
<li>公司最新的业务，为什么有两个云平台<ol>
<li>一个教学平台，一个比赛平台，然后说一些业务</li>
</ol>
</li>
<li>搭建过权限架构，使用的是什么框架？是如何实现 Spring Security 的？Spring Security 是如何实现权限验证的？<ol>
<li>Spring Security，引入依赖，配置一个 Configure，开启 Security Method 验证，自定义实现 UserDetailsService，扩展 UserDetails，加载 Authority，默认存入 Session 中，可以将 Session 扩展到 Redis、MongoDB 等地方保存，即可加载出用户信息到 SecurityContext 中。</li>
<li>通过@PreAuthorize 可以验证之前加载的 Authority 权限数组。</li>
</ol>
</li>
<li>如果用户保存在 Session 中，那么权限变更后如何重新加载权限？<ol>
<li>现在的解决方案：SpringSecurity 是通过 @PreAuthorize 的 SecurityExpressionOperations 实现类，如 hasAuthority()、hasAnyAuthority(…) 来验证的，那么我们只要实现一个 hasCustomAuthority() 改为从 Redis、MongoDB 等地直接获取用户存储的权限即可。通过使用自定义的接口，扩展 Security 的验证</li>
<li>不用担心性能问题，因为我们的 Session 存储在 Redis、MongoDB 中，那么程序每次获取 Session 时，都会从 Redis、MongoDB 中取。那么自定义接口所修改的，只是从 spring_sessions 表改为了自己的用户权限表。</li>
</ol>
</li>
<li>JDK 版本是多少？1.8 有哪些新特性？说说你对流式编程的理解？如何从 List<user>中取出所有的 username？<ol>
<li>jdk8 主要增加了对集合类的流式操作，也就是所说的 lambda 表达式，使我们对集合的遍历等操作更加便利。</li>
<li>userList.stream().map(val -&gt; val.getUsername()).collect(toList())</li>
</ol>
</user></li>
<li>用过索引没？谈谈索引的作用？谈谈复合索引<ol>
<li>索引的主要作用是优化查询，在数据库的某一个字段上创建了索引后，对该表的某一个字段查询时，将不再遍历整张表，而是遍历索引树。但是索引不应该创建的过多，如果索引树过于庞大的话，对性能也有很大的影响</li>
<li>复合索引，就是以一个数组的方式保存多个字段，然后在查询时，依次按照索引的位置从左到右查询</li>
<li>以下来自于“高性能 MySQL”中对索引设计的规范：<ol>
<li>禁止给每个列都建立索引，单表索引建议不超过 5 个</li>
<li>索引定义在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>索引定义在 OrderBy、GroupBy、Distinct 中的字段</li>
<li>多表 Join 的字段</li>
<li>复合索引，区分度高的放左侧、字段长度小的放左侧、使用最频繁的放左侧</li>
<li>避免冗余索引和重复索引，MySQL 在执行优化时需要选择具体的索引，降低了索引使用效率</li>
<li>避免使用外键约束，建议在业务端保证数据的参照完整性，因为外键会影响父表和子表的写操作而降低性能</li>
<li>不建议使用外键约束，但一定要在表与表的关联键上建立索引</li>
</ol>
</li>
</ol>
</li>
<li>说一说数据库事务是什么？回滚是在什么情况下发生的(提示)？<ol>
<li>我只说了数据隔离，然后被提示之后才想到一致性</li>
<li>数据隔离，比如数据插入时阻塞其他插入操作，数据查询时阻塞其他插入操作等，这些由数据库的事务隔离级别来决定（还好没问我数据库的隔离级别，越简单的越不容易记），避免脏读</li>
<li>回滚是为了保存数据的一致性，在同一个事务中执行的 SQL 会保持一致性，只能全部执行成功。如果某一个 SQL 出现了异常，会导致整个事务回滚到执行之前的状态。</li>
</ol>
</li>
<li>什么是分布式锁？怎么实现分布式锁？<ol>
<li>分布式锁就是为了解决集群环境时，JVM 和锁无法工作的问题。因为多台服务器的线程彼此之间没办法互相加锁，因此需要一些第三方中间件来帮助我们来模拟加锁行为。</li>
<li>比如 Redis、Zookeeper、MongoDB 等中间件，我们定义一个标识位，在我们进行一些对数据有要求的插入等操作时，为了避免其他线程同时执行，我们需要在执行之前尝试获取这个标志位，如果获取成功了，那么执行，获取失败则等待、轮询、或者抛出异常。</li>
</ol>
</li>
<li>Redis 是如何实现分布式锁的？<ol>
<li>Redis 有一个 setNX 的语句，是一个 CAS 操作，会先比较某一个值是否存在，如果不存在才设置，存在则不设置。</li>
<li>setNX 比直接查询再赋值，要原子化，将查询并修改合为一个操作。查询再赋值的操作再怎么快也是有时间间隔的。</li>
</ol>
</li>
<li>Redis 有哪些数据结构？(对 Redis 不太熟悉，带过了)<ol>
<li>string、hash、list、set、sorted set（后续查的）</li>
</ol>
</li>
<li>公司是如何使用 Docker 的？Docker 是如何创建镜像的？<ol>
<li>（白话）公司将 Nginx、后台的 Java Jar、前端编译后的包，都挂载到 docker 上，并使用容器的方式启动和运行。使用 Docker 能够保证每次容器运行时的环境都是隔离的。使用方法：在项目根目录下写一个 Dockerfile，然后在文件中指定所需的 jdk 版本、redis 等其他中间件服务。（后面这段没回答上来）然后通过 docker build 的方法生成镜像，然后将镜像通过 docker push 的方式推送到远程云上。push 之后我就不知道了。这些是从公司的 jenkins 上学到的。</li>
</ol>
</li>
<li>你有什么要了解的吗？<ol>
<li>打脸行为：</li>
<li>问：技术栈听贴合的，那么公司用的什么 ORM 框架呢？答：Mybatis，你用的是 JPA？</li>
<li>就这吧，嘟嘟嘟……</li>
</ol>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/05/读书笔记/《Jenkins》实战笔记/jenkins-springboot/">Jenkins 从零到有部署一个Java项目</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Jenkins部署/">Jenkins部署</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/hide/">hide</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Jenkins部署/">Jenkins部署</a></span><div class="content"><h1 id="Docker-Nginx-Jenkins-部署-SpringBoot-Jar"><a href="#Docker-Nginx-Jenkins-部署-SpringBoot-Jar" class="headerlink" title="Docker + Nginx + Jenkins 部署 SpringBoot Jar"></a>Docker + Nginx + Jenkins 部署 SpringBoot Jar</h1><p>本文能解决的问题：</p>
<ol>
<li>如何使用Docker 部署Jenkins</li>
<li>Jenkins 会重写url(使用三级域名)</li>
<li>nginx 配置 jenkins、前端、后端</li>
<li>部署 Maven 子项目(单 maven 项目更简单，我相信你们能举一反三)</li>
</ol>
<h2 id="一、docker-compose"><a href="#一、docker-compose" class="headerlink" title="一、docker-compose"></a>一、docker-compose</h2><p>编写 docker-compose，连接 nginx 与 jenkins。</p>
<blockquote>
<p>如果不是使用 Docker 做容器管理，此步可忽略。直接启动 Nginx 与 Jenkins 即可。</p>
</blockquote>
<pre><code class="sh">version: &#39;3&#39;

services:
  jenkins:
    container_name: &#39;jenkins.ci&#39;
    image: &#39;jenkins/jenkins:lts&#39;
    #ports:  不对外暴露端口，直接使用nginx容器转到8080
      #- &#39;8080:8080&#39;
      #- &#39;50000:50000&#39;
    volumes:
      - &#39;/home/docker-images/jenkins/var/jenkins_home:/var/jenkins_home&#39;
      - &#39;/home/docker-images/jenkins/html:/usr/share/jenkins/html&#39; #挂载编译打包后的存放路径
  nginx:
    container_name: &#39;nginx&#39;
    depends_on:
      - jenkins
    image: nginx:alpine
    volumes:
      - &#39;/home/luokaiii/backstage_page/html:/usr/www/luokaiii/cn/html&#39;
      - &#39;/home/docker-images/nginx/conf:/etc/nginx/conf.d&#39;
      - &#39;/home/docker-images/nginx/cert:/etc/nginx/cert&#39;
    ports:
      - 80:80 # 对外统一使用80端口
      - 443:443
    restart: always
</code></pre>
<h2 id="二、nginx-conf"><a href="#二、nginx-conf" class="headerlink" title="二、nginx.conf"></a>二、nginx.conf</h2><pre><code class="sh">upstream apisupport {
    # 自己部署的后端服务，因为是在容器访问外部服务，所以需要使用内网IP
    # 第二种方法是在 docker-compose 中将 jar 作为一个 service 连接
    server xxx.xx.xx.xxx:9000;
}
# 这里用到了 docker-compose 中的容器，如果没用docker，直接写localhost就可以了。
upstream dk-jenkins {
    server jenkins:8080;
}
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name www.luokaiii.cn;
    return    301 https://$server_name$request_uri; 
}
server {
    listen 80;
    # 我用了一个 三级域名来处理Jenkins的请求，因为 jenkins 会从根目录查找静态资源和发送请求，总是会重写url。
    server_name jenkins.luokaiii.cn;
    location / {
        proxy_pass http://dk-jenkins/;
    }
}
# 如果没有 https 证书，直接将 ssl 以下的部分写在 80 里就行了
server { 
    listen 443 ssl; 
    server_name www.luokaiii.cn luokaiii.cn; 

    # ssl config
    ssl on;   #设置为on启用SSL功能。
    ssl_certificate cert/2292046_www.luokaiii.cn.pem;
    ssl_certificate_key cert/2292046_www.luokaiii.cn.key;
    ssl_session_timeout 5m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on; 

    # 压缩请求，这样服务返回会快一些，毕竟国内带宽很贵的
    gzip on;
    gzip_min_length 1k;
    gzip_comp_level 9;
    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
    gzip_vary on;
    gzip_disable &quot;MSIE [1-6]\.&quot;;

    # 静态资源代理，在Jenkins部署前端项目的文章中，就是把前端静态文件部署在该目录下，直接由nginx代理即可。
    root /usr/www/luokaiii/cn/html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    # 请求转发，将 /api/ 请求转发到 jar 服务上
    location /api/ {
        proxy_pass http://apisupport/;
        proxy_redirect  http://api/support/ https://www.luokaiii.cn/api/;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host  $host;
        proxy_set_header X-Real_IP  $remote_addr;
        proxy_set_header REMOTE-HOST $remote_addr;
        proxy_set_header X-Nginx-Proxy true;
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
        proxy_read_timeout 600;
        proxy_buffer_size 256k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
        proxy_temp_file_write_size 256k;
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504 http_404;
        proxy_max_temp_file_size 128m;
        proxy_http_version 1.1;
        #proxy_cache mycache;
        #proxy_cache_valid 200 302 1h;
        #proxy_cache_valid 301 1h;
        #proxy_cache_valid any 1m;
    }
}</code></pre>
<blockquote>
<p>这里使用了一个三级域名来代理 Jenkins，因为 Jenkins 总是会从根目录查找静态资源，以及发送请求。如果是 <a href="http://www.luokaiii.cn/jenkins/" target="_blank" rel="noopener">www.luokaiii.cn/jenkins/</a> 的话总是会被重写为 <a href="http://www.luokaiii.cn，所以直接用三级域名，让它从根目录找好了。" target="_blank" rel="noopener">www.luokaiii.cn，所以直接用三级域名，让它从根目录找好了。</a></p>
<p>如果有知道如何代理的大佬也可以告诉我，虚心请教，谢谢。</p>
</blockquote>
<h2 id="三、SpringBoot-项目"><a href="#三、SpringBoot-项目" class="headerlink" title="三、SpringBoot 项目"></a>三、SpringBoot 项目</h2><p>这里项目以我自己写的 Demo <a href="https://github.com/luokaiii/luokaiii.api" target="_blank" rel="noopener"><a href="https://github.com/luokaiii/luokaiii.api" target="_blank" rel="noopener">https://github.com/luokaiii/luokaiii.api</a></a> 为例，一个 Maven 多级项目，我们只部署其中的 admin-server 模块。</p>
<p>具体的项目是怎么写的就不说了，大致是：打开idea  &gt; 新建 Spring Initializr &gt; 选择maven &gt; 在 Application 中写一个 GetMapping &gt; OK</p>
<h2 id="四、进入正题"><a href="#四、进入正题" class="headerlink" title="四、进入正题"></a>四、进入正题</h2><p>打开Jenkins，并新建一个 Freestyle（即自由风格的软件项目）。</p>
<p>除了上一节 <a href="https://www.jianshu.com/p/e34674f34242" target="_blank" rel="noopener">Jenkins部署前端React项目</a> 中所需的依赖之外，这里还需要 <code>Maven Integration</code> 依赖。</p>
<h3 id="1-项目描述（随便写）"><a href="#1-项目描述（随便写）" class="headerlink" title="1. 项目描述（随便写）"></a>1. 项目描述（随便写）</h3><p><img src="https://i.loli.net/2019/08/06/3AErybK1UaCoXgv.png" alt="UTOOLS1565082361195.png"></p>
<h3 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2. 源码管理"></a>2. 源码管理</h3><p>刚创建的用户，Credentials 可能为空，创建一个 username+password(一般是你的git账号密码)就行，(如果觉得不安全，可以使用SSH的方式，自己百度)。</p>
<p><img src="C:%5CUsers%5Cuser%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1565082401841.png" alt="1565082401841"></p>
<blockquote>
<p>这里分支使用的是 <code>develop</code>，原因：在 Git Flow 中，develop 为开发分支(这里用来做测试服务器的分支)，master 为主分支(即正式服务器的分支)。</p>
<p>因人而异，你想用 master 也行，反正不是我的项目，哈哈。</p>
</blockquote>
<h3 id="3-构建（jenkins与测试服务器在同一台服务器上）"><a href="#3-构建（jenkins与测试服务器在同一台服务器上）" class="headerlink" title="3. 构建（jenkins与测试服务器在同一台服务器上）"></a>3. 构建（jenkins与测试服务器在同一台服务器上）</h3><p>如果你的 jenkins 部署在测试服务器上，那么直接将打包后的 jar 文件移动至指定目录即可。</p>
<ol>
<li>调用顶层 Maven 目标，使用maven 打包项目<ol>
<li>因为打包的是子项目，所以使用 -pl 参数指定需要打包的子项目，通过 -am 参数开启依赖项目的构建</li>
<li>-Dmaven.test.skip=true 跳过测试(一般对单元测试有严格要求的都不应该跳过此步骤)</li>
</ol>
</li>
<li>Send files or execute commands over SSH<ol>
<li>通过 SSH发送文件或执行命令 </li>
<li>因为jenkins与测试在一起，所以我们只需要执行mv命令即可</li>
<li>下面的jenkins与服务器分开(比如正式服部署，总不能还浪费带宽吧)，就需要发送将jar发送到服务器然后运行</li>
</ol>
</li>
</ol>
<p><img src="https://i.loli.net/2019/08/06/nSx9yFpINqrEAlo.png" alt="UTOOLS1565082655139.png"></p>
<blockquote>
</blockquote>
<h3 id="4-构建（jenkins与测试服务器分离）"><a href="#4-构建（jenkins与测试服务器分离）" class="headerlink" title="4. 构建（jenkins与测试服务器分离）"></a>4. 构建（jenkins与测试服务器分离）</h3><p>跟步骤3没什么太大的区别，只是将 jar 发送到服务器。</p>
<p><img src="https://i.loli.net/2019/08/06/he49txiGX5PQgzT.png" alt="UTOOLS1565083626352.png"></p>
<blockquote>
<p>最后一句 <code>pm2 restart api-support</code> 类似于 <code>nohup java -jar xxx.jar</code> 我是使用 pm2 管理的jar包，有兴趣的可以自己查一下(或者推荐一下其他的进程管理工具也行)。</p>
</blockquote>
<h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><p>随便提交一次代码，点击立即构建。经过漫长的等待(maven首次更新、向服务器发送jar包)，打印出以下日志。</p>
<p><img src="https://i.loli.net/2019/08/06/GaonXC9TAKLF1wr.png" alt="构建成功"></p>
<p>完成，收工！</p>
<blockquote>
<p>最后提一下我为什么会写两种构建方式，因为我先用步骤 四4 中的构建时，1M (上行才100多k，T_T)小水管发一个 jar 包快二十分钟了。所以想到同服务器还是直接拷贝的比较好。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/05/读书笔记/《Jenkins》实战笔记/jenkins/">《Jenkins》实战</a><span class="article-meta"><i class="fa fa-thumb-tack article-meta__icon sticky"></i><span class="sticky">置顶</span><span class="article-meta__separator" style="margin-right: 0.3rem">|</span></span><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/读书笔记/Jenkins部署/">Jenkins部署</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Jenkins部署/">Jenkins部署</a></span><div class="content"><ul>
<li><a href="/2019/08/05/读书笔记/《Jenkins》实战笔记/jenkins-react/index.html">Jenkins 部署 reactjs</a></li>
<li><a href="/2019/08/05/读书笔记/《Jenkins》实战笔记/jenkins-springboot/index.html">Jenkins 部署 Java</a></li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>