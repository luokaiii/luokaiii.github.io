<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="描述"><meta name="keywords" content="1,2,3"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>凯 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">243</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">19</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">凯</div><div id="site-sub-title">凯</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《SpringSecurity》/23.自定义权限验证/">《Spring Security》自定义权限验证@PreAuthorize</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spring-Security/">Spring Security</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a></span><div class="content"><h1 id="自定义安全表达式"><a href="#自定义安全表达式" class="headerlink" title="自定义安全表达式"></a>自定义安全表达式</h1><pre><code class="java">/**
 * Base root object for use in Spring Security expression evaluations.
 *
 * @author Luke Taylor
 * @since 3.0
 */
public abstract class SecurityExpressionRoot implements SecurityExpressionOperations</code></pre>
<p>SecurityExpressionRoot 是所有安全表达式的基类，我们需要做的就是：</p>
<ol>
<li>继承 SecurityExpressionRoot，自定义 MethodSecurity 表达式</li>
<li>继承 DefaultMethodSecurityExpressionHandler，自定义方法级别的安全校验处理器</li>
<li>继承 GlobalMethodSecurityConfiguration，添加自定义的表达式处理器</li>
</ol>
<h2 id="一、MethodSecurityConfig"><a href="#一、MethodSecurityConfig" class="headerlink" title="一、MethodSecurityConfig"></a>一、MethodSecurityConfig</h2><p>开启方法级别的安全校验，注入登录用户时加载 UserDetails 的DB服务对象，通过 createExpressionHandler 注入自定义的表达式处理器。</p>
<pre><code class="java">/**
 * 配置 MethodSecurity 表达式
 */
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {

    private final LoginDetailService loginDetailService;

    public MethodSecurityConfig(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        return new ResourceMethodSecurityExpressionHandler(loginDetailService);
    }
}</code></pre>
<h2 id="二、ResourceMethodSecurityExpressionHandler"><a href="#二、ResourceMethodSecurityExpressionHandler" class="headerlink" title="二、ResourceMethodSecurityExpressionHandler"></a>二、ResourceMethodSecurityExpressionHandler</h2><p>接收 UserDetailsService，并创建一个处理表达式的操作类</p>
<pre><code class="java">/**
 * 自定义方法级别的安全校验处理器
 */
public class ResourceMethodSecurityExpressionHandler extends DefaultMethodSecurityExpressionHandler {

    private final LoginDetailService loginDetailService;

    private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();

    public ResourceMethodSecurityExpressionHandler(LoginDetailService loginDetailService) {
        this.loginDetailService = loginDetailService;
    }

    @Override
    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {
        final ResourceMethodSecurityExpressionRoot root = new ResourceMethodSecurityExpressionRoot(authentication, loginDetailService);
        root.setPermissionEvaluator(getPermissionEvaluator());
        root.setTrustResolver(this.trustResolver);
        root.setRoleHierarchy(getRoleHierarchy());
        return root;
    }
}</code></pre>
<h2 id="三、ResourceMethodSecurityExpressionRoot"><a href="#三、ResourceMethodSecurityExpressionRoot" class="headerlink" title="三、ResourceMethodSecurityExpressionRoot"></a>三、ResourceMethodSecurityExpressionRoot</h2><p>仿照 hasAuthority，编写一个自己的实现</p>
<pre><code class="java">/**
 * 自定义 MethodSecurity 表达式
 */
@Slf4j
public class ResourceMethodSecurityExpressionRoot extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {

    private LoginDetailService loginDetailService;

    private Object filterObject;
    private Object returnObject;
    private Object target;

    public ResourceMethodSecurityExpressionRoot(Authentication authentication, LoginDetailService loginDetailService) {
        super(authentication);
        this.loginDetailService = loginDetailService;
    }

    /**
     * 自定义接口，是否允许对该id的访问
     */
    public boolean canReadCourse(String courseId) {
        log.debug(&quot;method params courseId&quot;, courseId);
        log.debug(&quot;current principal {}&quot;, getPrincipal());
        return true;
    }

    public final boolean hasGlobalAuthority(String authority) {
        return hasAnyGlobalAuthority(authority);
    }

    public final boolean hasAnyGlobalAuthority(String... authorities) {
        return hasAnyGlobalAuthorityName(null, authorities);
    }

    private boolean hasAnyGlobalAuthorityName(String prefix, String... roles) {
        final String username = ((UserDetails) getPrincipal()).getUsername();
        final UserDetails details = loginDetailService.loadUserByUsername(username);

        if (details.getAuthorities() != null) {
            final Set&lt;String&gt; roleSet = details.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority).collect(Collectors.toSet());

            for (String role : roles) {
                String defaultedRole = getRoleWithDefaultPrefix(prefix, role);
                if (roleSet.contains(defaultedRole)) {
                    return true;
                }
            }
        }

        return false;
    }

    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) {
        if (role == null) {
            return role;
        }
        if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) {
            return role;
        }
        if (role.startsWith(defaultRolePrefix)) {
            return role;
        }
        return defaultRolePrefix + role;
    }

    @Override
    public void setFilterObject(Object filterObject) {
        this.filterObject = filterObject;
    }

    @Override
    public Object getFilterObject() {
        return filterObject;
    }

    @Override
    public void setReturnObject(Object returnObject) {
        this.returnObject = returnObject;
    }

    @Override
    public Object getReturnObject() {
        return returnObject;
    }

    @Override
    public Object getThis() {
        return target;
    }

    public void setTarget(Object target) {
        this.target = target;
    }

    @Override
    public void setRoleHierarchy(RoleHierarchy roleHierarchy) {
        super.setRoleHierarchy(roleHierarchy);
    }
}</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/2_XML配置/">《MyBatis》读书笔记 - MyBatis 中的 XML 详细配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="二、MyBatis-中的-XML-详细配置"><a href="#二、MyBatis-中的-XML-详细配置" class="headerlink" title="二、MyBatis 中的 XML 详细配置"></a>二、MyBatis 中的 XML 详细配置</h1><p>MyBatis 的配置文件包含了深深影响 MyBatis 行为的设置和属性信息。配置文档的顶层结构如下：</p>
<ul>
<li>configuration(配置)<ul>
<li>properties(属性)</li>
<li>settings(设置)</li>
<li>typealiases(类型别名)</li>
<li>typeHandlers(类型处理器)</li>
<li>objectFactory(对象工厂)</li>
<li>plugins(插件)</li>
<li>environments(环境配置)<ul>
<li>environment(环境变量)<ul>
<li>transactionManager(事务管理器)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider(数据库厂商标识)</li>
<li>mappers(映射器)</li>
</ul>
</li>
</ul>
<h2 id="一、属性（Properties）"><a href="#一、属性（Properties）" class="headerlink" title="一、属性（Properties）"></a>一、属性（Properties）</h2><p>这些属性都是可外部配置且可动态替换的，如：</p>
<pre><code class="xml">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;12345678&quot;/&gt;
&lt;/properties&gt;</code></pre>
<p>可替换的动态配置属性值：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>如果属性不值在一个地方进行了配置，那么 MyBatis 的加载顺序如下：</p>
<ul>
<li>首先读取在 properties 元素体内属性值</li>
<li>根据 properties 元素中的 resource 属性读取类路径下的文件或 url 读取属性文件，并覆盖已读取的同名属性</li>
<li>最后读取作为方法参数传递的属性，并覆盖已读取的同名属性</li>
</ul>
<p>因此，方法参数传递的属性优先级最高，其次是 resource/url 指定的配置文件，最后是 properties 中指定的属性。</p>
<p>在 MyBatis 3.4.2 开始，可以为占位符制定一个默认值，如：</p>
<pre><code class="xml">&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!-- 如果属性 username 没有配置，那么默认值为 ut_user --&gt;
     &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt;
&lt;/dataSource&gt;</code></pre>
<p>这个特性默认是关闭的，应该添加一个指定的属性来开启这个特性，如：</p>
<pre><code class="xml">&lt;properties resoure=&quot;org/mybatis/example/config.properties&quot;&gt;
    &lt;!-- 启用默认值特性 --&gt;
    &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot; /&gt;
&lt;/properties&gt;</code></pre>
<h2 id="二、设置（settings）"><a href="#二、设置（settings）" class="headerlink" title="二、设置（settings）"></a>二、设置（settings）</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为，下标描述了设置中各项的意图、默认值等。</p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>全局地开关映射器中已经配置的缓存</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关，所有关联对象都会延迟加载，可以通过 fetchType 来覆盖该项</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>开启时，任何方法的调用都会加载该对象的所有属性。否则，每个对象会按需加载</td>
</tr>
<tr>
<td>multipleResultSetsEnabled</td>
<td>是否允许单一语句返回多结果集（需要驱动支持）</td>
</tr>
<tr>
<td>useColumnLabel</td>
<td>使用列标签代替列名</td>
</tr>
<tr>
<td>useGeneratedKeys</td>
<td>允许 JDBC 支持自动生成主键</td>
</tr>
<tr>
<td>autoMappingBehavior</td>
<td>指定MyBatis应如何自动映射列到字段或属性。NONE：取消自动映射；PARTIAL：自动映射没有定义嵌套结果集的；FULL：自动映射任意复杂的结果集</td>
</tr>
<tr>
<td>autoMappingUnknownColumnBehavior</td>
<td>指定发现自动映射目标未知列（或未知属性）的行为。NONE：不做任何反应；WARNING：输出提醒日志；FAILING：映射失败（抛出SqlSessionException）</td>
</tr>
<tr>
<td>defaultExecutorType</td>
<td>配置默认的执行器。SIMPLE：普通执行器；REUSE 执行器会重用预处理语句；BATCH：执行器将重用语句并执行批量更新</td>
</tr>
<tr>
<td>defaultStatementTimeout</td>
<td>设置超时时间，决定驱动等待数据库响应的描述</td>
</tr>
<tr>
<td>defaultFetchSize</td>
<td>为驱动的结果集获取数量（fetchSize）设置一个提示值</td>
</tr>
<tr>
<td>defaultResultSetType</td>
<td>指定每个语句的省略滚动策略</td>
</tr>
<tr>
<td>safeRowBoundsEnabled</td>
<td>允许在嵌套语句中使用分页（RowBounds）。false为允许</td>
</tr>
<tr>
<td>safeResultHandlerEnabled</td>
<td>允许在嵌套局域中使用分页(RowHandler)。false为允许</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启自动驼峰命名规则映射，即从列名 A_COLUMN 到 Java 属性名 aColumn 的类似映射</td>
</tr>
<tr>
<td>localCacheScope</td>
<td>MyBatis 利用本地缓存机制防止循环引用和加速重复嵌套查询。SESSION：默认，会缓存一个会话中执行的所有查询；STATEMENT：仅用在局域执行上，对相同的 SqlSession 的不同调用不会共享数据</td>
</tr>
<tr>
<td>jdbcTypeForNull</td>
<td>当没有参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型</td>
</tr>
<tr>
<td>lazyLoadTriggerMethods</td>
<td>指定哪个对象的方法触发一次延迟加载</td>
</tr>
<tr>
<td>defaultScriptingLanguage</td>
<td>指定动态 SQL 生成的默认语言</td>
</tr>
<tr>
<td>defaultEnumTypeHandler</td>
<td>指定 Enum 使用的默认 TypeHandler(3.4.5)</td>
</tr>
<tr>
<td>callSettersOnNulls</td>
<td>指定当结果集中值为 null 时，是否调用映射对象的 setter 方法。</td>
</tr>
<tr>
<td>returnInstanceForEmptyRow</td>
<td>当返回的列都是空时，MyBatis默认返回 null。开启后，会返回一个空实例</td>
</tr>
<tr>
<td>logPrefix</td>
<td>指定 MyBatis 增加到日志名称的前缀</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找</td>
</tr>
<tr>
<td>proxyFactory</td>
<td>指定 MyBatis 创建具有延迟加载能力的对象所用到的代理工具</td>
</tr>
<tr>
<td>vfsImpl</td>
<td>指定 VFS 的实现</td>
</tr>
<tr>
<td>useActualParamName</td>
<td>允许使用方法签名中的名称作为语句参数名称。需要java 8编译，并加上 -parameters 选项</td>
</tr>
<tr>
<td>configurationFactory</td>
<td>指定一个提供 Configuration 实例的类。这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。这个类必须包含一个签名为 static Configuration getConfiguration() 的方法(3.2.3)</td>
</tr>
</tbody></table>
<p>一个完整的 settings 元素示例如下：</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;multipleResultSetEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
    &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;EXAMPLE&quot;/&gt;
    &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;
    &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;
    &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;
    &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;
    &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;
    &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;
&lt;/settings&gt;</code></pre>
<h2 id="三、类型别名（typeAliases）"><a href="#三、类型别名（typeAliases）" class="headerlink" title="三、类型别名（typeAliases）"></a>三、类型别名（typeAliases）</h2><p>类型别名用来减少类完全限定名的冗余，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;typeAlias alias=&quot;Author&quot; type=&quot;cn.luokaiii.adminservice.model.Author&quot;/&gt;
    &lt;typeAlias alias=&quot;Teacher&quot; type=&quot;cn.luokaiii.adminservice.model.Teacher&quot;/&gt;
&lt;/typeAliases&gt;</code></pre>
<p>也可以指定一个报名，MyBatis 会在包名下搜索 Java Bean，在没有注解的情况下，会使用Bean 的首字母小写的非限定类名来作为它的别名，如：</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;package name=&quot;domain.blog&quot; /&gt;
&lt;/typeAliases&gt;</code></pre>
<p>或者使用注解的方式，如：</p>
<pre><code class="java">@Alias(&quot;author&quot;)
public class Author {
    ......
}</code></pre>
<p>Java 类型内建的相应类型别名（不区分大小写）：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashMap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="四、类型处理器（typeHandlers）"><a href="#四、类型处理器（typeHandlers）" class="headerlink" title="四、类型处理器（typeHandlers）"></a>四、类型处理器（typeHandlers）</h2><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换为 Java 类型。</p>
<table>
<thead>
<tr>
<th>类型处理器</th>
<th>Java 类型</th>
<th>JDBC 类型</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanTypeHandler</td>
<td>Java.lang.Boolean,boolean</td>
<td>BOOLEAN</td>
</tr>
<tr>
<td>ByteTypeHandler</td>
<td>java.lang.Byte,byte</td>
<td>NUMERIC,BYTE</td>
</tr>
<tr>
<td>ShortTypeHandler</td>
<td>java.lang.Short,short</td>
<td>NUMERIC,SMALLINT</td>
</tr>
<tr>
<td>IntegerTypeHandler</td>
<td>java.lang.Integer,int</td>
<td>NUMERIC,INTEGER</td>
</tr>
<tr>
<td>FloatTypeHandler</td>
<td>java.lang.Float,float</td>
<td>NUMERIC,FLOAT</td>
</tr>
<tr>
<td>DoubleTypeHandler</td>
<td>java.lang.Double,double</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>BigDecimalTypeHandler</td>
<td>java.math.BigDecimal</td>
<td>NUMERIC,DECIMAL</td>
</tr>
<tr>
<td>StringTypeHandler</td>
<td>java.lang.String</td>
<td>CHAR,VARCHAR</td>
</tr>
<tr>
<td>ClobReaderTypeHandler</td>
<td>java.io.Reader</td>
<td>-</td>
</tr>
<tr>
<td>ClobTypeHandler</td>
<td>java.lang.String</td>
<td>CLOB,LONGVARCHAR</td>
</tr>
<tr>
<td>NStringTypeHandler</td>
<td>java.lang.String</td>
<td>NVARCHAR,NCHAR</td>
</tr>
<tr>
<td>NClobTypeHandler</td>
<td>java.lang.String</td>
<td>NCLOB</td>
</tr>
<tr>
<td>BlobInputStreamTypeHandler</td>
<td>java.io.InputStream</td>
<td>-</td>
</tr>
<tr>
<td>ByteArrayTypeHandler</td>
<td>byte[]</td>
<td></td>
</tr>
<tr>
<td>DateTypeHandler</td>
<td>byte[]</td>
<td>L</td>
</tr>
<tr>
<td>DateOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>TimeOnlyTypeHandler</td>
<td>java.util.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimestampTypeHandler</td>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>SqlDateTypeHandler</td>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimeTypeHandler</td>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>ObjectTypeHandler</td>
<td>Any</td>
<td>OTHER</td>
</tr>
<tr>
<td>EnumTypeHandler</td>
<td>Enum</td>
<td>VARCHAR</td>
</tr>
<tr>
<td>EnumOrdinalTypeHandler</td>
<td>Enum</td>
<td>NUMERIC,DOUBLE</td>
</tr>
<tr>
<td>SqlxmlTypeHandler</td>
<td>java.lang.String</td>
<td>SQLXML</td>
</tr>
<tr>
<td>InstantTypeHandler</td>
<td>java.time.Instant</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTimeTypeHandler</td>
<td>java.time.LocalDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>LocalDateTypeHandler</td>
<td>java.time.LocalDate</td>
<td>DATE</td>
</tr>
<tr>
<td>OffsetTimeTypeHandler</td>
<td>java.time.OffsetDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>ZonedDateTimeTypeHandler</td>
<td>java.time.ZonedDateTime</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>YearTypeHandler</td>
<td>java.time.Year</td>
<td>INTEGER</td>
</tr>
<tr>
<td>MonthTypeHandler</td>
<td>java.time.Month</td>
<td>INTEGER</td>
</tr>
<tr>
<td>YearMonthTypeHandler</td>
<td>java.time.YearMonth</td>
<td>VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>JapaneseDateTypeHandler</td>
<td>java.time.chrono.JapaneseDate</td>
<td>DATE</td>
</tr>
</tbody></table>
<p>可以通过重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 或集成 org.apache.ibatis.type.BaseTypeHandler，然后将它映射到一个 JDBC 类型：</p>
<pre><code class="java">@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {
  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}</code></pre>
<pre><code class="xml">&lt;typeHandlers&gt;
    &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;</code></pre>
<h2 id="五、对象工厂（objectFactory）"><a href="#五、对象工厂（objectFactory）" class="headerlink" title="五、对象工厂（objectFactory）"></a>五、对象工厂（objectFactory）</h2><p>MyBatis 每次创建结果对象的新实例时，都会使用一个对象工厂（ObjectFactory）实例来完成。要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。</p>
<p>如何想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现，如：</p>
<pre><code class="java">public class ExampleObjectFactory extends DefaultObjectFactory {
    // 包含两个创建方法
    // 处理默认构造方法
    public Object create(Class type){
        return super.create(type);
    }

    // 处理带参数的构造方法
    public Object create(Class type,List&lt;Class&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs){
        return super.create(type,constructorArgTypes,constructorArgs);
    }

    // 可以被用来配置 ObjectFactory，在初始化ObjectFactory后，objectFactory元素体中定义的属性会被传递给 setProperties 方法
    public void setProperties(Properties properties){
        super.setProperties(properties);
    }

    public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type){
        return Collection.class.isAssignableFrom(type);
    }
}</code></pre>
<pre><code class="xml">&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;</code></pre>
<h2 id="六、插件（Plugins）"><a href="#六、插件（Plugins）" class="headerlink" title="六、插件（Plugins）"></a>六、插件（Plugins）</h2><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包含：</p>
<ul>
<li>Executor（update、query、flushStatements、commit、rollback、getTransaction、close、isClosed）</li>
<li>ParameterHandler（getParameterObject、setParameters）</li>
<li>ResultSetHandler（handleResultSets、handleOutputParameters）</li>
<li>StatementHandler（prepare、parameterize、batch、update、query）</li>
</ul>
<p>这些都是很底层的类和方法，如果在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis的核心模块，因此在使用插件的时候要当心。</p>
<h2 id="七、环境配置（environments）"><a href="#七、环境配置（environments）" class="headerlink" title="七、环境配置（environments）"></a>七、环境配置（environments）</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中。</p>
<p>如开发、测试、生产环境需要不同的配置；或者现在相同 Schema 的多个库中使用相同的 SQL 映射。</p>
<blockquote>
<p>尽管可以配置多个环境，但是每个 SqlSessionFactory 实例只能选择一种环境</p>
</blockquote>
<p>环境元素定义了如何配置环境：</p>
<pre><code class="xml">&lt;enviroments default=&quot;development&quot;&gt;
    &lt;enviroment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;
            &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
        &lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;...&quot;/&gt;
            ...
        &lt;/dataSource&gt;
    &lt;/enviroment&gt;
&lt;/enviroments&gt;</code></pre>
<p>这里的关键：</p>
<ul>
<li>默认使用的环境ID（default=”development”）</li>
<li>每个元素都有一个环境ID</li>
<li>事务管理器的配置</li>
<li>数据源的配置</li>
</ul>
<h3 id="1-事务管理器（transactionManager）"><a href="#1-事务管理器（transactionManager）" class="headerlink" title="1. 事务管理器（transactionManager）"></a>1. 事务管理器（transactionManager）</h3><p>MyBatis 有两种类型的事务管理器：</p>
<ol>
<li>JDBC - 直接使用 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务作用域</li>
<li>MANAGED - 让容器来管理事务的整个生命周期。默认会关闭连接，然而一些容器不希望这样，因此需要将 closeConnection 设置为 false 来阻止它默认的关闭行为</li>
</ol>
<blockquote>
<p>如果使用 Spring+MyBatis，则没必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</blockquote>
<h3 id="2-数据源（DataSource）"><a href="#2-数据源（DataSource）" class="headerlink" title="2. 数据源（DataSource）"></a>2. 数据源（DataSource）</h3><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<p>MyBatis 提供了三种内建的数据源类型。</p>
<h4 id="UNPOOLED"><a href="#UNPOOLED" class="headerlink" title="UNPOOLED"></a>UNPOOLED</h4><p>每次被请求时打开和关闭连接</p>
<h4 id="POOLED"><a href="#POOLED" class="headerlink" title="POOLED"></a>POOLED</h4><p>使用连接池的方式，避免创建新实例时所需的初始化和认证时间</p>
<h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p>为了能在如 EJB 或应用服务器这类容器汇总使用，容器可以集成或在外部配置数据源</p>
<h4 id="第三方数据源"><a href="#第三方数据源" class="headerlink" title="第三方数据源"></a>第三方数据源</h4><p>可以通过实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 来使用第三方数据源。</p>
<h2 id="八、数据库厂商标识（databaseIdProvider）"><a href="#八、数据库厂商标识（databaseIdProvider）" class="headerlink" title="八、数据库厂商标识（databaseIdProvider）"></a>八、数据库厂商标识（databaseIdProvider）</h2><h2 id="九、映射器（mappers）"><a href="#九、映射器（mappers）" class="headerlink" title="九、映射器（mappers）"></a>九、映射器（mappers）</h2><p>mappers 定义 SQL 映射语句，告诉 MyBatis 去哪里找这些语句。如：</p>
<pre><code class="xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用完全限定资源定位符 URL --&gt;
&lt;mappers&gt;
    &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
&lt;/mappers&gt;</code></pre>
<pre><code class="xml">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
    &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/05/读书笔记/《Mybatis》/1_入门/">《MyBatis》读书笔记 - 入门</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/读书笔记/">读书笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/MyBatis/">MyBatis</a></span><div class="content"><h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>构建项目，需要引入如下的 dependency 到 pom.xml 中：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;or.mybatis&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
  &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="2-从XML配置SQLSessionFactory"><a href="#2-从XML配置SQLSessionFactory" class="headerlink" title="2. 从XML配置SQLSessionFactory"></a>2. 从XML配置SQLSessionFactory</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。</p>
<p>以下 XML 配置文件中包含了对 MyBatis 系统的核心设置，如获取数据源(DataSource)和决定事务作用于和控制方式的事务管理器(TransactionManager)：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot; /&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre>
<p>使用类路径下的资源文件进行配置，构建 SqlSessionFactory 实例：</p>
<pre><code class="java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre>
<h2 id="3-从SqlSessionFactory-获取-SqlSession"><a href="#3-从SqlSessionFactory-获取-SqlSession" class="headerlink" title="3. 从SqlSessionFactory 获取 SqlSession"></a>3. 从SqlSessionFactory 获取 SqlSession</h2><p>SqlSession 中完全包含了面向数据库执行 SQL 命令所需的所有方法，例如：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    Blog blog = (Blog)session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;,101);
}</code></pre>
<p>或者使用一种更简单的方式：</p>
<pre><code class="java">try(SqlSession session = sqlSessionFactory.openSession()){
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Blog blog = mapper.selectBlog(101);
}</code></pre>
<h3 id="提示：命名空间（Namespaces）"><a href="#提示：命名空间（Namespaces）" class="headerlink" title="提示：命名空间（Namespaces）"></a>提示：命名空间（Namespaces）</h3><p>命名空间的作用有两个，一个是利用更长的完全限定名来将不同的语句隔离开来，同时也实现了接口绑定。</p>
<p>命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ol>
<li>完全限定名，将被直接用于查找和使用</li>
<li>短名称，如果全局唯一也可作为单独的应用。如果不唯一，那么使用时就会出现错误，此时就需要使用完全限定名</li>
</ol>
<h2 id="4-基于-XML-映射语句的示例"><a href="#4-基于-XML-映射语句的示例" class="headerlink" title="4. 基于 XML 映射语句的示例"></a>4. 基于 XML 映射语句的示例</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>
<h2 id="5-基于注解的示例"><a href="#5-基于注解的示例" class="headerlink" title="5. 基于注解的示例"></a>5. 基于注解的示例</h2><pre><code class="java">public interface BlogMapper {
    @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;)
    Blog selectBlog(int id);
}</code></pre>
<h2 id="6-作用域（Scope）和生命周期"><a href="#6-作用域（Scope）和生命周期" class="headerlink" title="6. 作用域（Scope）和生命周期"></a>6. 作用域（Scope）和生命周期</h2><p><code>依赖注入框架</code>可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要了。</p>
<p>因此该实例的最佳作用域为<code>方法作用域</code>，可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory，但是使用后最好不要让其一直存在，以保证 XML 资源可以被释放。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>一旦创建就应该在应用的运行期间一直存在，尽量不要重复创建该实例。</p>
<p>因此该实例的最佳作用域为<code>应用作用域</code>。可以使用单例模式或静态单例模式来做到。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该由自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此不能被共享。</p>
<p>因此该实例的最佳作用于为<code>请求或方法作用域</code>。绝不能将 SqlSession 的实例引用放在静态域中，甚至一个类的实例变量也不行，也不能将引用放在任何类型的托管作用域中（如Servlet 的HttpSession）。</p>
<p>如果您使用的是 Web 框架，那么应该考虑将 SqlSession 放在和 Http 请求对象相似的作用域中。即每次 Http 请求，都打开一个 SqlSession，返回响应后就关闭它。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是映射Sql语句的接口，该接口的实例是从 SqlSession 中获得的。</p>
<p>因此该实例的最佳作用于<code>与 SqlSession 的作用域保持一致</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/SpringCloud/分布式并发问题/">分布式环境中的并发问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/分布式/">分布式</a></span><div class="content"><p>分布式环境中，处理并发问题没发通过操作系统和 JVM 提供的工具来解决，因为 LOCK 命令、总线锁、缓存所、monitor 对象、锁、等并发工具都无法影响到其他服务器的线程。</p>
<p>那么在分布式环境中，可以使用一下策略和方式处理：</p>
<ol>
<li>避免并发<ol>
<li>通过某些策略和业务来避免并发，如合理分配时间调度，避开共享资源的存取冲突等。</li>
<li>可以通过hash算法的方式，使一个对象的数据计算和访问都交给同一个线程来完成</li>
</ol>
</li>
<li>时间戳<ol>
<li>每次系统A发送给系统B的时候都带上一个时间戳，B在拿到通知后，比较时间戳</li>
<li>这样只需要调用方保证时间戳的时序有效性即可</li>
</ol>
</li>
<li>串行化<ol>
<li>串行化可能产生并发的问题，通过牺牲性能和扩展性，来满足对数据一致性的要求。</li>
<li>比如分布式消息系统，没法保证消息的有序性，但是可以通过将分布式消息系统改为单一消息系统，就可以保证消息的有序性了。</li>
<li>如果接收方无法保证处理的有序性，那么可以使用一个队列将调用信息缓存起来，再串行地处理这些调用</li>
</ol>
</li>
<li>数据库<ol>
<li>在分布式环境中，数据库是个服务器的共享点，可以通过数据库的高可靠一致性机制来满足需求。</li>
<li>比如通过唯一性约束，来解决并发过程中重复数据的生产或重复任务的执行</li>
<li>某些更新操作也尽量使用SQL来完成，在程序中计算后再更新，可能会出现脏复写的问题，但是通过一条SQL来完成计算和更新，就能通过数据库的锁机制来保证更新的一致性</li>
</ol>
</li>
<li>行锁<ol>
<li>有些事务较为复杂时，无法通过一条SQL解决问题，并且可能存在并发问题，此时可以考虑使用行锁来解决问题</li>
<li>如 select … for update ，在查询后将该行数据锁定，直到 commit。但是这么做会导致其他涉及该行的所有操作都会被挂起</li>
<li>通过在表中增加一个标志锁的字段，每次操作之前通过update，来模拟竞争锁的操作，操作完成后再update复位该标志，表示锁归还。（这种操作很类似Redis分布式锁、MongoDB分布式锁，说白了就是自己定义一个模拟竞争锁的场景）</li>
</ol>
</li>
<li>统一触发途径<ol>
<li>如果一个数据会被多个业务同时涉及到，就会有并发问题产生的隐患。因此可以通过前期架构和业务涉及，尽量统一触发途径，减少并发的可能，也有利于对并发问题的分析和判断。</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/cutesource/article/details/5791350" target="_blank" rel="noopener">文章总结自 : https://blog.csdn.net/cutesource/article/details/5791350</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/09/04/Interview/20190903上海基诺联生物/">20190903上海基诺联生物科技有限公司</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/面试题/">面试题</a></span><div class="content"><ol>
<li>公司最新的业务，为什么有两个云平台<ol>
<li>一个教学平台，一个比赛平台，然后说一些业务</li>
</ol>
</li>
<li>搭建过权限架构，使用的是什么框架？是如何实现Spring Security的？Spring Security 是如何实现权限验证的？<ol>
<li>Spring Security，引入依赖，配置一个Configure，开启Security Method验证，自定义实现UserDetailsService，扩展UserDetails，加载Authority，默认存入Session中，可以将Session扩展到Redis、MongoDB等地方保存，即可加载出用户信息到 SecurityContext 中。</li>
<li>通过@PreAuthorize 可以验证之前加载的Authority权限数组。</li>
</ol>
</li>
<li>如果用户保存在Session中，那么权限变更后如何重新加载权限？<ol>
<li>现在的解决方案：SpringSecurity 是通过 @PreAuthorize 的 SecurityExpressionOperations 实现类，如 hasAuthority()、hasAnyAuthority(…) 来验证的，那么我们只要实现一个 hasCustomAuthority() 改为从Redis、MongoDB等地直接获取用户存储的权限即可。通过使用自定义的接口，扩展Security的验证</li>
<li>不用担心性能问题，因为我们的Session存储在Redis、MongoDB中，那么程序每次获取Session时，都会从Redis、MongoDB中取。那么自定义接口所修改的，只是从spring_sessions表改为了自己的用户权限表。</li>
</ol>
</li>
<li>JDK版本是多少？1.8 有哪些新特性？说说你对流式编程的理解？如何从List<user>中取出所有的username？<ol>
<li>jdk8主要增加了对集合类的流式操作，也就是所说的lambda表达式，使我们对集合的遍历等操作更加便利。</li>
<li>userList.stream().map(val -&gt; val.getUsername()).collect(toList())</li>
</ol>
</user></li>
<li>用过索引没？谈谈索引的作用？谈谈复合索引<ol>
<li>索引的主要作用是优化查询，在数据库的某一个字段上创建了索引后，对该表的某一个字段查询时，将不再遍历整张表，而是遍历索引树。但是索引不应该创建的过多，如果索引树过于庞大的话，对性能也有很大的影响</li>
<li>复合索引，就是以一个数组的方式保存多个字段，然后在查询时，依次按照索引的位置从左到右查询</li>
<li>以下来自于“高性能MySQL”中对索引设计的规范：<ol>
<li>禁止给每个列都建立索引，单表索引建议不超过5个</li>
<li>索引定义在SELECT、UPDATE、DELETE语句的WHERE从句中的列</li>
<li>索引定义在OrderBy、GroupBy、Distinct中的字段</li>
<li>多表Join的字段</li>
<li>复合索引，区分度高的放左侧、字段长度小的放左侧、使用最频繁的放左侧</li>
<li>避免冗余索引和重复索引，MySQL在执行优化时需要选择具体的索引，降低了索引使用效率</li>
<li>避免使用外键约束，建议在业务端保证数据的参照完整性，因为外键会影响父表和子表的写操作而降低性能</li>
<li>不建议使用外键约束，但一定要在表与表的关联键上建立索引</li>
</ol>
</li>
</ol>
</li>
<li>说一说数据库事务是什么？回滚是在什么情况下发生的(提示)？<ol>
<li>我只说了数据隔离，然后被提示之后才想到一致性</li>
<li>数据隔离，比如数据插入时阻塞其他插入操作，数据查询时阻塞其他插入操作等，这些由数据库的事务隔离级别来决定（还好没问我数据库的隔离级别，越简单的越不容易记），避免脏读</li>
<li>回滚是为了保存数据的一致性，在同一个事务中执行的SQL会保持一致性，只能全部执行成功。如果某一个SQL出现了异常，会导致整个事务回滚到执行之前的状态。</li>
</ol>
</li>
<li>什么是分布式锁？怎么实现分布式锁？<ol>
<li>分布式锁就是为了解决集群环境时，JVM和锁无法工作的问题。因为多台服务器的线程彼此之间没办法互相加锁，因此需要一些第三方中间件来帮助我们来模拟加锁行为。</li>
<li>比如Redis、Zookeeper、MongoDB等中间件，我们定义一个标识位，在我们进行一些对数据有要求的插入等操作时，为了避免其他线程同时执行，我们需要在执行之前尝试获取这个标志位，如果获取成功了，那么执行，获取失败则等待、轮询、或者抛出异常。</li>
</ol>
</li>
<li>Redis是如何实现分布式锁的？<ol>
<li>Redis有一个setNX的语句，是一个CAS操作，会先比较某一个值是否存在，如果不存在才设置，存在则不设置。</li>
<li>setNX比直接查询再赋值，要原子化，将查询并修改合为一个操作。查询再赋值的操作再怎么快也是有时间间隔的。</li>
</ol>
</li>
<li>Redis有哪些数据结构？(对Redis不太熟悉，带过了)<ol>
<li>string、hash、list、set、sorted set（后续查的）</li>
</ol>
</li>
<li>公司是如何使用Docker的？Docker是如何创建镜像的？<ol>
<li>（白话）公司将Nginx、后台的Java Jar、前端编译后的包，都挂载到docker上，并使用容器的方式启动和运行。使用Docker能够保证每次容器运行时的环境都是隔离的。使用方法：在项目根目录下写一个Dockerfile，然后在文件中指定所需的jdk版本、redis等其他中间件服务。（后面这段没回答上来）然后通过 docker build 的方法生成镜像，然后将镜像通过 docker push 的方式推送到远程云上。push之后我就不知道了。这些是从公司的jenkins上学到的。</li>
</ol>
</li>
<li>你有什么要了解的吗？<ol>
<li>打脸行为：</li>
<li>问：技术栈听贴合的，那么公司用的什么ORM框架呢？答：Mybatis，你用的是JPA？</li>
<li>就这吧，嘟嘟嘟……</li>
</ol>
</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>