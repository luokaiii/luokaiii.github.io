<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《Java并发编程的艺术》第四章 Java 并发编程基础"><meta name="keywords" content="hide,Java并发编程的艺术"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>《Java并发编程的艺术》第四章 Java 并发编程基础 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-Java-并发编程基础"><span class="toc-number">1.</span> <span class="toc-text">第四章 Java 并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-线程"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-什么是线程"><span class="toc-number">1.1.1.</span> <span class="toc-text">4.1.1 什么是线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-多线程"><span class="toc-number">1.1.2.</span> <span class="toc-text">4.1.2 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-线程优先级"><span class="toc-number">1.1.3.</span> <span class="toc-text">4.1.3 线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-线程的状态"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.1.4 线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-Daemon-线程"><span class="toc-number">1.1.5.</span> <span class="toc-text">4.1.5 Daemon 线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-启动、终止线程"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 启动、终止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-中断"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.2.1 中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-安全地终止线程"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2.2 安全地终止线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-线程间通信"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-volatile-和-synchronized-关键字"><span class="toc-number">1.3.1.</span> <span class="toc-text">4.3.1 volatile 和 synchronized 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-等待-通知机制"><span class="toc-number">1.3.2.</span> <span class="toc-text">4.3.2 等待/通知机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-Thread-join"><span class="toc-number">1.3.3.</span> <span class="toc-text">4.3.3 Thread.join()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-线程应用实例"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 线程应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-等待超时模式"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.4.1 等待超时模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-简单的数据库连接池"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.4.2 简单的数据库连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-基于数据库连接池的Web服务器"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.4.3 基于数据库连接池的Web服务器</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">描述</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives/index.html"><span class="pull-left">文章</span><span class="pull-right">207</span></a><a class="author-info-articles__tags article-meta" href="/tags/index.html"><span class="pull-left">标签</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories/index.html"><span class="pull-left">分类</span><span class="pull-right">28</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives/index.html">归档</a><a class="site-page" href="/tags/index.html">标签</a><a class="site-page" href="/categories/index.html">分类</a><a class="site-page" href="/about/index.html">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">《Java并发编程的艺术》第四章 Java 并发编程基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/index.html">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/index.html">Java并发编程的艺术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第四章-Java-并发编程基础"><a href="#第四章-Java-并发编程基础" class="headerlink" title="第四章 Java 并发编程基础"></a>第四章 Java 并发编程基础</h1><h2 id="4-1-线程"><a href="#4-1-线程" class="headerlink" title="4.1 线程"></a>4.1 线程</h2><h3 id="4-1-1-什么是线程"><a href="#4-1-1-什么是线程" class="headerlink" title="4.1.1 什么是线程"></a>4.1.1 什么是线程</h3><p>操作系统在运行一个程序时，会创建一个进程，如一个Java程序就对应一个 Java 进程。</p>
<p>一个进程可以创建多个线程，每个线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>处理器在这些线程间高速切换，让使用者感觉是在同时运行。</p>
<h3 id="4-1-2-多线程"><a href="#4-1-2-多线程" class="headerlink" title="4.1.2 多线程"></a>4.1.2 多线程</h3><p>使用多线程的优势如下：</p>
<ol>
<li>更好的利用多处理器核心</li>
<li>程序运行更快，以获得更快的响应时间</li>
<li>更好的编程模型</li>
</ol>
<h3 id="4-1-3-线程优先级"><a href="#4-1-3-线程优先级" class="headerlink" title="4.1.3 线程优先级"></a>4.1.3 线程优先级</h3><p>线程优先级决定了线程能够使用处理器的资源多少，默认优先级为5，优先级范围为 1~10.</p>
<p>针对频繁阻塞的(休眠或者 IO操作)线程需要设置较高优先级，而偏重计算(需要较多CPU时间或者偏运算)的线程则设置较低的优先级，确保处理器不会被独占。</p>
<h3 id="4-1-4-线程的状态"><a href="#4-1-4-线程的状态" class="headerlink" title="4.1.4 线程的状态"></a>4.1.4 线程的状态</h3><p>Java 线程的六种生命周期：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，线程被构建，但是还未调用 start() 方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，即操作系统中的就绪和运行两种状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，表示可以在指定时间自动返回的等待状态</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示线程已执行完毕</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="Java线程状态变迁"></p>
<h3 id="4-1-5-Daemon-线程"><a href="#4-1-5-Daemon-线程" class="headerlink" title="4.1.5 Daemon 线程"></a>4.1.5 Daemon 线程</h3><p>当Java 虚拟机中不存在 Daemon 线程时，虚拟机将会退出。</p>
<p>通过 Thread.setDaemon(true) 将线程设置为 Daemon 线程。</p>
<h2 id="4-2-启动、终止线程"><a href="#4-2-启动、终止线程" class="headerlink" title="4.2 启动、终止线程"></a>4.2 启动、终止线程</h2><p>通过调用线程的 start() 方法启动，随着 run() 方法的执行完毕，线程随之终止。</p>
<h3 id="4-2-1-中断"><a href="#4-2-1-中断" class="headerlink" title="4.2.1 中断"></a>4.2.1 中断</h3><p>中断表示一个运行中的线程是否被其他线程进行了中断操作。</p>
<p>中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。</p>
<h3 id="4-2-2-安全地终止线程"><a href="#4-2-2-安全地终止线程" class="headerlink" title="4.2.2 安全地终止线程"></a>4.2.2 安全地终止线程</h3><p>通过标识位或者中断操作的方式，能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p>
<p>通过标识位和中断来停止线程：</p>
<pre><code class="java">public class TestRunner implements Runnable {
    private long i;
    private volatile boolean on = true;
    @Override
    public void run() {
        while(on &amp;&amp; !Thread.currentThread().isInterrupted()){
            i++;
        }
    }

    public void cancel(){
        on = false;
    }
}</code></pre>
<h2 id="4-3-线程间通信"><a href="#4-3-线程间通信" class="headerlink" title="4.3 线程间通信"></a>4.3 线程间通信</h2><p>Java 支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝，所以程序在执行过程中，各线程看到的变量并不一定是最新的。</p>
<h3 id="4-3-1-volatile-和-synchronized-关键字"><a href="#4-3-1-volatile-和-synchronized-关键字" class="headerlink" title="4.3.1 volatile 和 synchronized 关键字"></a>4.3.1 volatile 和 synchronized 关键字</h3><p>volatile 关键字：用来修饰的变量，可以使访问该变量的线程均从共享内存中获取。且对共享变量的修改，必须同步刷新回共享内存中。但是过多地使用volatile 会降低程序执行的效率。</p>
<p>synchronized 关键字：用来修饰方法或者同步块，确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。</p>
<h3 id="4-3-2-等待-通知机制"><a href="#4-3-2-等待-通知机制" class="headerlink" title="4.3.2 等待/通知机制"></a>4.3.2 等待/通知机制</h3><p>等待/ 通知机制，是指一个线程A 调用了对象O 的wait() 方法而进入等待状态。线程B 调用了对象O 的notify()或notifyAll() 方法，线程A 收到通知后从对象O的wait() 方法返回，进而执行后续操作。</p>
<p>等待通知的经典范式：</p>
<p>等待方(消费方):</p>
<ol>
<li>获取对象的锁</li>
<li>如果条件不满足，则调用对象的wait()方法，被通知后仍要检查条件</li>
<li>条件满足则执行对应的逻辑</li>
</ol>
<pre><code class="java">synchronized(对象){
    while(条件不满足){
        对象.wait();
    }
    处理逻辑
}</code></pre>
<p>通知方(生产者)：</p>
<ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<pre><code class="java">synchronized(对象){
    改变条件
    对象.notifyAll();
}</code></pre>
<h3 id="4-3-3-Thread-join"><a href="#4-3-3-Thread-join" class="headerlink" title="4.3.3 Thread.join()"></a>4.3.3 Thread.join()</h3><p>如果一个线程 A 执行了 thread.join() 语句，其含义是：当前线程 A 等待 thread 线程终止之后才从 thread.join() 返回。</p>
<h2 id="4-4-线程应用实例"><a href="#4-4-线程应用实例" class="headerlink" title="4.4 线程应用实例"></a>4.4 线程应用实例</h2><h3 id="4-4-1-等待超时模式"><a href="#4-4-1-等待超时模式" class="headerlink" title="4.4.1 等待超时模式"></a>4.4.1 等待超时模式</h3><p>调用一个方法后，如果在等待时间内得到结果则立即返回，否则返回默认结果。</p>
<pre><code class="java">// 伪代码：
public synchronized Object get(long mills) throws InterruptedException {
    long future = System.currentTimeMills() + mills;
    long remaining = mills;

    while((result == null) &amp;&amp; remaining &gt; 0){
        wait(remaining);
        remaining = future - System.currentTimeMills();
    }

    return result;
}</code></pre>
<h3 id="4-4-2-简单的数据库连接池"><a href="#4-4-2-简单的数据库连接池" class="headerlink" title="4.4.2 简单的数据库连接池"></a>4.4.2 简单的数据库连接池</h3><h3 id="4-4-3-基于数据库连接池的Web服务器"><a href="#4-4-3-基于数据库连接池的Web服务器" class="headerlink" title="4.4.3 基于数据库连接池的Web服务器"></a>4.4.3 基于数据库连接池的Web服务器</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">koral</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://luokaiii.github.io/2019/06/11/读书笔记/《Java并发编程的艺术》/4.Java并发编程基础//index.html">http://luokaiii.github.io/2019/06/11/读书笔记/《Java并发编程的艺术》/4.Java并发编程基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://luokaiii.github.io">凯</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/hide/index.html">hide</a><a class="post-meta__tags" href="/tags/Java并发编程的艺术/index.html">Java并发编程的艺术</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/12/读书笔记/《Java并发编程的艺术》/3.Java内存模型/index.html"><i class="fa fa-chevron-left">  </i><span>《Java并发编程的艺术》第三章 Java 内存模型</span></a></div><div class="next-post pull-right"><a href="/2019/06/10/读书笔记/《Java并发编程的艺术》/5.Java中的锁/index.html"><span>《Java并发编程的艺术》第五章 Java中的锁</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>