<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《Java并发编程的艺术》第六章 Java 并发容器和框架"><meta name="keywords" content="hide,Java并发编程的艺术"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>《Java并发编程的艺术》第六章 Java 并发容器和框架 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-Java-并发容器和框架"><span class="toc-number">1.</span> <span class="toc-text">第六章 Java 并发容器和框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-ConcurrentHashMap"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-为什么使用-ConcurrentHashMap"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1 为什么使用 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HashMap-线程不安全"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. HashMap 线程不安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HashTable-效率低下"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. HashTable 效率低下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ConcurrentHashMap-的锁分段技术"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3. ConcurrentHashMap 的锁分段技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-ConcurrentHashMap-的结构"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2 ConcurrentHashMap 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-ConcurrentHashMap-初始化"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3 ConcurrentHashMap 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-初始化-Segments-数组"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 初始化 Segments 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-初始化-SegmentShift-和-SegmentMask"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 初始化 SegmentShift 和 SegmentMask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-初始化每个-segment"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. 初始化每个 segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-定位-Segment"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">4. 定位 Segment</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-ConcurrentHashMap-操作"><span class="toc-number">1.1.4.</span> <span class="toc-text">6.1.5 ConcurrentHashMap 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-get操作"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. get操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-put操作"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. put操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-size-操作"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3. size 操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-ConcurrentLinkedQueue"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 ConcurrentLinkedQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-ConcurrentLinkedQueue-结构"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1 ConcurrentLinkedQueue 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-入队列"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2 入队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-入队列"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 入队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-定位尾节点"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 定位尾节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-设置入队节点为尾节点"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. 设置入队节点为尾节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-出队列"><span class="toc-number">1.2.3.</span> <span class="toc-text">6.2.3 出队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-阻塞队列"><span class="toc-number">1.3.</span> <span class="toc-text">6.3 阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-什么是阻塞队列"><span class="toc-number">1.3.1.</span> <span class="toc-text">6.3.1 什么是阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-Java-阻塞队列"><span class="toc-number">1.3.2.</span> <span class="toc-text">6.3.2 Java 阻塞队列</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">罗凯的博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">270</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">48</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">《Java并发编程的艺术》第六章 Java 并发容器和框架</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/Java并发编程的艺术/">Java并发编程的艺术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第六章-Java-并发容器和框架"><a href="#第六章-Java-并发容器和框架" class="headerlink" title="第六章 Java 并发容器和框架"></a>第六章 Java 并发容器和框架</h1><h2 id="6-1-ConcurrentHashMap"><a href="#6-1-ConcurrentHashMap" class="headerlink" title="6.1 ConcurrentHashMap"></a>6.1 ConcurrentHashMap</h2><p>ConcurrentHashMap 是线程安全且高效的 HashMap。</p>
<h3 id="6-1-1-为什么使用-ConcurrentHashMap"><a href="#6-1-1-为什么使用-ConcurrentHashMap" class="headerlink" title="6.1.1 为什么使用 ConcurrentHashMap"></a>6.1.1 为什么使用 ConcurrentHashMap</h3><h4 id="1-HashMap-线程不安全"><a href="#1-HashMap-线程不安全" class="headerlink" title="1. HashMap 线程不安全"></a>1. HashMap 线程不安全</h4><p>在多线程环境下，使用 HashMap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以在并发情况下不能使用 HashMap。</p>
<p>HashMap 在并发执行 put 操作时会引起死循环，是因为多线程会导致 HashMap 的 Entry 链表形成环形数据结构，一旦形成环形数据结构，Entry 的 next 节点永不为空，就会产生死循环获取 Entry。</p>
<h4 id="2-HashTable-效率低下"><a href="#2-HashTable-效率低下" class="headerlink" title="2. HashTable 效率低下"></a>2. HashTable 效率低下</h4><p>HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 效率低下。</p>
<p>因为当一个线程访问 HashTable 的同步方法，其他线程再访问时，会进入阻塞或轮询状态。</p>
<h4 id="3-ConcurrentHashMap-的锁分段技术"><a href="#3-ConcurrentHashMap-的锁分段技术" class="headerlink" title="3. ConcurrentHashMap 的锁分段技术"></a>3. ConcurrentHashMap 的锁分段技术</h4><p>HashTable 在线程竞争激烈时的效率低下原因是所有访问 HashTable 的线程都必须竞争同一把锁。</p>
<p>而ConcurrentHashMap 的锁分段技术，将容器中的数据分段存储起来，为每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。</p>
<h3 id="6-1-2-ConcurrentHashMap-的结构"><a href="#6-1-2-ConcurrentHashMap-的结构" class="headerlink" title="6.1.2 ConcurrentHashMap 的结构"></a>6.1.2 ConcurrentHashMap 的结构</h3><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p>
<p>Segment 是一种可重入锁(ReentrantLock)，扮演锁的角色。Segment与HashMap 类似，是一种数组和链表结构。</p>
<p>HashEntry 则用于存储键值对数据。每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须先获得对应的 Segment 锁。</p>
<h3 id="6-1-3-ConcurrentHashMap-初始化"><a href="#6-1-3-ConcurrentHashMap-初始化" class="headerlink" title="6.1.3 ConcurrentHashMap 初始化"></a>6.1.3 ConcurrentHashMap 初始化</h3><p>通过 initalCapacity、loadFactor 和 concurrencyLevel 等几个参数来初始化 segment 数组、段偏移量 segmentShift、段掩码 segmentMask 和每个 segment 里的 HashEntry 数组，以此来初始化 ConcurrentHashMap。</p>
<pre><code class="java">    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}), table
     * density ({@code loadFactor}), and number of concurrently
     * updating threads ({@code concurrencyLevel}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation may use this value as
     * a sizing hint.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive
     */
    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();
        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }</code></pre>
<h4 id="1-初始化-Segments-数组"><a href="#1-初始化-Segments-数组" class="headerlink" title="1. 初始化 Segments 数组"></a>1. 初始化 Segments 数组</h4><pre><code class="java">    if(concurrencyLevel &gt; MAX_SEGMENTs)
        concurrencyLevel = MAX_SEGMENTS;
    int sshift = 0;
    int ssize = 1;
    while(ssize &lt; concurrencyLevel){ // 必须保证 segments 数组长度是 2的N次方，如 concurrencyLevel = 14，ssize = 16
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    segmentShift = 32 - sshift;
    segmentMask = ssize - 1;
    this.segments = Segment.newArray(ssize);</code></pre>
<p>Segments 数组的程度是由 ssize 决定的，而ssize 是通过 concurrencyLevel 计算得出的 ，原因是必须保证 ssize 是 2的N次方。</p>
<h4 id="2-初始化-SegmentShift-和-SegmentMask"><a href="#2-初始化-SegmentShift-和-SegmentMask" class="headerlink" title="2. 初始化 SegmentShift 和 SegmentMask"></a>2. 初始化 SegmentShift 和 SegmentMask</h4><p>段偏移量 SegmentShift：segmentShift = 32 - sshift;</p>
<p>段掩码：segmentMask = ssize - 1; 是散列运算的掩码，等于 ssize - 1，因为 ssize 为2的N次方，因此 segmentMask 掩码的二进制各个位都是 1.</p>
<h4 id="3-初始化每个-segment"><a href="#3-初始化每个-segment" class="headerlink" title="3. 初始化每个 segment"></a>3. 初始化每个 segment</h4><p>initialCapacity 是 ConcurrentHashMap 的初始化容量，loadFactor 是每个 segment 的负载因子。</p>
<h4 id="4-定位-Segment"><a href="#4-定位-Segment" class="headerlink" title="4. 定位 Segment"></a>4. 定位 Segment</h4><p>ConcurrentHashMap 在插入和获取元素时，会通过散列算法定位 Segment，并会对元素的 hashCode 进行一次再散列。</p>
<p>在散列的目的是减少散列冲突，使元素能均匀地分布在不同的 Segment 上，从而提高容器的存取效率。</p>
<p>如果不进行再散列的话，无论散列值的高位是多少，只要低位相同，都会被存储到一个Segment 上。</p>
<h3 id="6-1-5-ConcurrentHashMap-操作"><a href="#6-1-5-ConcurrentHashMap-操作" class="headerlink" title="6.1.5 ConcurrentHashMap 操作"></a>6.1.5 ConcurrentHashMap 操作</h3><h4 id="1-get操作"><a href="#1-get操作" class="headerlink" title="1. get操作"></a>1. get操作</h4><p>先进行再散列，然后使用散列值进行散列运算，定位 Segment，再通过散列算法定位到元素。</p>
<pre><code class="java">public V get(Object key){
    int hash = hash(key.hash);
    return segmentFor(hash).get(key,hash);
}</code></pre>
<p>整个 get 操作不需要加锁，除非读到的值是空才会加锁重读。原因是 ConcurrentHashMap 将需要共享的变量都定义为 volatile 类型。</p>
<h4 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2. put操作"></a>2. put操作</h4><p>put操作会对共享变量进行写操作，所以必须加锁。</p>
<p>put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。在插入之前，先判断是否需要对 Segment 里的 HashEntry 进行扩容，然后定位添加元素的位置，将其放入 HashEntry 数组中。</p>
<h4 id="3-size-操作"><a href="#3-size-操作" class="headerlink" title="3. size 操作"></a>3. size 操作</h4><p>统计 ConcurrentHashMap 里元素的大小，就必须统计所有 Segment 里元素的大小后求和。 Segment 里的count 是一个 volatile 变量，但是多线程场景下，某个 segment 的 count 发生改变后，也可能会使结果不准确。</p>
<p>因此 size 操作的具体过程为：先尝试 2 次通过不锁住 Segment 的方式来统计各个 Segment 大小，如果统计过程中，容器的 count 发生了变化（容器 count 会在 put、remove、clean 时会使 modCount + 1），再采用加锁的方式（将所有 Segment 的 put、remove、clean 方法全部锁住）来统计 Segment 的大小。</p>
<h2 id="6-2-ConcurrentLinkedQueue"><a href="#6-2-ConcurrentLinkedQueue" class="headerlink" title="6.2 ConcurrentLinkedQueue"></a>6.2 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用 FIFO 的规则对节点进行排序。</p>
<h3 id="6-2-1-ConcurrentLinkedQueue-结构"><a href="#6-2-1-ConcurrentLinkedQueue-结构" class="headerlink" title="6.2.1 ConcurrentLinkedQueue 结构"></a>6.2.1 ConcurrentLinkedQueue 结构</h3><p>ConcurrentLinkedQueue 由 head 节点和 tail 节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个 next 关联，组成一张链表结果的队列。</p>
<h3 id="6-2-2-入队列"><a href="#6-2-2-入队列" class="headerlink" title="6.2.2 入队列"></a>6.2.2 入队列</h3><pre><code class="java">    /**
     * 插入元素到当前队列的尾部，且因为队列是无界的，结果总是true
     */
    public boolean offer(E e) {
        checkNotNull(e);
        // 1. 将插入元素构建为 node
        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);

        for (Node&lt;E&gt; t = tail, p = t;;) {
            Node&lt;E&gt; q = p.next;
            if (q == null) {
                if (p.casNext(null, newNode)) {
                    if (p != t)
                        casTail(t, newNode);
                    return true;
                }
            }
            else if (p == q)
                p = (t != (t = tail)) ? t : head;
            else
                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
        }
    }</code></pre>
<h4 id="1-入队列"><a href="#1-入队列" class="headerlink" title="1. 入队列"></a>1. 入队列</h4><p>入队列就是将入队节点添加到队列的尾部。在入队时，先将入队节点设置成当前队列尾节点的下一个节点，然后更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点，如果 tail 节点的 next 节点为空，则将入队节点设置为 tail 的 next 节点。</p>
<p>在设置入队节点为 tail 的 next 节点时，会使用  CAS 来保证多线程下的安全性。</p>
<h4 id="2-定位尾节点"><a href="#2-定位尾节点" class="headerlink" title="2. 定位尾节点"></a>2. 定位尾节点</h4><pre><code class="java">    /**
     * Returns the successor of p, or the head node if p.next has been
     * linked to self, which will only be true if traversing with a
     * stale pointer that is now off the list.
     */
    final Node&lt;E&gt; succ(Node&lt;E&gt; p) {
        Node&lt;E&gt; next = p.next;
        return (p == next) ? head : next;
    }</code></pre>
<h4 id="3-设置入队节点为尾节点"><a href="#3-设置入队节点为尾节点" class="headerlink" title="3. 设置入队节点为尾节点"></a>3. 设置入队节点为尾节点</h4><p>p.casNext(null,n) 将入队节点设置为当前队列尾节点的 next 节点，如果 p 为null，表示 p 是当前队列的尾节点，不为空则表示其他线程更新了尾节点，需要重新获取当前队列的尾节点。</p>
<h3 id="6-2-3-出队列"><a href="#6-2-3-出队列" class="headerlink" title="6.2.3 出队列"></a>6.2.3 出队列</h3><pre><code class="java">public E poll() {
    restartFromHead:
    for (;;) {
        // 1. 获取头节点
        for (Node&lt;E&gt; h = head, p = h, q;;) {
            E item = p.item;

            // 2. 头节点不为空，则用 CAS 将头节点的引用置null；为空则表示头节点被另一线程的出队操作取出
            if (item != null &amp;&amp; p.casItem(item, null)) {
                // 3. CAS 操作成功，直接返回头节点
                if (p != h) 
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            // 4. 如果取出失败，则继续进行循环取值
            else if (p == q)
                continue restartFromHead;
            else
                p = q;
        }
    }
}</code></pre>
<h2 id="6-3-阻塞队列"><a href="#6-3-阻塞队列" class="headerlink" title="6.3 阻塞队列"></a>6.3 阻塞队列</h2><h3 id="6-3-1-什么是阻塞队列"><a href="#6-3-1-什么是阻塞队列" class="headerlink" title="6.3.1 什么是阻塞队列"></a>6.3.1 什么是阻塞队列</h3><p>阻塞队列是一个支持阻塞插入和阻塞移除的方法。</p>
<p>插入和移除操作的4中处理方式：</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove(e)</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>/</td>
<td>/</td>
</tr>
</tbody></table>
<h3 id="6-3-2-Java-阻塞队列"><a href="#6-3-2-Java-阻塞队列" class="headerlink" title="6.3.2 Java 阻塞队列"></a>6.3.2 Java 阻塞队列</h3><p>JDK 中提供了 7个阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列<ul>
<li>队列按照FOFO原则对元素进行排序</li>
<li>默认不保证线程访问队列时的公平性</li>
</ul>
</li>
<li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列<ul>
<li>FIFO原则对元素进行排序</li>
<li>队列默认和最大长度为 Integer.MAX_VALUE</li>
</ul>
</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列<ul>
<li>支持优先级、无界阻塞</li>
<li>元素采用自然顺序升序排列，也可以自定义 compareTo 来排序</li>
<li>不能保证同优先级元素的顺序</li>
</ul>
</li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列<ul>
<li>支持延迟获取元素</li>
<li>队列元素必须实现 Delayed 接口</li>
<li>队列使用 PriorityQueue 实现</li>
<li>创建元素时可指定多久后才能获取当前元素</li>
<li>DelayQueue常用于：<ul>
<li>缓存系统的设计：用 DelayQueue 保存缓存元素的有效期</li>
<li>定时任务调度：使用 DelayQueue 保存执行的任务和执行时间</li>
</ul>
</li>
</ul>
</li>
<li>SynchronousQueue：不存储元素的阻塞队列<ul>
<li>不存储元素，每个put操作必须等待一个 take 操作</li>
<li>支持公平访问队列，默认是非公平的</li>
<li>队列本身不存储任何元素，适合传递性场景</li>
<li>吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue</li>
</ul>
</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列<ul>
<li>提供 transfer 方法，立即将元素 transfer 给消费者，如果无消费者等待则将元素放在队列的 tail 节点，等待消费者消费</li>
<li>提供 tryTransfer 方法，试探生产者传入的元素能够直接传给消费者，如果无消费者等待接收，则返回false。</li>
</ul>
</li>
<li>LinkedBlockingQueue：由链表结构组成的双向阻塞队列<ul>
<li>双向队列，使多线程同时入队时，减少了一般竞争，因为多了一个入队口</li>
<li>增加了 addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast等方法</li>
<li>add 等同于 addLast，remove 等同于 removeFirst</li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">koral</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://luokaiii.github.io/2019/06/09/读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架/">http://luokaiii.github.io/2019/06/09/读书笔记/《Java并发编程的艺术》/6.Java并发容器和框架/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://luokaiii.github.io">凯</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/hide/">hide</a><a class="post-meta__tags" href="/tags/Java并发编程的艺术/">Java并发编程的艺术</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/10/读书笔记/《Java并发编程的艺术》/5.Java中的锁/"><i class="fa fa-chevron-left">  </i><span>《Java并发编程的艺术》第五章 Java中的锁</span></a></div><div class="next-post pull-right"><a href="/2019/06/08/读书笔记/《Java并发编程的艺术》/7.Java中的13个原子操作类/"><span>《Java并发编程的艺术》第七章 Java中的13个原子操作类</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>