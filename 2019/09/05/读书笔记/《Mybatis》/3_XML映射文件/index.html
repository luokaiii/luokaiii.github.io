<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《MyBatis》读书笔记 - MyBatis XML 映射文件"><meta name="keywords" content="hide,MyBatis"><meta name="author" content="koral"><meta name="copyright" content="koral"><title>《MyBatis》读书笔记 - MyBatis XML 映射文件 | 凯</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#三、MyBatis-XML-映射文件"><span class="toc-number">1.</span> <span class="toc-text">三、MyBatis XML 映射文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、select"><span class="toc-number">1.1.</span> <span class="toc-text">一、select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、insert、update、delete"><span class="toc-number">1.2.</span> <span class="toc-text">二、insert、update、delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、sql"><span class="toc-number">1.3.</span> <span class="toc-text">三、sql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、参数"><span class="toc-number">1.4.</span> <span class="toc-text">四、参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串替换"><span class="toc-number">1.4.1.</span> <span class="toc-text">字符串替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、结果映射"><span class="toc-number">1.5.</span> <span class="toc-text">五、结果映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高级结果映射"><span class="toc-number">1.5.1.</span> <span class="toc-text">高级结果映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果映射（resultMap）"><span class="toc-number">1.5.2.</span> <span class="toc-text">结果映射（resultMap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id-amp-result"><span class="toc-number">1.5.3.</span> <span class="toc-text">id &amp; result</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法"><span class="toc-number">1.5.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联"><span class="toc-number">1.5.5.</span> <span class="toc-text">关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联的嵌套Select查询"><span class="toc-number">1.5.6.</span> <span class="toc-text">关联的嵌套Select查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">1.5.7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#集合的嵌套-Select-查询"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">集合的嵌套 Select 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合的嵌套结果映射"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">集合的嵌套结果映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合的多结果集（ResultSet）"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">集合的多结果集（ResultSet）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#鉴别器（discriminator）"><span class="toc-number">1.5.8.</span> <span class="toc-text">鉴别器（discriminator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动映射"><span class="toc-number">1.5.9.</span> <span class="toc-text">自动映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、缓存"><span class="toc-number">1.6.</span> <span class="toc-text">六、缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用自定义缓存"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">使用自定义缓存</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">koral</div><div class="author-info__description text-center">罗凯的博客主页</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">291</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">48</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/index.html">凯</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">《MyBatis》读书笔记 - MyBatis XML 映射文件</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/">读书笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/读书笔记/MyBatis/">MyBatis</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="三、MyBatis-XML-映射文件"><a href="#三、MyBatis-XML-映射文件" class="headerlink" title="三、MyBatis XML 映射文件"></a>三、MyBatis XML 映射文件</h1><p>MyBatis 通过映射 XML 文件的方式，减少了 JDBC 的样板代码，十分的简单。</p>
<p>SQL 映射文件只有少数几个顶级约束：</p>
<ul>
<li>cache - 对给定命名空间的缓存配置</li>
<li>cache-ref - 对其他命名空间缓存配置的引用</li>
<li>resultMap - 描述如何从数据库结果集中加载对象</li>
<li><del>parameterMap - 废弃，参数映射</del></li>
<li>sql - 可重用语句块</li>
<li>insert - 插入语句</li>
<li>update - 更新语句</li>
<li>delete - 删除语句</li>
<li>select - 查询语句</li>
</ul>
<h2 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h2><p>查询语句，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
    SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</code></pre>
<p>select 元素允许你配置很多属性来配置每条语句的作用细节</p>
<pre><code class="xml">&lt;select
          id=&quot;selectPerson&quot;
        parameterType=&quot;int&quot;
        parameterMap=&quot;deprecated&quot;
        result=&quot;hashMap&quot;
        resultMap=&quot;personResultMap&quot;
        flushCache=&quot;false&quot;
        useCache=&quot;true&quot;
        timeout=&quot;10&quot;
        fetchSize=&quot;256&quot;
        statementType=&quot;PREPARED&quot;
        resultSetType=&quot;FORWARD_ONLY&quot;
        &gt;

&lt;/select&gt;</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>命名空间中的唯一标识符，用来引用该语句</td>
</tr>
<tr>
<td>parameterType</td>
<td>传入的参数的完全限定名，可选。MyBatis会通过类型处理器推断具体传入的参数类型</td>
</tr>
<tr>
<td><del>parameterMap</del></td>
<td><del>引用外部 parametermap 的方法</del></td>
</tr>
<tr>
<td>resultType</td>
<td>返回的期望乐行的类的完全限定名或别名。如果结果为集合，则应该设置为集合包含的类型，而不是集合本身。</td>
</tr>
<tr>
<td>resultMap</td>
<td>外部 resultMap 的命名引用。与resultType不能同时使用</td>
</tr>
<tr>
<td>flushCache</td>
<td>默认为false。为true时，只要语句被调用，都会导致本地缓存和二级缓存被清空</td>
</tr>
<tr>
<td>useCache</td>
<td>默认对select元素为true。将本条语句的结果使用二级缓存缓存起来</td>
</tr>
<tr>
<td>timeout</td>
<td>驱动程序等待数据库返回请求结果的秒数，而后抛出异常</td>
</tr>
<tr>
<td>fetchSize</td>
<td>尝试让驱动程序每次批量返回的结果行数和设置的值相等</td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT、PREPARED(默认)、CALLABLE中的一个</td>
</tr>
<tr>
<td>resultSetType</td>
<td>FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE、DEFAULT中的一个</td>
</tr>
<tr>
<td>databaseId</td>
<td>数据库厂商标识</td>
</tr>
<tr>
<td>resultOrdered</td>
<td>仅针对嵌套select，如果为true，则假设包含了嵌套结果集或是分组，这样返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。使得在获取嵌套结果集时不至于导致内存不够用</td>
</tr>
<tr>
<td>resultSets</td>
<td>针对多结果集情况。将列出语句执行后返回的结果集并给每个结果集一个名称</td>
</tr>
</tbody></table>
<h2 id="二、insert、update、delete"><a href="#二、insert、update、delete" class="headerlink" title="二、insert、update、delete"></a>二、insert、update、delete</h2><p>与 select 参数相似，以一个示例来说明：</p>
<pre><code class="xml">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
   insert into  Author(username,password,email) values 
   &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
       (#{item.username},#{item.password},#{item.email})
   &lt;/foreach&gt;
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
    update Author set
     username=#{username},
     password=#{password},
     email=#{email}
    where id=#{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
    delete from Author where id=#{id}
&lt;/delete&gt;</code></pre>
<h2 id="三、sql"><a href="#三、sql" class="headerlink" title="三、sql"></a>三、sql</h2><p>该元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以在加载的时候被静态地设置参数。在不同的包含语句中可以设置不同的值到参数占位符上，如：</p>
<pre><code class="xml">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password&lt;/sql&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
    select
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
     &lt;includ refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/includ&gt;
    from some_table t1
    cross join some_table t2
&lt;/select&gt;</code></pre>
<blockquote>
<p>cross join 表示笛卡尔积，t1+t2的所有情况</p>
</blockquote>
<p>属性值也可以被用在 include 元素的 refid 属性里或 include 元素的内部语句中，如：</p>
<pre><code class="xml">&lt;sql id=&quot;sometable&quot;&gt;
    ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclud&quot;&gt;
      from
     &lt;includ refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
    select
     field1,field2,field3
    &lt;includ refid=&quot;someinclud&quot;&gt;
     &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
     &lt;property name=&quot;includ_target&quot; value=&quot;sometable&quot;/&gt;
    &lt;/includ&gt;
&lt;/select&gt;</code></pre>
<h2 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h2><pre><code class="xml">&lt;insert id=&quot;selectUser&quot; parameterType=&quot;User&quot;&gt;
    insert into users (id,username,password)
    values (#{id},#{username},#{password})
&lt;/insert&gt;</code></pre>
<p>上面的语句中，User 类型的参数对象传递到了语句中，id、username、password 属性会被查找，然后将它们的值传入预处理语句的参数中。</p>
<p>参数也可以指定一个特殊的数据类型：</p>
<blockquote>
<p>#{property,javaType=int,jdbcType=NUMERIC}</p>
</blockquote>
<p>也可以指定一个特殊的类型处理器类：</p>
<blockquote>
<p>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</p>
</blockquote>
<p>需要保留小数点的数值类型：</p>
<blockquote>
<p>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</p>
</blockquote>
<p>尽管该选项功能强大，但大多数情况下只需要简单地指定属性名，MyBatis 会自己推断类型，顶多<code>需要为可能为空的列指定 jdbcType</code>。</p>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>默认情况下，使用 <code>#{}</code> 格式的语法会导致 MyBatis 创建 PreparedStatement 参数占位符并安全地设置参数(就像？一样)。不过有时想直接在 SQL 中插入一个不转义的字符串，如：</p>
<blockquote>
<p>order by ${columnName}</p>
</blockquote>
<p>这样，MyBatis 不会修改或转义字符串。</p>
<p>有时，替换字符串会非常有用，如：</p>
<pre><code class="java">@Select(&quot;select * from user where id=#{id}&quot;)
User findById(@Param(&quot;id&quot;) long id);

@Select(&quot;select * from user where name=#{name}&quot;)
User findByName(@Param(&quot;name&quot;) String name);

@Select(&quot;select * from user where email=#{email}&quot;)
User findByEmail(@Param(&quot;email&quot;) long email);</code></pre>
<p>可以只写一个方法：</p>
<pre><code class="java">@Select(&quot;select * from user where ${column}=#{email}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;email&quot;) long email);</code></pre>
<p>使用的时候，可以如下调用：</p>
<pre><code class="java">User u1 = userMapper.findByColumn(&quot;id&quot;,1L);
User u2 = userMapper.findByColumn(&quot;name&quot;,&quot;zhangsan&quot;);
User u3 = userMapper.findByColumn(&quot;email&quot;,&quot;xx@qq.com&quot;);</code></pre>
<h2 id="五、结果映射"><a href="#五、结果映射" class="headerlink" title="五、结果映射"></a>五、结果映射</h2><p>resultMap 可以将返回结果映射到JavaBean或POJO上。如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>也可以使用类型别名，来代替完全限定名：</p>
<pre><code class="xml">&lt;typeAlias type=&quot;cn.luokaiii.model.User&quot; alias=&quot;User&quot;/&gt;

&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>如果列名与属性名没有精确匹配，可以在 SELECT 语句中对列使用别名来匹配标签，如：</p>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultType=&quot;cn.luokaiii.model.User&quot;&gt;
    select 
     id        as &quot;id&quot;,
     username  as &quot;userName&quot;
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<p>或者使用外部的 <code>resultMap</code> 来映射：</p>
<pre><code class="xml">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<pre><code class="xml">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
    select id,username
    from tb_user
    where id=#{id}
&lt;/select&gt;</code></pre>
<h3 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h3><pre><code class="xml">&lt;!-- 非常复杂的语句 --&gt;
&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt;
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;!-- 非常复杂的结果映射 --&gt;
&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt;
  &lt;constructor&gt;
    &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;
  &lt;/constructor&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
    &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt;
  &lt;/association&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt;
    &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt;
      &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
    &lt;/discriminator&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="结果映射（resultMap）"><a href="#结果映射（resultMap）" class="headerlink" title="结果映射（resultMap）"></a>结果映射（resultMap）</h3><ul>
<li>constructor - 用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg - ID参数，标记出ID，可以帮助提高整体性能</li>
<li>arg - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id - 一个ID结果</li>
<li>result - 注入到字段或 JavaBean 属性的普通结果</li>
<li>association - 一个复杂类型的关联；许多结果将包装成这种类型<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>collection - 一个复杂类型的集合<ul>
<li>嵌套结果映射 - 集合本身可以是一个 resultMap 元素，或者从别处引用一个</li>
</ul>
</li>
<li>discriminator - 使用结果值来决定使用哪个 resultMap<ul>
<li>case - 基于某些值的结果映射<ul>
<li>嵌套结果映射 - case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="id-amp-result"><a href="#id-amp-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h3><p>id 和 result 元素都将一个列的值映射到一个简单数据类型的属性或字段。</p>
<pre><code class="xml">&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;</code></pre>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>有时，需要使用不可变类来接收，即在构造方法中注入允许在初始化时设置的值，而不暴露出公有方法。</p>
<pre><code class="java">public class User {
    // ...property
    public User(Integer id, String userName, int age){
        // ...set
    }

    // private setter and getter
}</code></pre>
<pre><code class="xml">&lt;constructor&gt;
    &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot;/&gt;
    &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;userName&quot;/&gt;
    &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot;/&gt;
&lt;/constructor&gt;</code></pre>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联（association）元素处理“有一个”类型的关系。</p>
<pre><code class="xml">&lt;association property=&quot;author&quot; cloumn=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/association&gt;</code></pre>
<p>MyBatis 有两种方式加载关联：</p>
<ul>
<li>嵌套 Select 查询：通过执行另一个 SQL 映射语句来加载期望的复杂类型</li>
<li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集</li>
</ul>
<h3 id="关联的嵌套Select查询"><a href="#关联的嵌套Select查询" class="headerlink" title="关联的嵌套Select查询"></a>关联的嵌套Select查询</h3><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
    select * from Author where id=#{id}
&lt;/select&gt;</code></pre>
<p>selectBlog 用来加载博客，selectAuthor 用来加载作者，而 blogResult 结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。</p>
<p>这种方式虽然简单，但是<code>在大型数据集或大型数据表上表现不佳</code>。这个问题被称为“N+1查询问题”：</p>
<ul>
<li>执行了一个单独的 SQL 语句来获取结果的一个列表（就是+1）</li>
<li>对列表返回的每条记录，执行一个 select 查询语句来加载详细信息（就是N）</li>
</ul>
<p>虽然 MyBatis 能够对这样的查询进行延迟加载，但是如果你在加载完记录表后，立即进行了遍历。此时就会触发所有的延迟加载查询，性能会变得很糟糕。</p>
<blockquote>
<p>解决方法：使用联合查询来避免N+1问题</p>
</blockquote>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合元素和关联元素几乎是一样的</p>
<pre><code class="xml">&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;</code></pre>
<h4 id="集合的嵌套-Select-查询"><a href="#集合的嵌套-Select-查询" class="headerlink" title="集合的嵌套 Select 查询"></a>集合的嵌套 Select 查询</h4><pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
    &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    select * from blog where id=#{id}
&lt;/select&gt;

&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
    select * from post where blog_id=#{id}
&lt;/select&gt;</code></pre>
<blockquote>
<p><code>javaType=&quot;ArrayList&quot; ofType=&quot;Post&quot;</code> 等同于结果为：ArrayList<post></post></p>
</blockquote>
<h4 id="集合的嵌套结果映射"><a href="#集合的嵌套结果映射" class="headerlink" title="集合的嵌套结果映射"></a>集合的嵌套结果映射</h4><pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
&lt;/select&gt;</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h4 id="集合的多结果集（ResultSet）"><a href="#集合的多结果集（ResultSet）" class="headerlink" title="集合的多结果集（ResultSet）"></a>集合的多结果集（ResultSet）</h4><p>可以通过执行存储过程来实现，存储过程会执行两个查询并返回两个结果集。</p>
<pre><code class="sql">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}</code></pre>
<p>在映射时，必须通过 resultSets 属性为每个结果集指定一个名字，使用逗号隔开。</p>
<pre><code class="xml">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt;
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;</code></pre>
<p>指定结果集的数据进行填充</p>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="鉴别器（discriminator）"><a href="#鉴别器（discriminator）" class="headerlink" title="鉴别器（discriminator）"></a>鉴别器（discriminator）</h3><p>有时，一个数据库查询可能会返回多个不同的结果集。鉴别器元素就是被设计出来应对这种情况的，也能处理如类的继承层次结构的问题。类似于 java 语言中的 switch 语句。</p>
<pre><code class="xml">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</code></pre>
<h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><p>在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，则需要自行构建一个结果映射。</p>
<h2 id="六、缓存"><a href="#六、缓存" class="headerlink" title="六、缓存"></a>六、缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，可以非常方便地配置和定制。</p>
<p>默认情况下，只启用了本地的会话缓存，仅对一个会话中的数据进行缓存。要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<blockquote>
<cache>
</cache></blockquote>
<p>其效果如下：</p>
<ul>
<li>映射语句文件中的所有 select 结果都将被缓存</li>
<li>映射语句文件中的所有 insert、update、delete 都会刷新缓存</li>
<li>缓存会使用 最少使用算法 来清除不需要的缓存</li>
<li>缓存不会定时进行刷新</li>
<li>缓存会保存列表或对象的1024个引用</li>
<li>缓存会被视为读/写缓存，意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或县城所做的潜在修改</li>
</ul>
<blockquote>
<p>缓存只作用于 cache 标签所在的映射文件中的语句。混用 API和XML，在共用接口中的语句将不会被默认缓存。 可以修改cache 元素的属性：</p>
</blockquote>
<pre><code class="xml">&lt;cache 
       eviction=&quot;FIFO&quot; // FIFO缓存
       flushInerval=&quot;60000&quot; // 每隔60秒刷新
       size=&quot;512&quot;         // 最多可存512个引用
       readOnly=&quot;true&quot;  // 返回对象只读
/&gt;</code></pre>
<p>可用的清除策略：</p>
<ul>
<li>LRU - 最近最少使用：移除最长时间不被使用的对象</li>
<li>FIFO - 先进先出：按对象进入缓存的顺序来移除他们</li>
<li>SOFT - 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li>WEAK - 弱引用：更积极地基于垃圾回收期状态和弱引用规则移除对象</li>
</ul>
<h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><p>通过实现 Cache 接口或者第三方缓存方案，来完全覆盖缓存行为。</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;</code></pre>
<blockquote>
<p>上面说到的缓存配置（如清除策略、可读写等），不适用于自定义缓存</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">koral</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://luokaiii.github.io/2019/09/05/读书笔记/《Mybatis》/3_XML映射文件/">http://luokaiii.github.io/2019/09/05/读书笔记/《Mybatis》/3_XML映射文件/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://luokaiii.github.io">凯</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/hide/">hide</a><a class="post-meta__tags" href="/tags/MyBatis/">MyBatis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/09/05/读书笔记/《Mybatis》/4_动态SQL/"><i class="fa fa-chevron-left">  </i><span>《MyBatis》读书笔记 - MyBatis 动态SQL</span></a></div><div class="next-post pull-right"><a href="/2019/09/05/读书笔记/《SpringSecurity》/23.自定义权限验证/"><span>《Spring Security》自定义权限验证@PreAuthorize</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By koral</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>